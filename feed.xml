<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://neutrinox4b1.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://neutrinox4b1.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-10-16T23:45:40+00:00</updated><id>https://neutrinox4b1.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Privilege Escalation: python library hijacking</title><link href="https://neutrinox4b1.github.io/blog/2025/privilege-escalation-python-library-hijacking/" rel="alternate" type="text/html" title="Privilege Escalation: python library hijacking"/><published>2025-10-15T01:30:04+00:00</published><updated>2025-10-15T01:30:04+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/privilege-escalation-python-library-hijacking</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/privilege-escalation-python-library-hijacking/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[&nbsp; &nbsp; Python에서는 Numpy, Pandas, requests 같은 여러 라이브러리를 가져올 수 있으며, 라이브러리는 모듈을 포함한다. 모듈은 import , from 명령어를 통해 간단히 가져와 사용할 수 있도록 되어있다. &nbsp; 이러한 파이썬 모듈들은 import sys; print(sys.path) 로 확인해볼 수 있다. &nbsp; sys.path는 인터프리터가 사용하는 경로들을 담고 있으며, python은 여기에서 순서대로 모듈을 찾아 사용한다. &nbsp; 만약, SetUID가 설정된 파일이 Python 스크립트로 작성되어있고, 임포트한 모듈에 쓰기 권한이 존재하는 등의 방식으로 정상 라이브러리를 가로챌 수 있다면 공격자는 함수를 편집하여 권한 상승을 수행할 수 있을 것이다. &nbsp; 이러한 공격을 python library hijacking 이라고 하며, 공격 방식에 대해 알아보자. &nbsp; &nbsp; 공격 대상 탐색 공격을 통해 권한 상승을 수행하기 위해서는 SUID/SGID 걸려있는 바이너리이거나, SUDO로 실행할 수 있는 바이너리이어야 한다. &nbsp; SetUID/SetGID find / -perm -4000 2&gt; /dev/null #set uid only find / -perm -2000 2&gt; /dev/null #set gid only find / -perm /6000 2&gt; /dev/null #set uid or set gid &nbsp; &nbsp; sudo sudo -l &nbsp; 또한 덮어쓸 모듈은 Python 인터프리터에 내장된 Built-in(re, sys, os, time 등) 이 아니라 외부 라이브러리여야 한다. &nbsp; &nbsp; 취약점 케이스 1. 잘못된 쓰기 권한 만약 모듈 파일(.py)에 모든 사용자를 대상으로 쓰기 권한이 존재한다면, 이를 덮어씀으로써 원하는 코드를 실행할 수 있다. 일반적으로 파이썬 모듈은 rw-r--r-- 권한으로 설정되어있다. &nbsp; 2. 잘못된 권한 설정에 따른 더 높은 우선순위 경로 파이썬 모듈을 가져올 때, sys.path에 들어있는 순서(우선순위)대로 모듈 파일을 검색하고 가져온다고 했다. 이는 즉, 동일한 이름의 모듈이 정상적인 모듈 파일보다 상위 우선순위 경로에 있으면, 해당 모듈을 가져온다는 것이다. 따라서 모듈이 들어있는 디렉토리에는 쓰기 권한을 설정하지 말아야 한다. &nbsp; 다음 명령어를 통해 sys.path 의 권한을 확인해볼 수 있다. &nbsp; python3 -c "import sys; print('\n'.join(sys.path))" | while read path; do [ -n "$path" ] &amp;&amp; ls -ld "$path" 2&gt;/dev/null; done &nbsp; &nbsp; 3. PYTHONPATH 환경 변수 PYTHONPATH 환경 변수는 파이썬 인터프리터가 import 문을 처리할 때 특정 경로를 추가로 탐색하도록 설정하는 기능을 가진다. PYTHONPATH 에서 설정한 경로는 sys.path의 앞 부분에 추가된다. 즉, 높은 우선순위를 가지는 것이다. &nbsp; 따라서 우선 순위는 다음과 같다. 현재 디렉토리(스크립트 위치) &gt; PYTHONPATH 경로 &gt; 표준 라이브러리 경로 &gt; site-packages 경로 PYTHONPATH 환경변수 설정 권한이 있는지는 sudo -l 로 확인한다. 확인이 안되면 일단 시도해보는 것도 방법이다. &nbsp; &nbsp; 예시 Hackthebox의 Updown 문제에서는 SetUID가 걸려있는 바이너리 내부에서 /home/developer/dev/siteisup_test.py 를 호출하고 &nbsp; &nbsp; import requests url=input("Enter URL here:") page=requests.get(url) if page.status_code == 200: print "Website is up" else: print "Website is down" &nbsp; 해당 파일의 내용은 위와 같다. 이 때 requests 모듈을 임포트하므로, 잘못된 쓰기 권한은 일단 패스한다. 통상적으로 rw-r--r-- 권한이 설정된다. &nbsp; drwxr-xr-x 30 root root 16384 Aug 2 2022 /usr/lib/python3.8 drwxr-xr-x 2 root root 12288 Aug 2 2022 /usr/lib/python3.8/lib-dynload drwxrwsr-x 2 root staff 4096 Jun 15 2022 /usr/local/lib/python3.8/dist-packages drwxr-xr-x 124 root root 12288 Aug 29 2022 /usr/lib/python3/dist-packages &nbsp; 경로를 확인해보면 www-data(현재 유저)에서는 쓰기 권한이 없다는 것을 알 수 있다. 마지막 방법으로 /tmp 와 같은 경로에 requests.py 로 동일한 이름의 모듈을 만들어두고, 다음과 같이 코드를 작성한다. &nbsp; echo "import pty; pty.spawn('/bin/bash')" &gt;&gt; /tmp/requests.py cd /home/developer/dev PYTHONPATH=/tmp ./siteisup &nbsp; &nbsp; PYTHONPATH를 tmp로 지정함으로써, SetUID가 설정된 상태에서 쉘을 가져오므로, developer 유저로 UID가 설정되어 쉘이 떨어지게 된다.]]></summary></entry><entry><title type="html">Kerberos attacks: Roasting (AS-REP Roasting &amp;amp; Kerberosting)</title><link href="https://neutrinox4b1.github.io/blog/2025/kerberos-attacks-roasting-as-rep-roasting-amp-kerberosting/" rel="alternate" type="text/html" title="Kerberos attacks: Roasting (AS-REP Roasting &amp;amp; Kerberosting)"/><published>2025-10-10T00:06:59+00:00</published><updated>2025-10-10T00:06:59+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/kerberos-attacks-roasting-as-rep-roasting-amp-kerberosting</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/kerberos-attacks-roasting-as-rep-roasting-amp-kerberosting/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Kerberos Kerberos에 대한 동작 과정은 이전에 설명한 적이 있었다. https://neutrinox4b1.tistory.com/62 &nbsp; Windows 도메인 네트워크 인증 프로토콜 Windows 도메인을 사용할 때 모든 자격증명은 Domain Controller(DC)에 저장된다. 사용자가 도메인 자격증명을 사용하여 서비스에 인증하려고 할 때마다, 서비스는 도메인 컨트롤러에 자격증명이 올바 neutrinox4b1.tistory.com &nbsp; 일반적인 Kerberos 인증 과정은 다음과 같다. &nbsp; &nbsp; AS-REQ에서 클라이언트는 타임스탬프를 자신의 비밀번호 해시 값으로 암호화한 뒤, 유저 이름과 함께 보내면, DC에서는 NTDS.dit내에 유저의 비밀번호 해시값을 조회하여 복호화한다. 복호화가 성공하면 유저 이름/비밀번호를 올바르게 전달한 것이므로 AS-REP를 반환한다.AS-REP에는 유저 비밀번호 해시로 암호화된 Session Key 등과 krbtgt 유저의 해시로 암호화된 TGT가 있다. TGS-REQ에서는 세션 키로 암호화된 사용자 이름, 타임스탬프와 AS-REP로부터 받은 TGT, SPN을 보낸다. SPN(Service Principal Name)은 접근하려는 서비스에 대한 정보이다. 서비스 유형/호스트명:포트/서비스 이름 으로 구성된다.KDC에서는 TGS-REQ를 수신하면 검증을 수행하고 Service Ticket(ST)를 보낸다. ST는 서비스 계정의 NTLM 해시를 키로 사용하여 암호화(RC4-HMAC or AES256)된다. 애플리케이션 서버에 서비스 티켓과 세션키로 암호화된 타임스탬프, 유저명을 보내고 애플리케이션 서버에서는 자신의 해시를 하여 검증을 수행한다. 확인 완료되면 요청된 리소스에 대한 액세스를 허가하는 AP-REP 응답을 전송한다. Roasting 이라고 하는 기법은 암호화된 티켓(세션 키)을 탈취한 후 무차별 대입 공격을 통해 비밀번호를 크랙하는 공격 방식을 말한다. 쉽게 말해, 해시(실제로는 해시가 아님)를 훔치고 브루트 포싱하는 것이다. 1, 2 단계에서 사용된다. &nbsp; &nbsp; AS-REP Roasting 기본적으로 AD 사용자 계정 컨트롤(UAC) 설정에서 &ldquo;Kerberos 사전 인증 필요 없음&rdquo;(Do not require Kerberos preauthentication) 이 비활성화 되어있다. &nbsp; 즉, 모든 사용자에 대해 사전 인증이 수행된다는 것이다. &nbsp; &nbsp; 해당 옵션을 수동으로 활성화할 경우, AS-REP Roasting에 취약하다. &nbsp; 예를 들어, 내부 애플리케이션 오류로 인해 문제를 해결하는 동안만 임시로 활성화해두기로 하였으나, 비활성화하는 것을 잊고 계속 활성화해두는 경우가 있다. &nbsp; 위 Kerberos 동작 과정 1번에서는 클라이언트가 유저 이름과 함께 해싱된 비밀번호를 보냄으로써 Preauthentication을 수행하였다. &nbsp; 반면, preauthentication을 수행하지 않는 경우, 누구든지 특정 사용자를 대신하여 AS-REQ를 보낼 수 있다. 유저 비밀번호 해시를 보내지 않고도 유저명만 보내면 AS-REP를 받을 수 있는 것이다. &nbsp; 공격자는 AS-REP를 메모리상에서 추출해서 브루트포싱을 수행하고, 특정 비밀번호 해시로 복호화를 수행했을 때 PAC(Privilege Attribute Certificate) 구조가 유효한지 확인한다. PAC는 유저 해시로 암호화된 값이다. &nbsp; 만약, 복호화에 성공한다면 해당 유저의 비밀번호를 알아낸 것이다. &nbsp; &nbsp; 공격 방법 AS-REP roasting 시에 이미 유저명을 username.txt 로 리스팅해둔 경우, 다음과 같이 시도할 수 있다. -no-pass는 도메인 유저로 접속 가능한 계정이 아예 없으므로 사용된다. Impacket-GetNPUsers &lt;domain&gt;/ -usersfile username.txt -dc-ip &lt;ip&gt; -no-pass -format hashcat -outputfile hashes.txt &nbsp; 이후 hashcat이나 john으로 브루트포스를 수행한다. 조건 도메인 유저 이름을 알고 있음 AD에서 대상 계정에 대한 Kerberos preauthentication이 비활성화 되어있음 결과 도메인 사용자 패스워드 획득 &nbsp; 탐지 및 대응 방안 Do not require Kerberos preauthentication 옵션을 가진 유저를 확인하고 필요하지 않다면 비활성화 한다. &nbsp; DC에서 이벤트 ID 4768 (Kerberos 인증 티켓 요청)로 로그를 필터링하고, 이벤트 정보에서 Pre-Authentication Type이 0(비활성화) 인지, 서비스 이름이 krbtgt이고, Ticket Encryption Type이 0x17(RC4, 해시 해독이 쉬움) 인지 확인함으로써 침해 정황을 파악한다. &nbsp; Kerberosting Kerberosting은 2014년 DerbyCon 컨퍼런스에서 Tim Medin이 발표한 공격이다. 이는 공격자가 사용자로 가장하여, TGS-REQ를 통해 서비스를 요청함으로써 해시를 탈취한다. 서비스 계정 해시가 TGS-REP에 있으므로, 공격자는 TGS-REP의 해시를 해독하여 서비스 비밀번호 값을 얻어낼 수 있다. &nbsp; 공격 방법 GetUserSPNs 를 통해 SPN이 등록된 서비스 계정 목록을 확인할 수 있으며, -request 옵션을 주면 TGS 티켓의 암호화 해시를 추출해주기도 한다. &nbsp; 파일 형태로 저장하려면 다음과 같이 수행한다. &nbsp; impacket-GetUserSPNs &lt;domain&gt;/&lt;username&gt;:&lt;password&gt; -dc-ip &lt;ip&gt; -save -outputfile GetSPNs.out &nbsp; &nbsp; 조건 유효한 도메인 계정이 있음 대상이 SPN에 등록된 계정임 결과 서비스 계정의 패스워드 획득 &nbsp; 탐지 및 대응 방안 MSA, gMSA를 사용해서 강력한 비밀번호가 설정되도록 한다. &nbsp; FGPP(Fine-Grained Password Policy)로 강한 비밀번호 사용을 강제화한다. &nbsp; ST 암호화를 RC4-HMAC이 아닌 AES-256으로 설정한다. &nbsp; 이벤트 ID 4769 (Kerberos 서비스 티켓 요청)중 서비스나 머신 계정(`$`로 끝남)이 아닌 일반 도메인 사용자 계정(`$`로 끝나지 않음)으로 Account Name이 설정되었으며, 서비스 이름이 `$`로 끝나지 않고, Ticket Encryption Type가 0x17(RC4) 인지 확인하여 침해 정황을 확인한다. &nbsp; Powershell 로그에서 이벤트 ID 4104 (실행된 명령/스크립트)를 확인했을 때, Kerberostable 계정을 열거하려고 ps 스크립트를 실행한 흔적이 있는지, Prefetch를 확인했을 때, Rubeus같은 도구의 사용 흔적이 있는 지 확인한다.]]></summary></entry><entry><title type="html">HTTP(S), SMTP, POP3, IMAP 기본</title><link href="https://neutrinox4b1.github.io/blog/2025/https-smtp-pop3-imap/" rel="alternate" type="text/html" title="HTTP(S), SMTP, POP3, IMAP 기본"/><published>2025-01-23T05:44:28+00:00</published><updated>2025-01-23T05:44:28+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/https-smtp-pop3-imap-</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/https-smtp-pop3-imap/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[HTTP(S) 메소드 GET HTML 파일이나 이미지 등의 데이터를 서버에서 검색 POST 양식을 제출하거나 파일을 업로드하는 등 서버에 새로운 데이터를 제출 PUT 서버에 새로운 리소스를 생성하고 기존 정보를 업데이트, 덮어쓰는데 사용 DELETE 서버에서 지정된 파일이나 리소스를 삭제하는데 사용 HTTP는 80/tcp 사용, HTTPS는 443/tcp 사용 $ telnet &lt;ip addr&gt; 80 GET / HTTP/1.1 Host: &lt;ip&gt; &nbsp; 이런 식으로 사용 가능하며, 마지막에 개행이 두 번 들어가야 보내짐 &nbsp; FTP (File Transfer Protocol) 파일 전송에 최적화된 프로토콜임 USER 사용자 이름 입력 PASS 패스워드 입력 RETR FTP 서버에서 클라이언트로 파일 다운로드 시 사용 STOR 클라이언트에서 서버로 파일 업로드 시 사용 FTP 서버는 기본적으로 21번 포트를 사용하여 수신함 데이터 전송은 다른 연결을 맺어 수행됨 &nbsp; $ ftp &lt;IP addr&gt; USER &lt;username&gt; PASS &lt;password&gt; LIST ls type ascii get &lt;filename&gt; quit &nbsp; type을 통해 binary인지, ascii인지를 명시하여야 함. binary 타입으로 텍스트파일을 가져올 시 텍스트가 꺠질 수 있음 &nbsp; SMTP (Simple Mail Transfer Protocol) SMTP는 이메일을 보내는데에 사용됨 HELO 또는 EHLO SMTP 세션을 시작함 MAIL FROM 발신자 이메일 주소를 지정함 RCPT TO 수신자 이메일 주소를 지정함 DATA 클라이언트가 이메일 내용을 보내기 시작함을 의미함 . 한 줄에 전송함으로써 끝을 나타냄 SMTP는 25/tcp 포트를 사용함 $ telnet &lt;IP addr&gt; 25 HELO client.thm MAIL FROM: &lt;user@client.thm&gt; RCPT TO: &lt;strategos@server.thm&gt; DATA From: user@client.thm To: strategos@server.thm Subject: Telnet email Hello. I am using telnet to send you an email! . QUIT &nbsp; &nbsp; &nbsp; POP3 (Post Office Protocol v3) 이메일을 수신하고 로컬 메일 클라이언트에 다운로드 하는데 사용됨. POP3는 클라이언트가 메일서버와 통신하고 메시지를 검색할 수 있도록 설계됨 &nbsp; USER &lt;username&gt; 사용자 식별 PASS &lt;password&gt; 사용자 비밀번호 제공 STAT 메시지 수와 총 크기를 요청함 LIST 모든 메시지와 해당 크기를 나열함 RETR &lt;message_number&gt; 메시지를 검색함 DELE &lt;message_number&gt; 메시지를 삭제함 QUIT 변경사항을 적용하여 POP3 세션을 종료함 POP3는 기본적으로 110/tcp 를 사용함 $ telnet &lt;IP addr&gt; 110 AUTH USER linda PASS Pa$$123 STAT LIST RETR 3 QUIT &nbsp; &nbsp; &nbsp; IMAP (Internet Message Access Protocol) 한 기기에서 작업할 때는 POP3로 충분하지만, 여러 클라이언트에서 이메일을 확인하고 동기화를 수행할 필요가 있을 때는 IMAP을 사용하는 것이 적절함 IMAP는 POP3와 달리 이메일을 서버에 보관하고 이메일 클라이언트간에 동기화를 수행하여 더 많은 저장소를 사용함 LOGIN &lt;username&gt; &lt;password&gt; 사용자를 인증함 SELECT &lt;mailbox&gt; 작업할 사서함 폴더를 선택함 FETCH &lt;mail_number&gt;&nbsp; &lt;data_item_name&gt; FETCH 3 body[] 메시지 번호 3, 헤더 본문을 가져옴 MOVE &lt;sequence_set&gt; &lt;mailbox&gt; 지정된 메시지를 다른 사서함으로 이동함 COPY &lt;sequence_set&gt; &lt;mailbox&gt; 지정된 메시지를 다른 사서함으로 복사함 LOGOUT 로그아웃 143/tcp 를 사용함 $ telnet &lt;IP addr&gt; 143 LOGIN strategos Pa$$123 SELECT inbox FETCH 3 body[] LOGOUT &nbsp; &nbsp; Ref. [1] TryHackMe, "Networking Core Protocols," [Online]. Available: https://tryhackme.com/r/room/networkingcoreprotocols. [Accessed: Jan. 23, 2025].]]></summary></entry><entry><title type="html">DHCP의 DORA</title><link href="https://neutrinox4b1.github.io/blog/2025/dhcp-dora/" rel="alternate" type="text/html" title="DHCP의 DORA"/><published>2025-01-23T05:42:23+00:00</published><updated>2025-01-23T05:42:23+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/dhcp-dora</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/dhcp-dora/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[DHCP는 DORA 절차를 가진다. Discover Discover는 로컬 서버를 찾기 위해 브로드캐스트를 보낸다. Offer Request Acknowledge &nbsp; &nbsp; user@TryHackMe$ tshark -r DHCP-G5000.pcap -n 1 0.000000 0.0.0.0 &rarr; 255.255.255.255 DHCP 342 DHCP Discover - Transaction ID 0xfb92d53f 2 0.013904 192.168.66.1 &rarr; 192.168.66.133 DHCP 376 DHCP Offer - Transaction ID 0xfb92d53f 3 4.115318 0.0.0.0 &rarr; 255.255.255.255 DHCP 342 DHCP Request - Transaction ID 0xfb92d53f 4 4.228117 192.168.66.1 &rarr; 192.168.66.133 DHCP 376 DHCP ACK - Transaction ID 0xfb92d53f &nbsp; 첫 번째 Discover과 세번째 Request에서 아직 DHCP 연결이 이루어지지 않았으므로 클라이언트는 MAC 주소만을 가지고 있고 IP주소는 0.0.0.0으로 브로드캐스트 주소 255.255.255.255에 패킷을 보낸다. 이는 링크 게층에서 브로드캐스트 MAC 주소 ff:ff:ff:ff:ff:ff 으로 사용된다. &nbsp; DHCP 프로세스가 끝나면, DHCP로부터 클라이언트는 다음을 받는다. 네트워크 리소스에 접근하기 위한 임대 IP 주소 로컬 네트워크 외부로 패킷을 라우팅하는 게이트웨이 도메인 이름을 확인하기 위한 DNS 서버 DHCP는 포트번호 67/UDP를 통해 수신하고 68/UDP로 송신한다. &nbsp; Ref. [1] TryHackMe, "Networking Essentials," [Online]. Available: https://tryhackme.com/r/room/networkingessentials. [Accessed: Jan. 23, 2025]. &nbsp;]]></summary></entry><entry><title type="html">Windows PowerShell 기본</title><link href="https://neutrinox4b1.github.io/blog/2025/windows-powershell/" rel="alternate" type="text/html" title="Windows PowerShell 기본"/><published>2025-01-23T05:36:58+00:00</published><updated>2025-01-23T05:36:58+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/windows-powershell-</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/windows-powershell/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[소개 https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.4 PowerShell은 명령줄 쉘, 스크립팅 언어 및 구성 관리 프레임워크로 구성된 크로스 플랫폼 자동화 솔루션이다. PowerShell은 command line 인터페이스와 .NET 프레임워크에 기반한 스크립팅 언어를 결합하였다. 텍스트 기반 Command Line 도구와 달리 객체지향적이므로 복잡한 데이터 유형을 처리하고 시스템 구성 요소와 보다 효과적으로 상호작용 할 수 있다. &nbsp; 역사 2000년대 초, cmd.exe 배치 파일과 같은 기존 도구는 복잡한 엔터프라이즈 환경 시스템을 자동화하고 관리하는데에 한계가 있었다. MS에서는 Windows 최신 API와 상호작용 할 수 있는 도구가 필요했다. MS 엔지니어인 Jeffry Snover는 Windows가 Unix와 달리, 구조화된 데이터와 API를 사용한다는 것을 깨달았다. Unix는 모든 것을 텍스트파일로 처리했다. 이러한 차이로, Unix 도구를 Windows로 이식하는 것이 비실용적이었다. Snover는 이에 스크립팅의 단순성과 .NET 프레임워크의 힘을 결합한 객체지향 방식을 개발하고자 했다. 2006년데 PowerShell이 출시되며 관리자는 객체를 조작하여 작업을 보다 효과적으로 자동화할 수 있고 Windows 시스템과 더욱 밀접하게 통합되었다. 2016년 MS에서는 Windows, macOS, Linux에서 실행되는 오픈 소스 및 크로스 플랫폼 버전인 PowerShell Core을 출시하기도 하였다. &nbsp; The Power of PowerShell 객체는 속성과 메서드가 있는 항목을 의미한다. 예를 들어, 객체 car는 속성 Color, Model, FuelLevel 을 가질 수 있고 메서드로는 Drive(), HonkHorn(), Refuel() 을 가질 수 있다. PowerShell에서 객체도 마찬가지로 데이터와 기능을 캡슐화하는 기본 단위로 정보를 관리하고 조작하기 쉽게 해준다. 객체는 파일명, 유저명, 크기 등을 속성을 포함할 수 있고 파일 복사나 프로세스 중지 같은 메서드를 수행할 수 있다. 기존 Command Shell에서 기본 명령은 텍스트 기반으로, 데이터를 일반 텍스트로 처리하고 출력하지만 PowerShell에서 cmdlet을 실행하면 속성과 메서드를 유지하는 객체를 반환한다. &nbsp; PowerShell 사용 powershell 해당 명령어를 사용하면 현재 작업디렉토리에 PS 가 표시된다. &nbsp; cmdlets cmdlets는 동사-명사 명명 규칙을 따른다. 이 구조는 cmdlet이 무엇을 하는지 이해하기 쉽도록 한다. 동사는 작업을 설명하고 명사는 작업이 수행되는 개체를 지정한다. 예를 들어 Get-Content는 파일의 내용을 검색하여 콘솔에 표시, Set-Location은 현재 작업 디렉토리를 변경(설정)한다. &nbsp; &nbsp; 기본 cmdlet Get-Command Get-Command는 현재 PowerShell 세션에서 사용할 수 있는 모든 cmdlet, 함수, alias 및 스크립트를 나열한다. -CommandType "Function" 이나 -Name "Remove*" 처럼 옵션을 추가할 수 있다. &nbsp; Get-Help Get-Help는 명령어 사용법을 배우는데 필요한 cmdlet이다. Get-Help &lt;cmdlet&gt; 와 같이 사용한다. linux의 man과 비슷하다. -examples 옵션은 몇가지 예시를 보여준다. &nbsp; Get-Alias Get-Alias는 별칭을 나열한다. &nbsp; &nbsp; 이래서 리눅스 명령어와 powershell이 유사한 명령어를 가지던 것이었구나 싶다. 주요 리눅스 명령어들이 cmdlet alias로 지정되어있다. &nbsp; &nbsp; Find-Module Find-Module은 온라인 저장소에서 cmdlet을 검색하는데에 사용할 수 있는 명령어이다. Find-Module -Name "PowerShell*&rdquo; 이렇게 사용할 수 있다. 설치는 Install-Module 명령어를 통해 설치할 수 있다. Install-Module -Name "PowerShellGet" &nbsp; 파일 시스템 탐색 및 파일 작업 Get-ChildItem Get-Childitem은 dir, ls와 유사하게 지정된 위치에 있는 파일과 디렉토리를 나열한다. &nbsp; Set-Location -Path 옵션을 통해 특정 디렉토리로 이동할 수 있다. cd와 유사함 &nbsp; &nbsp; New-Item New-Item은 item을 생성하는데에 사용할 수 있다. 아이템의 경로와 유형(파일 or 디렉토리)를 지정해주어야 한다. New-Item -Path ".\captain-wardrobe" -ItemType "Directory" &nbsp; &nbsp; Remove-Item 이는 cmd의 rmdir이나 del과 유사하며, -Path를 지정해주어야 한다. &nbsp; Copy-Item 이는 copy와 동일하며 -Path 와 -Destination 을 지정해야 한다. &nbsp; Get-Content 이는 cmd의 type 또는 리눅스의 cat과 유사하게 동작한다 지정한 -Path의 내용을 화면에 표시한다. &nbsp; &nbsp; 데이터 파이핑, 필터링 및 정렬 pipe 명령어는 PowerShell에서도 사용 가능하다. PowerShell에서는 텍스트만이 아니라 객체를 전달하기 때문에 더욱 강력한 기능을 가진다. 예를 들어, 디렉토리에 있는 파일 목록을 가져온 다음 크기별로 정렬하려면 Get-ChildItem | Sort-Object Length 을 사용할 수 있다. &nbsp; &nbsp; Where-Object Where-Object는 지정된 조건에 따라 객체를 필터링 하기 위해 사용할 수 있다. Get-ChildItem | Where-Object -Property "Extension" -eq ".txt" &nbsp; &nbsp; -eq 는 같다는 의미, -ne는 같지 않음, -gt는 ~보다 큼 -ge 는 크거나 같음, -lt는 작음 -le는 작거나 같음 Get-ChildItem | Where-Object -Property "Name" -like "ship*" -like 를 이용하여 지정된 패턴과 일치하는 속성으로 객체를 필터링할 수 있다. &nbsp; &nbsp; Select-Object &nbsp; &nbsp; Get-ChildItem | Select-Object Name, Length &nbsp; Name과 Length만 표시하도록 출력을 필터링한다. 그리고 Get-ChildItem | Sort-Object Length -Descending | Select-Object -First 1 &nbsp; 현재 폴더에서 가장 크기가 큰 파일을 선택하는 파이프라이닝 &nbsp; &nbsp; Select-String 이는 리눅스의 grep, 윈도우의 findstr과 유사하게 문서 내 특정 콘텐츠를 찾는데 사용된다. Select-String -Path ".\captain-hat.txt" -Pattern "hat" &nbsp; &nbsp; 이렇게 하면 captain-hat.txt에서 hat이라는 문자열이 있는 행을 찾을 수 있다. 해당 명령어는 regex를 지원한다. &nbsp; &nbsp; 시스템 및 네트워크 정보 Get-ComputerInfo Get-ComputerInfo 명령어는systeminfo와 유사하게 운영체제 정보, 하드웨어 사양, BIOS 세부 정보 등을 제공한다. systeminfo 보다 많은 정보를 제공한다고 한다. &nbsp; Get-LocalUser 이는 사용자 계정을 관리하고 머신의 보안 구성을 이해하는데 필수적이다. Get-LocalUser는 시스템의 모든 로컬 사용자 계정을 나열한다. 사용자 이름, 계정 상태, 설명을 표시한다. &nbsp; &nbsp; Get-NetIPConfiguration IP주소, DNS서버, 게이트웨이 구성을 포함하여 시스템의 네트워크 인터페이스에 대한 자세한 정보를 제공한다. &nbsp; &nbsp; Get-NetIPAddress 네트워크 인터페이스에 할당된 IP주소의 세부정보가 필요할때는 Get-NetIPAddress 명령어를 사용한다. 이는 현재 활성화되지 않은 IP 주소를 포함하여, 시스템의 모든 IP주소에 대한 세부 정보를 표시한다. &nbsp; &nbsp; 실시간 시스템 분석 Get-Process Get-Process는 CPU와 메모리 사용량을 포함하여 현재 실행중은 모든 프로세스에 대한 자세한 정보를 제공한다. &nbsp; &nbsp; Get-Service 실행중인 서비스, 중지되거나 일시중지된 서비스 정보를 나타낸다. &nbsp; &nbsp; Get-NetTCPConnection 현재 TCP 연결을 표시한다. 침해대응 및 멀웨어 분석 작업 중에 유용하다. 공격자가 제어하는 서버에 대한 백도어, 연결을 발견할 수 있기 때문임 &nbsp; Get-FileHash 파일 해시를 생성한다. -Path를 통해 파일을 지정한다. &nbsp; 스크립팅 Invoke-Command Invoke-Command는 원격 시스템에서 명령을 실행하는데 필수적이다. Invoke-Command -FilePath c:\scripts\test.ps1 -ComputerName Server01 와 같이 스크립트와 결합하여 원격 컴퓨터의 작업을 자동화 할 수 있고, Invoke-Command -ComputerName Server01 -Credential Domain01\User01 -ScriptBlock { Get-Culture } 처럼 원격 컴퓨터로 -ScriptBlock을 이용하여 명령어를 입력할 수 있다. &nbsp; &nbsp; Ref. [1] TryHackMe, "Windows PowerShell," [Online]. Available: https://tryhackme.com/r/room/windowspowershell. [Accessed: Jan. 23, 2025]. &nbsp;]]></summary></entry><entry><title type="html">Windows 도메인 네트워크 인증 프로토콜</title><link href="https://neutrinox4b1.github.io/blog/2025/windows/" rel="alternate" type="text/html" title="Windows 도메인 네트워크 인증 프로토콜"/><published>2025-01-18T16:47:05+00:00</published><updated>2025-01-18T16:47:05+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/windows----</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/windows/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Windows 도메인을 사용할 때 모든 자격증명은 Domain Controller(DC)에 저장된다. 사용자가 도메인 자격증명을 사용하여 서비스에 인증하려고 할 때마다, 서비스는 도메인 컨트롤러에 자격증명이 올바른지 확인하도록 요청한다. &nbsp; Windows 도메인에서 네트워크 인증에는 다음 두 가지 프로토콜을 사용할 수 있다. &nbsp; Kerberos &nbsp; &nbsp; Kerberos는 최신 버전 Windows에서 사용되는 인증 프로토콜로, 최신 도메인에서 디폴트로 설정되어 있다. Kerberos의 방식은 Needham-Schroeder (NS) 프로토콜에서 영감을 받았다. Needham-Schroeder protocol Needham-Schroeder 프로토콜은 신뢰된 서버를 사용하는 프로토콜 중 하나로 잘 알려져 있다. 1978년에 개발되었으며, 키 교환에서 매우 중요한 프로토콜이다. &nbsp; &nbsp; A는 서버 S에 A의 아이디, B의 아이디, $N_A$ 라는 A의 nonce값을 전송한다. 서버 S는 $K_{AS}$ 로 대칭키 암호화하여, $N_A$, B의 아이디, AB의 세션키 $K_{AB}$, 그리고 $K_{BS}$로 A의 아이디와 $K_{AB}$ 를 암호화 한 값을 전송한다. &nbsp; A는 $K_{AS}$를 통해 세션키 $K_{AB}$를 얻을 수 있고, $SKE_{K_{BS}}(K_{AB}, A)$ 는 그대로 전송한다. B는 $K_{BS}$를 통해 이를 복호화하여 $K_{AB}$와 A의 아이디를 확인할 수 있다. &nbsp; 이후, B는 A에게 세션키 $K_{AB}$를 잘 가지고있음을 확인하고자 $N_B$를 암호화하여 보내고 A는 $K_{AB}$로 $N_B-1$을 전송하여 서로 세션키를 확인할 수 있게 된다. &nbsp; 해당 Needham-Schroeder 프로토콜에서는 B의 입장에서 $K_{AB}$의 freshness가 보장되지 않는다는 문제가 존재한다. &nbsp; &nbsp; Kerberos 동작 과정 이에 Kerberos에서는 timestamp와 lifetime을 사용하여 이를 해결하였다. &nbsp; &nbsp; 사용자는 이름과 타임스탬프를 Key Distribution Center(KDC)로 보낸다. KDC는 Windows 도메인 네트워크에서 Domain Controller에 설치되는 서비스가 된다. &nbsp; &nbsp; KDC는 Ticket Granting Ticket(TGT)를 생성하여 사용자에게 보낸다. 이때 세션 키(TGS 세션키)도 함께 제공한다. TGT는 krbtgt 계정의 비밀번호 해시를 사용하여 암호화된다. TGT에는 유저 아이디, 세션키가 들어있다. &nbsp; &nbsp; 사용자가 네트워크 서비스에 연결하려고 할 때, TGT를 사용하여 KDC에 Ticket Granting Service(TGS)를 요청해야 한다. TGS를 요청하려면 TGT, Service Principal Name (SPN), 세션 키로 암호화된 사용자 이름, 타임 스탬프를 보내야 한다. &nbsp; SPN은 액세스하려는 서비스, 서버 이름을 나타낸다. 위 그림에서는 MSSQL 서비스, SRV 서버에 접근하려고 나타낸다. &nbsp; TGS를 요청하면 KDC는 서비스 세션 키, TGS를 보낸다. 이는 서비스 소유자 해시에서 파생된 키를 사용하여 암호화된다. TGS에는 서비스 세션 키가 들어있다. &nbsp; &nbsp; 이후, TGS를 원하는 서비스로 보내어 인증하고 연결을 설정한다. 서비스는 Owner Hash를 이용하여 TGS를 해독하고 서비스 세션 키를 검증한다. &nbsp; &nbsp; NetNTLM(NT LAN Manager) NetNTLM은 호환성을 위해 유지되는 레거시 인증 프로토콜이다. Challenge-response authentication 메커니즘을 사용하여 작동한다. &nbsp; 클라이언트가 액세스하고자 하는 서버에 인증 요청을 보낸다. 서버에서는 난수를 생성하여 클리어인트에게 Challenge로 전송한다. 클라이언트는 NTLM 비밀번호 해시를 Challenge와 결합하여 서버로 보낸다. 서버는 Domain Controller에 전달한다. DC에서는 전달 받은 Challenge와 알고 있는 NTLM 비밀번호 해시를 가지고 계산해보고, 전달 받은 Response와 비교한다. 인증 결과를 서버에 전송한다 서버는 클라이언트에 인증 결과를 전송한다. 보다 정확히는 다음과 같이 response를 구성한다. SC=8-byte server challenge, random CC=8-byte client challenge, random CC* = (X, time, CC2, domain name) v2-Hash = HMAC-MD5(NT-Hash, user name, domain name) LMv2=HMAC-MD5(v2-Hash, SC, CC) NTv2=HMAC-MD5(v2-Hash, SC, CC*) response=LMv2 | CC | NTv2 | CC* &nbsp; NT 해시는 Security Account Manager(SAM) 또는 Active Directory(AD)에 저장되어있으며, 위에서 언급한 NTLM 비밀번호 해시는 보다 쉬운 이해를 위하여 사용된 용어이다.]]></summary></entry><entry><title type="html">A memory Allocator (Doug Lea의 글) (dlmalloc)</title><link href="https://neutrinox4b1.github.io/blog/2025/a-memory-allocator-doug-lea-dlmalloc/" rel="alternate" type="text/html" title="A memory Allocator (Doug Lea의 글) (dlmalloc)"/><published>2025-01-05T15:48:14+00:00</published><updated>2025-01-05T15:48:14+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/a-memory-allocator-doug-lea--dlmalloc</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/a-memory-allocator-doug-lea-dlmalloc/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[https://gee.cs.oswego.edu/dl/html/malloc.html 오래된 글이지만 유용한 개념같아 번역하여 정리해둔다. 해당 내용은 매우 오래되었으며, malloc의 현재 버전에 대한 세부 정보를 반영하지 않음에 유의 (그래도 ptmalloc의 기본 알고리즘은 dlmalloc과 흡사하게 작동함) Introduction 메모리 할당자는 인프라 소프트웨어 엔지니어링에서 흥미로운 case study를 형성한다. 나(Doug Lea)는 1987년에 하나를 작성하기 시작했고, 이 할당자는 malloc(), free()의 구현, realloc()과 몇가지 보조 유틸리티 루틴을 제공한다. 할당자는 특정 이름을 받은 적은 없지만, 대부분의 사람들은 이를 Doug Lea&rsquo;s Malloc 또는 줄여서 dlmalloc이라고 부른다. 이 할당자에 대한 코드는 퍼블릭 도메인에 공개되었으며, 널리 사용되고 있는 것으로 보인다. 이 코드는 일부 Linux 버전에서 malloc의 기본 네이티브 버전으로 제공되며, 일반적으로 사용 가능한 여러 소프트웨어 패키지(네이티브 malloc을 재정의)에 컴파일되었으며, 내가 모르는 다른 많은 곳에서 사용되었다. &nbsp; 나는 동적 메모리 할당에 거의 전적으로 의존하는 C++ 프로그램을 작성한 후 할당자의 첫번째 버전을 작성하였다. 예상보다 훨씬 느리게 실행되거나 총 메모리 소비량이 훨씬 더 많다는 것을 알게 되었다. 이는 내가 실행중이던 시스템(주로 당시 최신 버전의 SunOs 및 BSD)의 메모리 할당자의 특성 때문이었다. 이를 해결하기 위해 처음에는 C++에서 다양한 클래스에 대해 operator new를 오버로딩하여 여러 특수 목적 할당자를 작성했다. 이 중 일부는 1989년 C++ 보고서에 실린 &ldquo;Some storage allocation techniques for container classes&ldquo;이라는 기사로 각색된 논문에서 설명되었다. &nbsp; 하지만, 나는 동적으로 할당되고 자주 사용되는 클래스마다 특수 할당기를 구축하는 것은 내가 당시 작성중이던 범용 프로그래밍 지원 클래스를 구축할 때 좋은 전략이 아님을 곧 깨달았다.(1986년 부터 1991년까지 나는 GNU C++ 라이브러리(libg++)의 주요 작성자였다.) 보다 넓은 해결책이 필요했는데, 이는 C++ 및 C의 일반적인 로드에서 충분히 성능이 좋은 할당기를 작성하는 것이었다. 이렇게 하면 프로그래머들이 매우 특별한 조건을 제외하고는 특수 목적의 할당기를 작성하려는 유혹을 느끼지 않을 것이다. &nbsp; 이 글에서는 이 할당기의 주요 설계 목표, 알고리즘, 구현 고려사항에 대한 설명을 제시한다. 보다 자세한 문서는 코드 배포본과 함께 제공된다. &nbsp; Goals 좋은 메모리 할당기는 다음과 같은 목표를 균형 있게 고려해야 한다. 호환성 극대화(Maximizing compatibility) 할당기는 다른 할당기와 플러그-호환성(plug-compatible)을 가져야하며, 특히 ANSI/POSIX 규격을 준수해야 한다. 이식성 극대화(Maximizing Portability) 시스템 종속적인 기능(e.g., system call)에 대한 의존성을 최소화하면서, 특정 시스템에만 제공되는 유용한 기능은 선택적으로 지원해야 한다. 정렬 및 주소지정 규칙과 같은 모든 알려진 시스템 제약 조건을 준수해야 한다 공간 최소화(Minimizing Space) 할당기는 공간 낭비를 최소화해야한다. 시스템에서 메모리를 가능한 적게 가져와야 하며, 메모리를 유지 관리할 때 프로그램이 사용하지 않는 청크의 단편화(fragmentation)을 최소화해야 한다. 시간 최소화(Minimizing Time) malloc(), free(), realloc() 루틴은 평균적인 경우 가능한 빨라야 한다 . 튜닝 가능성 극대화(Maximizing Tunability) 선택적 기능과 동작은 사용자가 정적(e.g., #define 등) 또는 동적(e.g., mallopt 와 같은 제어명령)으로 제어할 수 있어야 한다. 지역성 극대화(Maximizing Locallity) 일반적으로 함께 사용되는 메모리 청크를 서로 가까운 위치에 할당해야 한다. 이는 프로그램 실행 중 페이지 및 캐시 미스를 최소화하는데 도움이 된다. 오류 감지 극대화(Maximizing Error Detection) 일반적인 할당자가 Purify와 같은 일반적인 메모리 오류 테스트 도구로도 사용되기는 어렵지만, 할당자는 메모리 덮어쓰기, 다중 해제 등으로 발생하는 손상을 감지하는 수단을 제공해야 한다. 이상 현상 최소화(Minimizing Anomalies) 기본 설정으로 구성된 할당자는 동적 할당에 크게 의존하는 실제 워크로드(e.g., 윈도잉 툴킷, GUI 어플리케이션, 컴파일러, 인터프리터, 개발 도구, 네트워크 패킷 집중 프로그램, 그래픽 집중 패키지, 웹 브라우저, 문자열 처리 애플리케이션)에서 잘 동작해야 한다. &nbsp; 참고 Paul Wilson과 그의 동료들은 이러한 목표 중 일부를 더 자세히 논의하는 훌륭한 할당 기술 서베이 논문을 작성했다. 이 논문은 Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles, ``Dynamic Storage Allocation: A Survey and Critical Review'' in International Workshop on Memory Management, September 1995 이다. Winson et al. 이 논의한 바와 같이 어떠한 할당자에서도 공간 낭비(주로 단편화에 의한)를 최소화하는 것이 가장 중요한 목표여야 한다. 극단적인 예 가장 빠른 버전의 malloc() 중 하나는 시스템에서 사용할 수 있는 다음 연속 메모리 위치를 항상 할당하는 방식으로 구현된다. 이 경우, 가장 빠른 free()는 아무 작업도 하지 않는다. 하지만 이러한 구현은 거의 받아들여질 수 없다. 이는 사용하지 않는 공간을 절대 회수하지 않으므로, 프로그램이 메모리를 빠르게 소진하게 된다. 실제 사용되는 일부 할당자에서 특정 워크로드는 이와 비슷한 극단적인 낭비가 발생할 수 있다. Wilson이 지적한 바와 같이, 낭비는 금전적으로 측정할 수도 있다. 전 세계적으로 보면, 잘못된 할당 방식은 메모리 칩에서 수십억 달러의 손실을 초래할 수 있다. &nbsp; Trade-off 예시 시간과 공간 문제는 지배적인 요소이지만, Trade-off와 절충안의 조합은 거의 무한하다. 다음은 많은 사례 중 몇가지 예시이다: 최악의 정렬 요구 사항을 수용하는 것은 청크를 정렬하기 위해 할당자가 바이트를 건너뛰도록 강제하여 낭비를 증가시킨다. 동적 튜닝(e.g., 디버그 모드 설정)에 대한 대부분의 규정은 indirection 레벨을 추가하고 분기 수를 증가시켜 시간 효율성을 심각하게 저하시킬 수 있다. 오류를 잡기 위해 설계된 일부 규정은 적용 범위를 제한한다. 예를 들어 2.6.6 버전 이전에는 플랫폼에 관계없이 malloc이 내부적으로 할당 크기 인수를 부호있는 32비트 정수로 처리했으며, 0 이하의 인수를 요청크기 0으로 간주했다. (그러나 2.6.6 부터는 음수 인수가 POSIX 표준을 준수하기 위해 null 값을 반환한다) 다른 할당기의 특이점을 수용하여 플러그-호환성을 유지하려면 유연성과 성능이 감소할 수 있다. 가장 특이한 예로, 초기 Unix 할당기의 일부 버전은 이미 해제된 메모리를 realloc하는 것을 허용했다. 1993년까지는 호환성을 위해 이를 허용했지만, 이 기능이 제거되었을 때 아무도 불평하지 않았다. 소규모 프로그램의 시간/공간을 개선하는 일부 휴리스틱은 요즘 대부분의 시스템 로드를 지배하는 대규모 프로그램에서 시간/공간 특성을 용납할 수 없을 정도로 악화시킬 수 있다. 이와 같은 절충안 중 어떤 것도 완벽할 수 없다. 그러나 수년에 걸쳐 할당자는 대다수 사용자가 수용할 수 있는 Trade-off를 제공하도록 진화해왔다. &nbsp; 이 malloc의 진화를 계속해서 이끄는 주요 요인들은 다음과 같다: malloc 성능에 대한 다른 사람들의 실증적 연구 (위에서 언급한 Wilson 등의 논문과 그 논문이 인용한 다른 논문 포함). 이 논문들은 이 malloc 버전이 시간 및 공간 효율성 측면에서 가장 효율적인 메모리 할당기 중 하나로 순위가 매겨진다고 밝히고 있다. 그러나 각 논문은 약점이나 추가 개선 가능성을 드러낸다. 대상 워크로드의 변화 malloc 구현에 민감한 프로그램 종류의 특성은 지속적으로 변화한다. 대표적인 예로, X 및 기타 윈도잉 시스템의 메모리 특성이 점점 더 지배적이 되고 있다. 시스템 및 프로세서의 변화 전형적인 프로세서에서 코드를 최적화하려는 구현 세부사항 및 미세 조정이 시간이 지남에 따라 변화한다. 추가적으로, Linux와 Solaris와 같은 운영 체제는 자체적으로 진화하여 메모리 매핑을 시스템 수준 할당에 있어서 현명한 선택으로 만드는 경우가 있다. 사용자 및 기여자로부터의 제안, 경험 보고서, 코드 이 코드는 여러 정기적인 자원봉사 기여자들의 도움으로 발전해왔다. 최근의 변경 사항 대부분은 Linux에서 제공된 버전을 사용하는 사람들로부터 시작되었으며, 많은 부분이 Linux 버전을 위해 Wolfram Gloger(ptmalloc 제작자)에 의해 구현되었고, 이후 내가 통합하였다. Algorithms malloc 알고리즘의 두 가지 핵심 요소는 초기 버전 이후로 변하지 않았다: Boundary Tags (경계 태그) 메모리 청크에는 청크의 앞과 뒤에 크기를 정보를 포함한 필드가 있다. 이를 통해 두 가지 중요한 기능을 제공한다: 서로 인접한 사용되지 않은 청크를 하나의 더 큰 청크로 병합(coalescing) 할 수 있다.이는 사용 불가능한 작은 청크의 수를 최소화한다. 모든 청크는 알려진 청크를 기준으로 앞쪽(forwrad) 또는 뒤쪽(backward) 방향으로 순회할 수 있다. &nbsp; &nbsp; 초기 버전에는 경계 태그가 정확히 이 방식으로 구현되었다. 하지만 최신 버전에서는 프로그램에서 사용중인 청크에 대한 후방 필드(trailer fields)를 생략한다. 이는 소소한 트레이드 오프로, 활성 상태인 청크에서는 해당 필드를 절대 사용하지 않으므로 필요하지 않다. 이를 제거하면 오버헤드와 낭비를 줄일 수 있다. 하지만, 이러한 필드가 없으면 사용자가 필드를 덮어쓰는 실수를 감지하기 어려워져 오류 감지 기능이 약화된다. Binning (분류) 사용 가능한 청크는 크기별로 그룹화되어 빈(bin)에 저장된다. bin은 놀랍게도 많은 수(128개)의 고정 폭을 가지며, 대략 로그함수적 간격으로 크기가 배치된다. &nbsp; 512 바이트 이하 크기를 위한 빈은 각 크기마다 정확히 하나씩만 유지한다.(청크 크기는 8바이트 간격으로 나뉘어 있어, 8바이트 정렬을 간단히 보장한다.) 사용 가능한 청크를 검색할 때는 가장 작은 크기부터 시작하여, 가장 적합한 (best-fit) 순서로 처리된다. Wilson 등의 연구에 따르면, 다른 일반적인 접근 방식보다 실제 워크로드에서 단편화를 덜 유발한다. &nbsp; &nbsp; &nbsp; &nbsp; 1995년 이전 버전까지는 빈 내에서 청크가 정렬되지 않았기 때문에, best-fit 전략이 근사적으로만 적용되었다. 최신 버전에서는 대신 빈 내에서 청크를 크기 순서로 정렬하며, 크기가 동일한 경우 가장 오래된 것부터(first-in) 사용하는 규칙으로 정렬한다. (이는 약간의 시간이 추가로 소요되더라도 관찰된 문제를 피할 가치가 있다고 판단되어 변경되었다.) 따라서, 이 알고리즘의 일반적인 분류는 coalescing(병합) 가능한 best-fit 전략이다. 해제된 청크는 이웃한 청크와 병합되고, 크기 순서대로 검색되는 빈에서 관리된다. &nbsp; 이 접근 방식은 청크당 고정된 부가 작업 오버헤드를 초래한다. 크기 정보와 이진 링크를 각각의 사용 가능한 청크에 보유해야 하므로, 32비트 포인터를 사용하는 시스템에서는 최소 할당 가능 청크 크기가 16바이트이고, 64비트 포인터를 사용하는 시스템에서는 24바이트이다. 이러한 최소 크기는 대부분의 사람들이 선호하는 것보다 크며, 예를 들어 작은 연결 리스트 노드를 많이 할당하는 애플리케이션에서는 상당한 낭비를 초래할 수 있다. 그러나 16바이트 크기는 8바이트 정렬을 요구하고 malloc 부가 작업 오버헤드가 있는 시스템의 특징이다. &nbsp; 이 기본 알고리즘은 매우 빠르게 동작하도록 설계될 수 있다. 최적 크기를 찾기 위해 검색 메커니즘에 의존하더라도, 색인 기법(indexing techniques), 특수 사례 활용(exploitation of special cases), 세심한 코딩(careful coding)을 통해 평균적으로 몇십 개의 명령어만 필요하다(물론 이는 기계 및 할당 패턴에 따라 달라질 수 있다.). &nbsp; 경계 태그를 통한 병합(coalescing)과 이진화를 통한 최적 적합(best-fit)은 이 알고리즘의 주요 아이디어를 나타낸다. 하지만 추가적인 고려 사항들이 여러 휴리스틱 개선으로 이어지며 이는 다음을 포함한다: 지역성 유지(locality preservation) 미사용 영역 보존(wilderness preservation) 메모리 매핑(memory mapping) 캐싱(caching) &nbsp; 지역성 유지(Locality preservation) 프로그램에 의해 비슷한 시점에 할당된 청크는 유사한 참조 패턴과 공존 패턴을 가지는 경향이 있다. 지역성(locality)을 유지하면 페이지 폴트(page fault)와 캐시 미스(cache miss)를 최소화할 수 있으며, 이는 현대 프로세서에서 성능에 큰 영향을 미칠 수 있다. 만약 지역성만이 목표라면, 할당자는 연속적인 청크를 가능한 이전 청크에 가깝게 할당할 수 있다. 그러나 이 근접 적합(nearest-fit) 방식(주로 다음 적합(next-fit)으로 근사됨)은 매우 심각한 단편화를 초래할 수 있다. 현재 malloc 버전에서는 제한된 맥락에서만 다음 적합(next-fit)이 사용되며, 이는 지역성이 다른 목표와 가장 적게 충돌하는 경우에 유지하도록 설계되었다. 예를 들어, 정확히 원하는 크기의 청크가 없는 경우, 가장 최근에 분할된 공간을 사용(재분할)할 수 있을 만큼 크다면 이를 사용하고, 그렇지 않으면 최적 적합(best-fit)을 사용한다. 이러한 제한된 사용은 완벽히 사용 가능한 기존 청크가 할당되지 않는 경우를 방지하여 단편화를 제거한다. 또한, 이 형태의 다음 적합은 최적 적합 이진 검색보다 더 빠르므로 평균 malloc 속도를 높인다. &nbsp; 미사용 영역 보존(Wilderness preservation) 미사용 영역(wilderness) 청크는 시스템에서 할당된 최상위 주소를 경계로 하는 공간을 나타내며, Kiem-Phong Vo에 의해 명명되었다. 이 경계에 있으므로, 이는 sbrk(Unix에서 사용)를 통해 임의로 확장할 수 있는 유일한 청크이다. (단, 모든 메모리가 소진되어 sbrk가 실패하지 않는 한 가능하다.) 미사용 영역 청크를 처리하는 한 가지 방법은 다른 청크와 동일하게 다루는 것이다. (이 방법은 1994년까지 대부분의 malloc 버전에서 사용되었다.) 이는 구현을 단순화하고 속도를 높이지만, 신중하지 않으면 매우 나쁜 최악의 공간 특성을 초래할 수 있다. 예를 들어, 다른 사용 가능한 청크가 존재하는데도 미사용 영역 청크를 사용할 경우, 나중에 요청 시 방지할 수 있었던 sbrk를 초래할 가능성이 높아진다. 현재 사용되는 더 나은 전략은 미사용 영역 청크를 다른 청크보다 더 큰 것으로 취급하는 것이다. 이는 시스템 한계까지 확장 가능하므로 최적 우선(best-first) 검색에서 이를 가장 큰 것으로 간주한다. 결과적으로, 미사용 영역 청크는 다른 청크가 없을 때만 사용되며, 방지 가능한 단편화를 최소화한다. &nbsp; 메모리 매핑(Memory mapping) sbrk를 통해 일반적인 할당 영역을 관리하는 것 외에도, 대부분의 Unix 버전은 mmap과 같은 시스템 콜을 지원하여 프로그램에서 사용하기 위한 비연속 메모리 영역을 별도로 할당한다. 이는 malloc이 메모리 요청을 충족하기 위한 두 번째 옵션을 제공한다. mmap된 청크를 요청하고 반환하면 다운스트림 단편화를 줄일 수 있다. 이는 해제된 메모리 맵이 관리해야 할 구멍(hole)을 생성하지 않기 때문이다. 하지만 mmap과 관련된 제한 및 오버헤드로 인해 이는 매우 제한적인 상황에서만 유용하다. 예를 들어: 모든 현재 시스템에서 매핑된 영역은 페이지 정렬(page-aligned)이 필요하다. mmap과 mfree를 호출하는 것은 기존 메모리 청크를 분할하는 것보다 훨씬 느리다. &nbsp; 이러한 이유로 현재 malloc 버전은 다음 두 조건을 충족할 때만 mmap을 사용한다: 요청이 동적으로 조정 가능한 임계값 크기(현재 기본값 1MB)를 초과하는 경우 요청된 공간이 기존 영역에 없어서 sbrk를 통해 확보해야 하는 경우 &nbsp; 또한, 현재 malloc 버전은 메인 영역의 트리밍을 지원한다. 이는 사용되지 않는 공간을 시스템에 반환하여 메모리 매핑 효과 중 하나를 달성한다. 예를 들어, sbrk는 음수 인수를 사용하여 이 효과를 달성할 수 있다. 이러한 공간 반환은 운영 체제의 스왑 공간 요구 사항을 줄이고 메모리 매핑 테이블을 재사용할 수 있게 한다. 하지만 mmap과 마찬가지로 호출 자체가 비용이 많이 들기 때문에, 이는 후행 미사용 메모리가 조정 가능한 임계값을 초과할 경우에만 시도된다. &nbsp; 캐싱(Caching) 가장 기본적인 알고리즘에서, 해제된 청크는 즉시 이웃 청크들과 병합하여 가능한 가장 큰 미사용 청크를 형성한다. 마찬가지로, 청크는 명시적으로 요청될 때만(더 큰 청크를 나눔으로써) 생성된다. 청크를 분할하거나 병합하는 작업은 시간이 소요된다. 이 시간 오버헤드는 두 가지 캐싱 전략 중 하나 또는 둘 모두를 사용함으로써 줄일 수 있다. 지연 병합(Deferred Coalescing) 해제된 청크를 병합하지 않고 현재 크기로 그대로 두어 동일한 크기에 대한 다른 요청이 곧 들어올 가능성에 대비한다. 이를 통해 병합과 나중의 분할, 그리고 정확히 일치하지 않는 청크를 찾는데 드는 시간을 절약할 수 있다. 사전 할당(Preallocation) 새 청크를 하나씩 나누는 대신 여러개를 한 꺼번에 나눈다. 이는 일반적으로 한 번에 하나 씩 나누는 것보다 더 빠르다. malloc, free, realloc 등의 기본 데이터 구조는 언제든지 병합을 허용하므로, 관련된 캐싱 휴리스틱을 쉽게 적용할 수 있다. 캐싱의 효과는 분할, 병합, 검색 비용에 따라 달라진다. 또한, 캐싱과 병합 시점에 대한 정책에 따라 효과가 달라질 수 있다. 캐싱은 소수의 크기만 할당하고 해제하는 프로그램에서 좋은 선택이 될 수 있다. 예를 들어, 많은 트리 노드를 할당하고 해제하는 프로그램에서는 일부 노드를 캐싱하는 것이 효율적일 수 있다. 하지만 프로그램에 대한 사전 지식이 없는 경우, malloc은 작은 캐시된 청크를 병합하여 더 큰 요청을 충족시키는 것이 좋은지 아니면 다른 곳에서 가져와야 하는지를 판단하기 어렵다. 이전의 malloc 버전은 캐싱에 대해 적절한 추정을 하기 위해 몇 가지 검색 순서 휴리스틱(search-ordering huristics)을 사용했지만, 때로는 나쁜 최악의 사례 결과를 초래했다. 시간이 지남에 따라 이러한 휴리스틱은 실제 작업 부하에서 점점 덜 효과적인 것으로 나타났다. 이는 malloc에 크게 의존하는 실제 프로그램들이 점점 더 다양한 크기의 청크를 사용하는 경향이 있기 때문이다 . 예를 들어, C++ 프로그램에서는 클래스 수가 증가하는 경향과 관련이 있을 가능성이 있다. 서로 다른 클래스는 서로 다른 크기를 가지는 경향이 있다. 참고: 최신 malloc은 작은 청크(small chunks)만 캐싱한다. &nbsp; Lookasides Lookasides는 일부 애플리케이션에서 매우 바람직하지만, 이 할당자에서는 구현되지 않는 캐싱 유형으로, 매우 작은 청크를 위한 것이다. 위에서 언급했듯이, 기본 알고리즘은 최소 청크 크기를 강제하면, 이는 매우 작은 요청에 대해 매우 낭비적을 수 있다. 예를 들어 4바이트 포인터를 사용하는 시스템에서 연결 리스트는 두 개의 포인터만 포함하는 노드를 할당할 수 있으며, 이는 8바이트만 필요하다. 그러나 최소 청크 크기가 16바이트이기 때문에, 리스트 노드에만 할당하는 사용자 프로그램은 100%의 오버헤드를 겪게 된다. 이 문제를 해결하면서도 이식 가능한 정렬을 유지하려면 할당자가 어떤 오버헤드도 부과하지 않아야 한다. 이를 수행하기 위한 기술은 존재한다. 예를 들어, 청크가 더 큰 집합된 공간에 속하는지 여부를 주소 비교를 통해 확인할 수 있다. 그러나 이렇게 하는 것은 상당한 비용을 초래할 수 있으며, 실제로 이 할당자에서는 그 비용이 허용될 수 없는 수준이다. 청크가 주소로는 따로 추적되지 않으므로, 임의로 제한하지 않는다면 이러한 확인 과정은 메모리를 무작위로 검색하는 결과를 초래할 수 있다. 또한, 작은 청크를 병합할지 여부와 방법을 제어하는 하나 이상의 정책을 채택해야 한다. 이러한 문제와 제한은 프로그래머가 특수 목적의 메모리 관리 루틴(e.g., C++에서 operator new()를 오버로딩)을 작성해야 하는 매우 적은 종류의 상황 중 하나로 이어진다. 대규모이지만 대략적으로 알려진 숫자의 매우 작은 청크를 사용하는 프로그램은 매우 간단한 할당자를 구축하는 것이 유리할 수 있다. 예를 들어, 고정된 배열에서 청크를 할당하고 임베디드 free 리스트를 사용하며, 배열이 소진된 경우 malloc을 백업으로 사용하는 방식을 들 수 있다. 약간 더 유연하게는, 이는 GNU gcc와 libg++에서 제공되는 C 또는 C++ 버전의 obstack을 기반으로 할 수도 있다.]]></summary></entry><entry><title type="html">LD_PRELOAD란?</title><link href="https://neutrinox4b1.github.io/blog/2025/ld_preload/" rel="alternate" type="text/html" title="LD_PRELOAD란?"/><published>2025-01-04T11:57:42+00:00</published><updated>2025-01-04T11:57:42+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/ld_preload</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/ld_preload/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[LD_PRELOAD 유닉스 계열 운영체제에서 제공하는 환경 변수로, 동적 링커(dynamic linker)에 특정 라이브러리를 강제로 로드하도록 지시하는데에 사용된다. 이를 통해, 프로그램 기본 라이브러리 함수 동작을 재정의하여 후킹 등에 사용할 수 있다. &nbsp; &nbsp; &nbsp; How to use? 프로그램 실행 시 LD_PRELOAD=./your_lib.so ./target_program 환경 변수 등록 export LD_PRELOAD=./your_lib.so 비활성화하려면, unset LD_PRELOAD 명령어를 입력한다. gdb에서 사용 pwndbg&gt; set env LD_PRELOAD ./your_lib.so pwntools에서 사용 p=process('./target_program', env={'LD_PRELOAD':'./your_lib.so'}) &nbsp;]]></summary></entry><entry><title type="html">운영체제별 glibc 버전 확인 방법</title><link href="https://neutrinox4b1.github.io/blog/2025/glibc/" rel="alternate" type="text/html" title="운영체제별 glibc 버전 확인 방법"/><published>2025-01-02T16:58:03+00:00</published><updated>2025-01-02T16:58:03+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/-glibc---</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/glibc/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[pwnable 공부를 하다보면, 어떤 기법은 glibc ~~ 이상부터 통하지 않는다거나, 어느 기능이 사라졌다거나 하는 내용을 한번쯤은 마주쳤을 텐데 "그래서 그게 우분투 몇 버전이야?" 싶었던 적이 있을 것이다. &nbsp; glibc 버전 뿐만이 아니라 다양한 정보들을 알아보기 쉽게 정리해둔 사이트가 있다. &nbsp; DistroWatch Distrowatch는 리눅스 배포판과 관련된 정보를 제공하는 웹사이트로, 리눅스 및 기타 오픈소스 운영체제(OS)에 관심이 있는 사용자들에게 배포판의 최신 뉴스, 업데이트, 리뷰, 다운로드 링크 등을 제공한다. &nbsp; 다음 링크는 우분투에 관한 정보이다. https://distrowatch.com/table.php?distribution=ubuntu &nbsp; DistroWatch.com: Ubuntu Reader supplied reviews for Ubuntu Average rating7.6from 299 review(s) Version: 24.10Rating: 1Date: 2024-12-27Votes: 0 I think .. it's very bloated, hidden reporting packages, data collectors and senders using your bandwidth. pushing upgrade to pro-version distrowatch.com &nbsp; 해당 링크에서는 다음과 같이 테이블 형태로 glibc 버전을 확인할 수 있다. &nbsp; &nbsp; Ubuntu 24.04 LTS noble에서는 glibc 2.39 버전, 22.04 LTS jammy에서는 2.35 버전을 사용한다. Ubuntu LTS 버전들을 표시해보자면, 24.04 LTS noble: glibc 2.39 22.04 LTS jammy: glibc 2.35 20.04 LTS focal: glibc 2.31 18.04 LTS bionic: glibc 2.27 16.04 LTS xenial: glibc 2.23 glibc 버전 별 주요 변경점은 추후 작성할 예정이다.]]></summary></entry><entry><title type="html">GCC memory protection options (Updating)</title><link href="https://neutrinox4b1.github.io/blog/2024/gcc-memory-protection-options-updating/" rel="alternate" type="text/html" title="GCC memory protection options (Updating)"/><published>2024-10-13T13:18:20+00:00</published><updated>2024-10-13T13:18:20+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/gcc-memory-protection-options-updating</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/gcc-memory-protection-options-updating/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[이번 글에서는 GCC(GNU C Compiler)에서 메모리 보호기법을 enable, disable하는 옵션들에 대해서 정리한다. &nbsp; NX bit NX bit는 데이터 영역(e.g., stack)에서 실행 권한을 제거하는 보호기법이다. gcc -z execstack &nbsp; `-z execstack` 옵션을 통해 NX bit를 disable 할 수 있다. &nbsp; Stack Smashing Protector (Stack Canary) SSP는 SFP(Saved Frame Pointer) 전에 Canary라고 하는 랜덤 값을 삽입해두어 오버플로우를 탐지하는 보호기법이다. &nbsp; gcc -fno-stack-protector `-fno-stack-protector` 옵션을 통해 SSP를 disable 할 수 있다. &nbsp; 해당 보호기법을 명시적으로 적용하기 위해서는 gcc -fstack-protector `-fstack-protector` 옵션을 사용한다. &nbsp; &nbsp; ASLR(Address&nbsp;Space&nbsp;Layout&nbsp;Randomization) ASLR은 주소공간을 랜덤화하는 보호기법이다. sudo cat /proc/sys/kernel/randomize_va_space 명령어를 통해 `/proc/sys/kernel/randomize_va_space` 파일을 읽어들여 ASLR 적용 여부를 확인할 수 있다. &nbsp; `/proc/sys/kernel/randomize_va_space`가 0이면 ASLR 해제 1이면 stack과 library가 랜덤 2이면 stack, heap, library가 랜덤이다. &nbsp; sudo bash -c "echo 0 &gt; /proc/sys/kernel/randomize_va_space" 명령어를 통해 ASLR을 disable 할 수 있다. &nbsp; RELRO(RELocation Read Only) RELRO는 GOT overwrite 처럼 메모리가 변경되는 것을 방어한다. NO RELRO gcc -z norelro NO RELRO는 본 헤더, 코드 영역등을 제외한 거의 모든 부분에 read, write 권한을 준다. &nbsp; PARTIAL RELRO gcc -z relro PARTIAL RELRO는 .ctors, .dtors, .jcr, .dynamic 섹션이 ready-only 즉, 쓰기 권한이 없어진다. &nbsp; FULL RELRO gcc -z relro -z now FULL RELRO는 BSS영역을 제외한 모든 부분에서 write권한이 없다. &nbsp; PIE(Position Independent Executable) PIE는 모든 심볼 주소를 상대적으로 작성하고 base address를 랜덤화해서 함수들의 주소를 실행할 때마다 랜덤화하는 보호기법이다. &nbsp; gcc -no-pie `-no-pie` 옵션은 PIE를 disable 하는 옵션이다. &nbsp; gcc -fpie `-fpie`는 .text 영역을 랜덤화한다. &nbsp; gcc -fpie -pie `-fpie -pie`옵션은 PIE를 명식적으로 적용한다. &nbsp; &nbsp; &nbsp; &nbsp;]]></summary></entry></feed>
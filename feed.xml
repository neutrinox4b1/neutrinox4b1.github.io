<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://neutrinox4b1.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://neutrinox4b1.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-26T15:04:10+00:00</updated><id>https://neutrinox4b1.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Windows에서 GCC를 사용한 C 언어 실행</title><link href="https://neutrinox4b1.github.io/blog/2024/windows-gcc-c/" rel="alternate" type="text/html" title="Windows에서 GCC를 사용한 C 언어 실행"/><published>2024-09-20T03:56:54+00:00</published><updated>2024-09-20T03:56:54+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/windows-gcc--c--</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/windows-gcc-c/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[나는 VS Code와 Git Bash조합으로 많이 사용하고 있는데, 추후 빠른 환경설정을 위해서 환경 설정을 한 번 정리하고 넘어가고자 한다.&nbsp;우선, Git Bash와 VSCode가 설치되었다는 가정 하에서&nbsp;&nbsp; VSCode 터미널 설정 Panel 위치 &nbsp;우선 터미널은 우측으로 두는 것이 작업하기 편리하므로 panel의 default location을 right로 둔다.&nbsp; Default terminal &nbsp;터미널 설정은 우측의 V 표시를 누르고 Select Default Profile -&gt;Git Bash를 지정한다. &nbsp; &nbsp;이제 GCC 설정이 남았다.&nbsp;&nbsp; MinGW를 활용한 GCC 설정 일반적으로 사용하는 MinGW가 아니라 MinGW-w64를 사용하고자 하며, gdb 사용 또한 보장되어야 할 것이다.&nbsp;MinGW와 MinGW-w64의 차이점 및 배경&nbsp;&nbsp;https://code.visualstudio.com/docs/cpp/config-mingw &nbsp; Get Started with C++ and MinGW-w64 in Visual Studio Code Configuring the C++ extension in Visual Studio Code to target g++ and gdb on a MinGW-w64 installation code.visualstudio.com 위 VSCode에서 작성한 문서를 따라 환경설정을 수행한다.&nbsp; MSYS2 및 MinGW-w64 설치 &nbsp;앞선 링크에서 설치 프로그램에 대한 링크를 통해 MSYS2를 설치한다.&nbsp;MSYS2가 설치되면 pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain &nbsp;을 입력한다. 여기에서 Enter를 눌러서 디폴트로 전체 설치를 수행한다.&nbsp; Y 입력&nbsp; 환경 변수 설정 설치가 완료되면 환경변수를 설정한다.&nbsp;&nbsp; &nbsp;Path에 새로운 환경 변수를 추가한다. &nbsp;디폴트로 설치했다면 다음 `C:\msys64\ucrt64\bin` 경로로 설정할 것이다.&nbsp; 설정 완료 및 테스트 &nbsp;이렇게 되면 Windows VSCode에서 자유롭게 gdb, gcc, g++ 사용이 가능하다.&nbsp;&nbsp;추가적으로, 맥이나 리눅스를 사용하다보면 쉘에서 open 이라는 명령어를 편하게 사용한다.윈도우 환경에서는 `explorer.exe` 로 사용하고, 이는 간단히`~/.bash_profile`에서 alias open=explorer.exe &nbsp;를 추가해주면 된다.]]></summary></entry><entry><title type="html">하이퍼바이저(Hypervisor)란 무엇인가? with 가상화 (Virutalization)</title><link href="https://neutrinox4b1.github.io/blog/2024/hypervisor-with-virutalization/" rel="alternate" type="text/html" title="하이퍼바이저(Hypervisor)란 무엇인가? with 가상화 (Virutalization)"/><published>2024-05-22T05:10:30+00:00</published><updated>2024-05-22T05:10:30+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/hypervisor--with--virutalization</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/hypervisor-with-virutalization/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[하이퍼바이저란 무엇인가? 커널까지는 뭐하는 앤지 대충 알겠는데, 최신 OS에 대해 논하다보면 항상 Hypervisior라는 단어가 빠지지 않는다. 하이퍼바이저란 무엇일까? 1. Hypervisor 하이퍼바이저는 가상화를 구현하기 위해 기반이 되는 기술이고 가상화 계층을 구현해주는 소프트웨어를 말한다. &nbsp; 하드웨어 위에서 가상 머신을 생성하고 자원을 할당하고, 요청을 처리해주는 매니저의 역할을 수행한다. &nbsp; 그래서 가상 머신 매니저(Virtual Machine Manager)&nbsp; 또는 가상 머신 모니터(Virutual Machine Monitor, VMM) 라고 불리기도 한다. &nbsp; 그럼 이 하이퍼바이저가 우리가 사용하는 윈도우 아래에서 왜 작동하는가? 윈도우는 OS가 하나인데 하이퍼바이저를 두면 뭐가 좋아서? 싶다. &nbsp; 우선 하이퍼바이저의 종류부터 알아보자. &nbsp; &nbsp; 2. Hypervisor Type 하이퍼바이저는 Type 1과 Type 2로 나뉜다. &nbsp; 2.1. Type 1 (navtive, bare-metal) 타입 1 하이퍼바이저는 native 또는 Bare-metal 하이퍼바이저라고도 불린다. 이름 그대로의 의미로 하드웨어에서 직접 구동되어 게스트 OS를 관리한다. &nbsp; 바로 하드웨어 위에서 동작하므로 호스트 OS가 존재하지 않고, 게스트 OS는 하드웨어 위에 2번째 수준으로&nbsp; 실행되기 때문에 오버헤드가 적다는 장점을 가진다.&nbsp; &nbsp; 그러나 VM들에 대한 자체 관리 기능이 없어, VM&nbsp; 관리를 위한 컴퓨터나 콘솔이 별개로 필요하다. &nbsp; Type 1 하이퍼바이저는 IBM의 CP/CMS에서 시작(최초의 하이퍼바이저는 CP-40)되어 IBM의 z/VM으로 이어졌다. 최근에는 Xen, Ctrix의 XenServer Vmware의 ESX Server, L4 마이크로 커널, TANGO IBM의 POWER 하이퍼바이저 (PR/SM)&nbsp; 마이크로소프트 Hyper-V, Parallel Server 썬의 로지컬 도메인 하이퍼바이저 등이 있다. 또는 히타치의 Virtage 하이퍼바이저같이 플랫폼 펌웨어에 하이퍼바이저를 넣기도 하며, KVM은 하이퍼바이저에 완전한 리눅스 커널을 넣었는데 이것도 Type 1이다. &nbsp; Type 1 하이퍼바이저는 구현 방식에 따라 전가상화 (Full-Virtualization) =&gt; VMware ESX Server, MS Hyper-V 반가상화 (Half-Virtualization) =&gt; Citrix XenServer HAV (Hardware Asssisted Virtualization) 으로 나뉜다. &nbsp; 2.2. Type 2 (Hosted Hypervisor) Type 2 하이퍼바이저는 Hosted 하이퍼바이저라고도 불리며, Host OS를 갖는 하이퍼바이저를 말한다. &nbsp; 하드웨어에 이미 Host OS가 설치되어 있고, 하이퍼바이저는 OS 위에서 소프트웨어로서 동작한다. =&gt; 하드웨어로부터 3번째 수준으로 실행된다&nbsp; &nbsp; 기존 시스템 위에서 쉽게 사용 가능하다는 장점을 가진다.&nbsp; 그러나 오버헤드가 커지고 Host OS 문제가 전체 게스트 OS에 영향을 미칠 수 있다는 단점이 존재한다. &nbsp; 대표적인 종류로는 VMware Server VMware Workstation, Fusion QEMU 마이크로소프트 버추얼 PC와 버추얼 서버 Oracle의 Virutal Box SWsoft의 Paralles Workstation과 Parallels Desktop 등이 있다. 그냥 VM 소프트웨어들 같아보인다. &nbsp; 보통 개인 컴퓨터에서 VM을 사용하고자 할 때 일반적으로 사용하는 유형이다. &nbsp; Q1. Type 1 하이퍼바이저와 Type 2 하이퍼바이저를 동시에 사용 가능한가?Q2. BoB에서 VT-x 를 설정해야했는데 그거랑 무슨 관련이 있는가? 왜 그렇게 했어야만 하는가?Q3. Hyper-V는 Default 설정이 Enable인가? &nbsp; A1. GPT: 가능은 하지만 호환성 문제나 성능저하를 야기할 수 있다. &nbsp; &nbsp; A2. BoB에서 VT-x를 설정해야 하는건 Hyper-V를 꺼야 적용되는 옵션이었다. 우선, 에러명은 VMware Workstation does not support nested virtualization on this host. Module 'HV' power on failed. Failed to start the virtual machine 이고, 이 에러가 발생하기 이전에 "virtualized intel vt-x/ept is not supported on this platform" 이 언급된다. &nbsp; VT-x/EPT란 무엇인가? 이에 대해선 다음 글에 설명해봐야겠다. 우선 알고 넘어갈 것은 CPU에 내장된 하드웨어 가상화 기능이라는 것이다. 이 에러는 nested virtualization (중첩 가상화)와 관련이 있는데 이 에러가 뜨는 vm은 이 화면에서 Virtualize Intel VT-x/EPT or AMD-V/RVI 기능이 켜져있었다. https://www.clien.net/service/board/kin/5244830 &nbsp; Vmware 프로그램에서 옵션에 프로세스 부분에 "virtualize intel vt-x/ept or amd-v/rvi" 옵션은 무슨옵션인가 알려주실 고수분 계신가요 -.-a;; 갑자기 궁굼해서 ㅠㅠ www.clien.net &nbsp; 이 옵션을 켜는 이유는 nested VM을 지원하기 위함이며, 해당 VM이 이 옵션을 사용하던 이유는 KVM에서 커널 취약점을 분석하기 위해서 사용하던 VM이기 때문이다. &nbsp; 덧붙여서 &nbsp; Virtualize Intel VT-x/EPT or AMD-V/RVI: CPU가 가상화 기술을 지원할 때, 실행 모드를 Intel VT-x나 AMD-V/RVI로 실행하도록 VMware에 지시하는 옵션임 Virtualize CPU performance counters: 고급 디버깅이나 성능 모니터링을 수행하는 경우 이 옵션을 활성화하나, 일반적으로는 권장되지 않는다. Virtualize IOMMU (IO memory management unit): 메모리 및 DMA 리매핑 기술로 AMD와 Intel의 이더넷 가상화 기술이다. 가상 이더넷 장치를 추가할 때 하드웨어 가속을 해준다. 메인보드 지원 필요. A3. Hyper-V는 기본적으로 Disable 상태로 되어있다. &nbsp; &nbsp; 3. 가상화(Virtualization) 하이퍼바이저가 있고 VM이 있고 위에서 뭐 게스트 OS가 돌아가고 하는 것은 대충 알겠는데, &nbsp; 가상화는 왜 사용하는가? &nbsp; 하드웨어 성능이 빠르게 증가하던 1960, 70년대에 소프트웨어 발전 속도는 하드웨어 발전 속도를 따라가지 못하였고 소프트웨어 요구 성능보다 서버 성능이 좋다보니 자원이 남아 돌았다. &nbsp; 자원이 남아도는 비효율로 문제를 해결하기 위해서 가상화 개념이 도입되었다. &nbsp; 기존에는 하나의 OS, 1개의 태스크를 실행하기 위해서 각각의 물리적 서버가 필요했으나, &nbsp; 서버를 가상화한다면 더 효율적으로 쓸 수 있는 것임. &nbsp; 이렇게 하면 비용 절감: 마이그레이션이 쉬워 빈 서버를 재사용하거나 중지시켜서 유지관리를 수월하게 할 수도 있음 유연성: 동일 하드웨어에서 여러 운영체제 동시 실행 가능 민첩성: 한 물리서버에서 다른 물리 서버로 OS 이동 가능 내결함성: 물리적 서버에 장애가 있으면 관리 소프트웨어가 마이그레이션하여 신속한 조치 가능&nbsp; 이러한 장점을 가진다. &nbsp; 3.1. 가상화 작동 방식 및 종류 하이퍼바이저 소프트웨어를 설치하면 하나의 물리 시스템을 가상 머신으로 분할하여 구현할 수 있다. 하이퍼바이저 소프트웨어의 주 역할은 CPU, 메모리, 기타 물리적 리소스를 가상 인스턴스와 분리하는 가상화 계층을 생성(재차 언급임) &nbsp; &nbsp; https://www.redhat.com/ko/topics/virtualization/what-is-virtualization &nbsp; 3.1.1. 데이터 가상화 데이터 가상화는 여러 곳에 분산된 데이터를 단일 소스로 통합한다. 이를 통해 사용자 요구에 따라 데이터를 변환할 수 있는 처리 역량을 확보할 수 있고 적시에 애플리케이션 또는 사용자에게 필요한 데이터를 제공한다. &nbsp; &nbsp; 3.1.2. 데스크탑 가상화 운영체제 가상화와 혼동하기 쉽다. 중앙 관리자나 자동화 툴을 이용해서 시뮬레이션된 데스크탑 환경을 수백개의 물리 머신에 동시에 배포할 수 있도록 지원한다. &nbsp; 각 머신에서 물리적으로 설치, 구성, 업데이트 되는 전통적인 데스크탑 가상화와 달리, 관리자가 모든 데스크탑에서 설치, 구성, 업데이트를 수행 가능하다. &nbsp; &nbsp; 3.1.3. 서버 가상화 서버를 가상화해서 서버의 기능을 많이 수행할 수 있고, 서버 파티셔닝을 통해 구성요소로 여러 기능을 지원할 수 있다. &nbsp; 3.1.4. 운영체제 가상화 운영체제 가상화는 커널에서 이루어진다. 이렇게 하면 linux 환경과 windows 환경을 함께 실행할 수 있다. 기업에서는 운영체제를 push해서 다음과 같은 이점을 얻을 수 있다. 하드웨어 비용 감소: 컴퓨터에 고도의 OOTB(Out Of The Box) 기능이 필요하지 않음 보안 강화: 모든 가상 인스턴스를 모니터링하고 격리할 수 있음 시간 절약: 소프트웨어 업데이트같은 IT서비스의 소요시간이 감소됨 3.1.5. 네트워크 기능 가상화 (Network Fuctions Virtualization, NFV) 디렉터리 서비스, 파일 공유, IP 설정같은 네트워크 주요 기능을 분리하여 이러한 기능을 환경에 배포시킴 소프트웨어 기능이 속한 물리머신으로부터 분리하면 특정 기능을 새 네트워크에 패키징하고 이를 환경에 할당할 수 있음. =&gt;뭔말이래; &nbsp; 네트워크를 가상화하면 물리 구성 요소의 수가 감소한다. (스위치, 라우터, 서버, 케이블, 허브 등 여러 독립적인 네트워크를 생성하는데 필요하며, 특히 산업에서 일반적으로 사용되는 물리 구성 요소..) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]]></summary></entry><entry><title type="html">Team. PPP - CTF 운영에 대한 제안</title><link href="https://neutrinox4b1.github.io/blog/2024/team-ppp-ctf/" rel="alternate" type="text/html" title="Team. PPP - CTF 운영에 대한 제안"/><published>2024-05-03T10:08:49+00:00</published><updated>2024-05-03T10:08:49+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/team-ppp---ctf---</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/team-ppp-ctf/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[PPP팀의 suggestions-for-running-a-ctf 문서를 읽고 정리한 글 CTF에는 어떤 문제들이 출제되고(되어야 하고) 어떻게 운영되는지 담은 글 같아서 정리해둔다. &nbsp; Introduction 이&nbsp;문서는&nbsp;CTF&nbsp;대회&nbsp;운영과&nbsp;관련된&nbsp;설계&nbsp;및&nbsp;기술적인&nbsp;세부&nbsp;사항을&nbsp;설명한다. CTF&nbsp;커뮤니티들이&nbsp;가지고&nbsp;있는&nbsp;의견을&nbsp;요약하고,&nbsp;문제를&nbsp;설계할&nbsp;때&nbsp;피해야&nbsp;할&nbsp;몇&nbsp;가지&nbsp;구체적인&nbsp;위험&nbsp;사항들을&nbsp;나열하고자한다. &nbsp; General&nbsp;Design CTF를&nbsp;많이&nbsp;참가하여&nbsp;타겟&nbsp;고객(참가자)를&nbsp;파악하고&nbsp;내려야&nbsp;할&nbsp;몇&nbsp;가지&nbsp;결정들에&nbsp;익숙해지는&nbsp;것이&nbsp;좋다. CTF를&nbsp;준비하고&nbsp;실행하는&nbsp;것은&nbsp;항상&nbsp;예상보다&nbsp;더&nbsp;많은&nbsp;시간과&nbsp;노력이&nbsp;필요하므로&nbsp;작업할&nbsp;시간을&nbsp;충분히&nbsp;가지도록&nbsp;한다.&nbsp;:-) &nbsp; Timing 다른&nbsp;보안&nbsp;행사와의&nbsp;일정&nbsp;충돌을&nbsp;피하기&nbsp;위해,&nbsp;ctftime.org같은&nbsp;것을&nbsp;주로&nbsp;사용해보자.&nbsp;미리&nbsp;계획하고&nbsp;이벤트를&nbsp;일찍&nbsp;발표해서&nbsp;다른&nbsp;사람들이&nbsp;계획할&nbsp;시간을&nbsp;갖도록&nbsp;한다. &nbsp; 또한,&nbsp;과거에&nbsp;열린&nbsp;큰&nbsp;규모의&nbsp;대회&nbsp;일정을&nbsp;찾아볼&nbsp;수&nbsp;있다.&nbsp;매년&nbsp;같은&nbsp;날짜에&nbsp;열리는&nbsp;경향이&nbsp;있으며(연례&nbsp;컨퍼런스와&nbsp;관련됨)&nbsp;이를&nbsp;통해&nbsp;CTF에&nbsp;많은&nbsp;인원을&nbsp;수용하기&nbsp;위해서&nbsp;일정을&nbsp;변경할&nbsp;수&nbsp;있다. &nbsp; 주중에는&nbsp;CTF&nbsp;일정을&nbsp;잡지&nbsp;않도록&nbsp;한다.&nbsp;이는&nbsp;학생과&nbsp;직업을&nbsp;가진&nbsp;사람들에게&nbsp;패널티가&nbsp;된다. 경쟁을&nbsp;24시간&nbsp;또는&nbsp;48시간&nbsp;열어두어야&nbsp;한다.&nbsp;이렇게&nbsp;하면&nbsp;전&nbsp;세계&nbsp;팀이&nbsp;동일한&nbsp;&lsquo;일광&rsquo;&nbsp;시간을&nbsp;투자할&nbsp;수&nbsp;있다. 그러나&nbsp;일반적으로&nbsp;2일&nbsp;이상&nbsp;열어두는&nbsp;것은&nbsp;좋지&nbsp;않다.&nbsp;좋은&nbsp;문제로는&nbsp;그렇게&nbsp;많은&nbsp;시간을&nbsp;채울&nbsp;수&nbsp;없거나,&nbsp;할수&nbsp;있다&nbsp;하더라도&nbsp;참가자들이&nbsp;금방&nbsp;지치게&nbsp;된다. &nbsp; Flag&nbsp;Format 플래그&nbsp;형식이&nbsp;사소한&nbsp;것처럼&nbsp;보일&nbsp;수&nbsp;있으나,&nbsp;성가신&nbsp;플래그&nbsp;형식은&nbsp;그럭저럭&nbsp;괜찮은&nbsp;CTF&nbsp;경험을&nbsp;짜증나는&nbsp;경험으로&nbsp;바꿀&nbsp;수&nbsp;있다. 가능한&nbsp;한,&nbsp;플래그를&nbsp;참가자들이&nbsp;해결하면서&nbsp;발견하는&nbsp;간단한&nbsp;ASCII&nbsp;문자열로&nbsp;만들자.&nbsp;그리고&nbsp;다음과&nbsp;같은&nbsp;복잡한&nbsp;형식으로는&nbsp;만들지&nbsp;않도록&nbsp;한다. &lt;md5(대상 이름)&gt;&lt;이벤트 날짜&gt;&lt;함수 주소&gt; &nbsp; 이러한&nbsp;형식은&nbsp;실수로&nbsp;충분히&nbsp;명시되지&nbsp;않기&nbsp;쉽다.&nbsp;이름은&nbsp;대문자로?&nbsp;어떻게&nbsp;표기하는가?&nbsp;날짜에는&nbsp;슬래시?&nbsp;대시?&nbsp;점으로&nbsp;구분하는가?&nbsp;시간도&nbsp;포함인가?&nbsp;어떤&nbsp;시간대인가?&nbsp;정확도는&nbsp;얼마나&nbsp;되고&nbsp;초,&nbsp;밀리초,&nbsp;마이크로초인가?&nbsp;함수&nbsp;주소는&nbsp;16진수인가?&nbsp;8자리&nbsp;또는&nbsp;16자리&nbsp;0으로&nbsp;채워진&nbsp;주소인가?&nbsp;0x로시작하나&nbsp;아니면&nbsp;시작하지&nbsp;않나? &nbsp; 또한,&nbsp;복합&nbsp;플래그&nbsp;형식은&nbsp;참가자들이&nbsp;올바른&nbsp;것을&nbsp;찾았는&nbsp;지&nbsp;알기&nbsp;어렵게&nbsp;만든다.&nbsp;새로운&nbsp;추축이&nbsp;있을&nbsp;때마다,&nbsp;여러&nbsp;순열을&nbsp;시도해야&nbsp;하며&nbsp;형식을&nbsp;가지고&nbsp;놀면서&nbsp;가까운&nbsp;지&nbsp;궁금해하는&nbsp;것은&nbsp;보람이&nbsp;없다. &nbsp; (복잡한&nbsp;형식을&nbsp;절대적으로&nbsp;필요하는&nbsp;좋은&nbsp;문제가&nbsp;있을&nbsp;수&nbsp;있다.&nbsp;조심스럽게&nbsp;진행하고&nbsp;모호함을&nbsp;주의하도록&nbsp;한다.) &nbsp; 참가자들에게&nbsp;해시로&nbsp;만들어&nbsp;플래그로&nbsp;보내도록&nbsp;요청하지&nbsp;않도록&nbsp;한다.&nbsp;해시에&nbsp;정확히&nbsp;무엇이&nbsp;들어가야&nbsp;하는지&nbsp;명시하기&nbsp;어렵고,&nbsp;대소문자나&nbsp;new&nbsp;line&nbsp;문자에서&nbsp;사소한&nbsp;오류로&nbsp;인해&nbsp;잘못된&nbsp;결과가&nbsp;나올&nbsp;수&nbsp;있다. &nbsp; 해시&nbsp;자체가&nbsp;원래&nbsp;플래그보다&nbsp;추축하기&nbsp;어렵지도&nbsp;않다;&nbsp;직접&nbsp;제출하는게&nbsp;낫다. &nbsp; 주최자&nbsp;입장에서&nbsp;힌트&nbsp;필요&nbsp;여부나&nbsp;참가자들이&nbsp;예상치&nbsp;못한&nbsp;장애물에&nbsp;부딪혔는지&nbsp;알기&nbsp;위해&nbsp;플래그&nbsp;제출&nbsp;로그를&nbsp;보는&nbsp;것도&nbsp;중요하다.&nbsp;MD5&nbsp;해시만&nbsp;본다면&nbsp;무슨&nbsp;일이&nbsp;일어나고&nbsp;있는&nbsp;지&nbsp;알&nbsp;수&nbsp;없다. &nbsp; 플래그는 항상 제출할 플래그처럼 명확하게 보여야 한다. 플래그가 &ldquo;축하합니다. 이겼습니다!&rdquo; 또는 &ldquo;1234"라면, 일부 참가자들은 문제를 해결했다는걸 깨닫지 못하고 계속 시간을 낭비할 수도 있다. &nbsp; 주최자들은&nbsp;MyCTF{663d63e8c755f1b4}&nbsp;또는&nbsp;funny_1337speaK_pHras3&nbsp;같은&nbsp;일반적인&nbsp;형식을&nbsp;모든&nbsp;대회의&nbsp;플래그에&nbsp;사용하는&nbsp;것이&nbsp;좋다.(일부&nbsp;플래그&nbsp;앞에&nbsp;&ldquo;flag&nbsp;is:&rdquo;&nbsp;를&nbsp;포함하는&nbsp;것도&nbsp;도움이&nbsp;된다.) &nbsp; 브루트&nbsp;포스로&nbsp;풀수&nbsp;있는&nbsp;플래그를&nbsp;피해야&nbsp;한다.&nbsp;예를&nbsp;들어&nbsp;플래그가&nbsp;도시&nbsp;이름이라면,&nbsp;일부&nbsp;플레이어는&nbsp;수천&nbsp;개의&nbsp;추측을&nbsp;제출할&nbsp;수&nbsp;있다. &nbsp; 모든&nbsp;키&nbsp;제출&nbsp;앞에&nbsp;CAPCHA를&nbsp;두지는&nbsp;말자&nbsp;이는&nbsp;불필요하고&nbsp;플레이어한테&nbsp;성가신&nbsp;일이다. &nbsp; 플래그&nbsp;검사는&nbsp;최대한&nbsp;허용적이어야&nbsp;한다.&nbsp;대소문자를&nbsp;구분하지&nbsp;않고&nbsp;합리적으로&nbsp;유연해야&nbsp;한다. 좋은&nbsp;기능&nbsp;중&nbsp;하나는,&nbsp;&ldquo;CTF{663d63e8c755f1b4}&rdquo;,&nbsp;&ldquo;663D63E8C755F1B4&rdquo;,&nbsp;&ldquo;flag&nbsp;is:663D63E8C755F1B4&rdquo;&nbsp;같은&nbsp;것을&nbsp;모두&nbsp;받아들이는&nbsp;것이다. &nbsp; 또&nbsp;다른&nbsp;좋은&nbsp;기능은&nbsp;웹&nbsp;폼에&nbsp;복사하여&nbsp;붙여넣을&nbsp;때&nbsp;쉽게&nbsp;추가될&nbsp;수&nbsp;있는&nbsp;공백&nbsp;문자를&nbsp;플래그&nbsp;제출에서&nbsp;자르거나&nbsp;삭제하는&nbsp;것이다.&nbsp;-&gt;&nbsp;.strip() &nbsp; Mechanics CTF는&nbsp;재미를&nbsp;위한&nbsp;게임이지만,&nbsp;보안&nbsp;기술&nbsp;연습이기도&nbsp;하다.&nbsp;도전&nbsp;과제를&nbsp;둘러싼&nbsp;게임플레이&nbsp;매커니즘은&nbsp;재미와&nbsp;흥미를&nbsp;더할&nbsp;수&nbsp;있지만,&nbsp;항상&nbsp;보안&nbsp;기술을&nbsp;발휘하는&nbsp;것은&nbsp;아니다. &nbsp; 최고의&nbsp;CTF&nbsp;챌린지는&nbsp;재미와&nbsp;주제에&nbsp;관한&nbsp;것이다.&nbsp;팀이&nbsp;매커니즘에&nbsp;대해&nbsp;전략을&nbsp;세우는&nbsp;것은&nbsp;나쁘지&nbsp;않지만,&nbsp;CTF의&nbsp;핵심은&nbsp;항상&nbsp;보안&nbsp;문제이다. &nbsp; 따라서,&nbsp;아무리&nbsp;복잡하더라도&nbsp;CTF&nbsp;채점&nbsp;시스템은&nbsp;최고의&nbsp;보안&nbsp;기술을&nbsp;보여주는&nbsp;팀에&nbsp;큰&nbsp;보상을&nbsp;제공해야&nbsp;한다.&nbsp;게임&nbsp;매커니즘에&nbsp;열심히&nbsp;생각하고&nbsp;그것이&nbsp;악용되거나,&nbsp;핵심&nbsp;과제에서&nbsp;너무&nbsp;많은&nbsp;방해를&nbsp;받지&nbsp;않도록&nbsp;노력하자.&nbsp;(재미&nbsp;없다는&nbsp;뜻은&nbsp;아니지만,&nbsp;본&nbsp;문서에서는&nbsp;그러한&nbsp;대회에&nbsp;적용되는&nbsp;내용이&nbsp;거의&nbsp;없다.) &nbsp; Jeopardy&nbsp;스타일&nbsp;CTF의&nbsp;몇&nbsp;가지&nbsp;일반적인&nbsp;매커니즘은&nbsp;다음과&nbsp;같다.&nbsp;: 어려운&nbsp;&ldquo;역작&rdquo;&nbsp;문제를&nbsp;더&nbsp;높은&nbsp;점수를&nbsp;가지도록&nbsp;하고,&nbsp;쉽거나&nbsp;더&nbsp;하찮고&nbsp;게싱하는&nbsp;문제를&nbsp;낮은&nbsp;점수를&nbsp;가지도록&nbsp;한다.&nbsp;이는&nbsp;사람들이&nbsp;어려운&nbsp;문제를&nbsp;살펴보고&nbsp;하드코어한&nbsp;보안&nbsp;기술을&nbsp;배우도록&nbsp;장려한다.&nbsp;포인트&nbsp;값을&nbsp;미세&nbsp;조정하는&nbsp;것에&nbsp;대해서는&nbsp;걱정하지&nbsp;말자.&nbsp;&ldquo;완벽함"은&nbsp;없다.&nbsp;문제를&nbsp;테스트&nbsp;하는&nbsp;사람은&nbsp;문제를&nbsp;낸&nbsp;사람보다&nbsp;난이도를&nbsp;더&nbsp;잘&nbsp;알고&nbsp;있으므로&nbsp;테스터는&nbsp;일반적으로&nbsp;적합한&nbsp;점수&nbsp;값을&nbsp;할당한다. &ldquo;돌파&nbsp;점수"를&nbsp;사용한다.:&nbsp;각&nbsp;문제를&nbsp;처음으로&nbsp;최초&nbsp;몇&nbsp;팀에게만&nbsp;주어지는&nbsp;추가&nbsp;포인트(보통&nbsp;동점자&nbsp;처리를&nbsp;위한&nbsp;것)을&nbsp;활용한다.&nbsp;이는&nbsp;팀이&nbsp;자신들의&nbsp;플래그를&nbsp;쥐고&nbsp;있다가&nbsp;대회&nbsp;끝에서&nbsp;모두&nbsp;제출하는&nbsp;&lsquo;플래그&nbsp;키핑&rsquo;을&nbsp;방지하는데&nbsp;도움이&nbsp;된다&nbsp;(플래그&nbsp;키핑은&nbsp;종종&nbsp;유리한&nbsp;경우가&nbsp;있음).자신이 생각한 만큼 잘하지 않는다는 사실을 깨달으면 사기가 떨어지기 때문에, 돌파 점수와 같은 키핑 방지 조치를 취하는 것이 좋다 문제의 열림/닫힘 상태는 모두 동일해야 한다. 즉, 한 팀에게 문제가 열려 있다면 모든 팀에게 열려 있어야 한다. 이는 모든 팀에게 모든 문제를 살펴볼 공정한 시간과 기회를 제공하고, 불운한 문제를 열어 손해를 보는 팀이 생기는 상황을 피하는 데 도움이 된다. 점수판에 있는 모든 팀에는 항상 해결해야 할 문제가 2~3개 이상 있는지 확인해야 한다. 특정 문제에 막히는 것은 어느 팀이게나 쉽게 일어날 수 있다 (자신들의 잘못이 아닐 수도 있음). 그리고 모든 참가자들이 자신들이 다루고 싶어하는 문제를 다루도록 하는게 모두를 만족시키는 최선의 방법이다. 열려있는 미해결 문제의 수를 제한하도록 한다. 이는 대규모 팀이 큰 이점을 얻는 것을 방지하며, 내년을 위해 열리지 않은 문제를 몇 개 절약할 수 있다. &nbsp; Testing 테스팅은&nbsp;끔찍한&nbsp;문제와&nbsp;훌륭한&nbsp;문제의&nbsp;차이가&nbsp;된다.&nbsp;누군가가&nbsp;요청할&nbsp;때마다&nbsp;서비스가&nbsp;작동하고&nbsp;해결&nbsp;가능한지&nbsp;확인하기&nbsp;위해&nbsp;실행할&nbsp;수&nbsp;있는&nbsp;참조&nbsp;솔루션을&nbsp;마련해야&nbsp;한다. 원래&nbsp;문제&nbsp;작성자가&nbsp;아닌&nbsp;다른&nbsp;사람에게&nbsp;풀이를&nbsp;작성하게&nbsp;하여,&nbsp;심령술사가&nbsp;아니어도&nbsp;실행&nbsp;가능한지&nbsp;확인해야&nbsp;한다.&nbsp;모든&nbsp;것을&nbsp;테스트할&nbsp;시간이&nbsp;없다면,&nbsp;&lsquo;블랙박스&rsquo;&nbsp;기반&nbsp;문제에&nbsp;우선&nbsp;순위를&nbsp;둔다. &nbsp; &nbsp; Communication 주최자는&nbsp;CTF&nbsp;전체&nbsp;기간&nbsp;동안&nbsp;연락이&nbsp;가능하도록&nbsp;해야&nbsp;한다.&nbsp;IRC&nbsp;채널을&nbsp;만들고&nbsp;CTF&nbsp;전체에서&nbsp;이를&nbsp;모니터링&nbsp;한다.&nbsp;채널에서&nbsp;주최자들에게&nbsp;채널&nbsp;운영자&nbsp;역할을&nbsp;부여하여&nbsp;플레이어들이&nbsp;문제에&nbsp;대해&nbsp;누구와&nbsp;논의해야&nbsp;하는지&nbsp;알&nbsp;수&nbsp;있도록&nbsp;해야한다. &nbsp; 이메일&nbsp;주소를&nbsp;공개하고&nbsp;모니터링&nbsp;한다. &nbsp; 사이트에&nbsp;트위터&nbsp;스트림이나&nbsp;뉴스&nbsp;페이지와&nbsp;같은&nbsp;최소한&nbsp;하나의&nbsp;다른&nbsp;커뮤니케이션&nbsp;채널을&nbsp;가져,&nbsp;누구도&nbsp;중요한&nbsp;게임&nbsp;업데이트를&nbsp;놓치지&nbsp;않도록&nbsp;해야한다. &nbsp; &nbsp; Problem&nbsp;Updates 문제에&nbsp;변경&nbsp;사항이&nbsp;있을&nbsp;때마다&nbsp;IRC&nbsp;뿐만&nbsp;아니라&nbsp;영구적이고&nbsp;눈에&nbsp;띄는&nbsp;장소에&nbsp;이를&nbsp;발표해야&nbsp;한다. 문제&nbsp;설명을&nbsp;업데이트하여&nbsp;변경&nbsp;사항을&nbsp;반영하도록&nbsp;한다.&nbsp;변경된&nbsp;다운로드&nbsp;파일이&nbsp;있다면,&nbsp;파일&nbsp;이름을&nbsp;업데이트&nbsp;하여&nbsp;변경&nbsp;사항이&nbsp;명백하게&nbsp;드러나도록&nbsp;한다. &nbsp; 해당되는&nbsp;경우,&nbsp;원래&nbsp;버전의&nbsp;문제도&nbsp;계속&nbsp;사용&nbsp;가능하게&nbsp;하고&nbsp;운영한다.&nbsp;예를&nbsp;들어,&nbsp;업데이트&nbsp;하려는&nbsp;문제에&nbsp;대해&nbsp;누군가가&nbsp;정답에&nbsp;가까이&nbsp;다가간&nbsp;경우가&nbsp;있을&nbsp;수&nbsp;있다. 문제에&nbsp;솔버(solver)가&nbsp;있는&nbsp;경우,&nbsp;문제&nbsp;변경에&nbsp;신중해야&nbsp;한다.&nbsp;(점수&nbsp;가치,&nbsp;문제&nbsp;파일,&nbsp;설명,&nbsp;힌트를&nbsp;포함)&nbsp;이러한&nbsp;문제들은&nbsp;대부분&nbsp;사례별로&nbsp;처리해야&nbsp;하므로&nbsp;좋은&nbsp;판단력을&nbsp;발휘하기&nbsp;바란다. &nbsp; Problem&nbsp;Distribution 파일을&nbsp;배포하는&nbsp;가장&nbsp;쉬운&nbsp;방법은&nbsp;스코어보드&nbsp;서버에서&nbsp;HTTP를&nbsp;이용하는&nbsp;것이다.&nbsp;Dropbox&nbsp;및&nbsp;Google&nbsp;Drive같은&nbsp;서비스는&nbsp;대역폭&nbsp;제한에&nbsp;도달할&nbsp;수&nbsp;있으므로&nbsp;사용하지&nbsp;말아야&nbsp;한다. &nbsp; 철저한&nbsp;준비가&nbsp;되어&nbsp;있고,&nbsp;대용량&nbsp;파일이&nbsp;있는&nbsp;경우&nbsp;배포하는&nbsp;가장&nbsp;좋은&nbsp;방법은&nbsp;gpg&nbsp;또는&nbsp;openssl&nbsp;같은&nbsp;무료&nbsp;도구를&nbsp;사용하여&nbsp;대칭&nbsp;암호화하고&nbsp;CTF&nbsp;전에&nbsp;토렌트를&nbsp;배포하는&nbsp;것이다.&nbsp;그런&nbsp;다음&nbsp;CTF의&nbsp;시작(또는&nbsp;중간)에&nbsp;암호화를&nbsp;해제하여&nbsp;사람들에게&nbsp;파일에&nbsp;대한&nbsp;액세스&nbsp;권한을&nbsp;부여할&nbsp;수&nbsp;있다. &nbsp; 문제가&nbsp;열릴&nbsp;때까지&nbsp;문제에&nbsp;대한&nbsp;파일에&nbsp;접근할&nbsp;수&nbsp;없는&nbsp;지&nbsp;확인하라. &nbsp; 이를&nbsp;수행하는&nbsp;한&nbsp;가지&nbsp;간단한&nbsp;방법은&nbsp;파일&nbsp;이름에&nbsp;파일&nbsp;내용의&nbsp;해시를&nbsp;추가하여(파일&nbsp;이름을&nbsp;추측할&nbsp;수&nbsp;없도록)&nbsp;웹&nbsp;서버에서&nbsp;디렉토리&nbsp;인덱싱을&nbsp;비활성화&nbsp;하는&nbsp;것이다. &nbsp; 문제를&nbsp;다운로드&nbsp;하기&nbsp;위해&nbsp;로그인이&nbsp;필요하지&nbsp;않은&nbsp;경우에도&nbsp;좋다.&nbsp;이렇게&nbsp;하면&nbsp;플레이어들이&nbsp;wget이나&nbsp;curl같은&nbsp;도구를&nbsp;명령&nbsp;줄에서&nbsp;쉽게&nbsp;사용할&nbsp;수&nbsp;있고,&nbsp;성가신&nbsp;쿠키&nbsp;설정이나&nbsp;로그인&nbsp;처리&nbsp;스크립트를&nbsp;준비할&nbsp;필요가&nbsp;없다.&nbsp;파일명이&nbsp;비밀로&nbsp;유지된다면&nbsp;이것과&nbsp;관련된&nbsp;문제가&nbsp;없어야&nbsp;한다. &nbsp; Infrastructure 다른&nbsp;모든&nbsp;것과&nbsp;마찬가지로&nbsp;인프라의&nbsp;모든&nbsp;부분을&nbsp;주의&nbsp;깊게&nbsp;테스트해야&nbsp;한다. 많은&nbsp;CTF&nbsp;주최자들이&nbsp;웹&nbsp;사이트와&nbsp;관련한&nbsp;문제들을&nbsp;클라우드에&nbsp;호스팅하는&nbsp;것이&nbsp;유용하다고&nbsp;발견했다.&nbsp;이&nbsp;방식은&nbsp;필요에&nbsp;따라&nbsp;더&nbsp;많은&nbsp;인스턴스를&nbsp;빠르고&nbsp;쉽게&nbsp;가동할&nbsp;수&nbsp;있다. &nbsp; 최종&nbsp;배포&nbsp;인프라에서&nbsp;적절한&nbsp;테스트를&nbsp;수행해야&nbsp;한다.&nbsp;예를&nbsp;들어,&nbsp;첫&nbsp;번째&nbsp;pCTF에서&nbsp;pwnable&nbsp;문제들이&nbsp;NX를&nbsp;지원하지&nbsp;않는&nbsp;기계에서&nbsp;실행된다면&nbsp;이는&nbsp;인프라가&nbsp;철저히&nbsp;테스트되지&nbsp;않아&nbsp;CTF&nbsp;이후까지&nbsp;내용이&nbsp;누락되었다.&nbsp;(역주:&nbsp;PPP&nbsp;팀&nbsp;이야기로&nbsp;보임) &nbsp; 배포&nbsp;인프라에서&nbsp;테스트할&nbsp;항목의&nbsp;부분적인&nbsp;체크리스트: &nbsp; 팀&nbsp;등록&nbsp;및&nbsp;키&nbsp;제출에&nbsp;대한&nbsp;End&nbsp;to&nbsp;End&nbsp;Testing 키(flag)&nbsp;제출에&nbsp;중복&nbsp;계산&nbsp;race&nbsp;condition이&nbsp;없는&nbsp;지&nbsp;확인해야&nbsp;한다. 점수판 및 주요 제출에 대한 부하 테스트를 수행한다. pwnable&nbsp;머신이&nbsp;원하는&nbsp;보호&nbsp;기능을&nbsp;제공하는&nbsp;지&nbsp;확인한다. 모든&nbsp;문제에&nbsp;대한&nbsp;전체&nbsp;솔루션을&nbsp;테스트한다.&nbsp;이는&nbsp;솔루션&nbsp;스크립트를&nbsp;실행할&nbsp;수&nbsp;있고&nbsp;올바른&nbsp;키가&nbsp;출력된다는&nbsp;의미이다.&nbsp;&ldquo;내&nbsp;솔루션&nbsp;스크립트에&nbsp;eip=0x41414141이&nbsp;표시된다"는&nbsp;것으로는&nbsp;충분하지&nbsp;않을&nbsp;수&nbsp;있다. CTF&nbsp;중에&nbsp;문제&nbsp;업데이트하는&nbsp;것을&nbsp;테스트해야&nbsp;한다.&nbsp;실수가&nbsp;발생할&nbsp;수&nbsp;있으므로&nbsp;준비하는&nbsp;것이&nbsp;좋다. 서비스에서&nbsp;실행되는&nbsp;바이너리/코드가&nbsp;제공하는&nbsp;파일과&nbsp;일치하는&nbsp;지&nbsp;테스트해야&nbsp;한다. &nbsp; Problems CTF의&nbsp;목표는&nbsp;플레이어가&nbsp;배우고&nbsp;즐기는&nbsp;것임을&nbsp;기억한다. 문제의&nbsp;핵심은&nbsp;해결되는&nbsp;것이므로,&nbsp;적어도&nbsp;한&nbsp;팀&nbsp;이상이&nbsp;모든&nbsp;문제를&nbsp;해결하는&nbsp;것이&nbsp;좋다.&nbsp;창의력을&nbsp;발휘하고&nbsp;풀이자들이&nbsp;문제에서&nbsp;멋진&nbsp;점을&nbsp;배울&nbsp;수&nbsp;있도록&nbsp;노력해야&nbsp;한다. &nbsp; 플레이어가&nbsp;고객이라는&nbsp;점을&nbsp;기억하고,&nbsp;그들을&nbsp;행복하게&nbsp;만들자&nbsp;:-) &nbsp; 아래에는&nbsp;특정&nbsp;문제&nbsp;범주에&nbsp;대한&nbsp;좀&nbsp;더&nbsp;구체적인&nbsp;권장&nbsp;사항이&nbsp;있다. &nbsp; Pwnable 이&nbsp;pwnable&nbsp;섹션에서는&nbsp;Linux&nbsp;바이너리만&nbsp;구체적으로&nbsp;다룬다. &nbsp; Local 로컬&nbsp;pwnable에서는&nbsp;일반적으로&nbsp;시스템에&nbsp;대한&nbsp;ssh&nbsp;연결과&nbsp;거기에서&nbsp;setuid/setgid&nbsp;바이너리&nbsp;활용이&nbsp;포함된다. 이를&nbsp;수행하는&nbsp;가장&nbsp;좋은&nbsp;방법은&nbsp;팀이&nbsp;서로&nbsp;간섭하거나&nbsp;정보를&nbsp;유출하지&nbsp;않고&nbsp;작업할&nbsp;수&nbsp;있도록&nbsp;컴퓨터에&nbsp;팀별&nbsp;계정을&nbsp;만드는&nbsp;것이다. &nbsp; 다음은&nbsp;머신에서&nbsp;구성할&nbsp;사항에&nbsp;대한&nbsp;간단한&nbsp;체크리스트이다.&nbsp;: 컴퓨터가&nbsp;완전히&nbsp;패치되고&nbsp;최신&nbsp;상태인지&nbsp;확인한다. limits.conf를&nbsp;통해&nbsp;forkbombing&nbsp;또는&nbsp;기타&nbsp;리소스&nbsp;고갈을&nbsp;방지한다. sysctl&nbsp;-w&nbsp;kernel.dmesg_restrict=1&nbsp;#&nbsp;그리고&nbsp;/etc/sysctl.conf에&nbsp;persist&nbsp;를&nbsp;설정한다. mount&nbsp;-o&nbsp;remount,hidepid=2&nbsp;/proc&nbsp;#&nbsp;사용자가&nbsp;서로의&nbsp;프로세스를&nbsp;볼&nbsp;수&nbsp;없도록&nbsp;한다. chmod&nbsp;1733&nbsp;/tmp/var/&nbsp;/dev/shm&nbsp;#&nbsp;작업&nbsp;내용이&nbsp;다른&nbsp;사람에게&nbsp;유출되는&nbsp;것을&nbsp;방지하기&nbsp;위해&nbsp;#&nbsp;사용자별&nbsp;홈&nbsp;디렉토리가&nbsp;있는&nbsp;경우&nbsp;chmod&nbsp;700&nbsp;하면&nbsp;된다.&nbsp;:-) 문제에&nbsp;대한&nbsp;사용자를&nbsp;생성하고&nbsp;/home/problemuser/problem에&nbsp;문제를&nbsp;넣는다. chown&nbsp;-R&nbsp;root:rioot&nbsp;/home/problemuser chown&nbsp;root:problemuser&nbsp;/home/problemuser/problem chmod&nbsp;2755&nbsp;/home/problemuser/problem touch&nbsp;/home/problemuser/flag chown&nbsp;root:problemuser&nbsp;/home/problemuser/flag chmod&nbsp;440&nbsp;/home/problemuser/flag 모든&nbsp;문제와&nbsp;마찬가지로&nbsp;완전히&nbsp;설정된&nbsp;후&nbsp;완전히&nbsp;테스트한다.&nbsp;특히,&nbsp;참조&nbsp;솔루션이&nbsp;CTF&nbsp;사용자&nbsp;중&nbsp;하나로&nbsp;작동하는&nbsp;지,&nbsp;플래그가&nbsp;다른&nbsp;수단을&nbsp;통해&nbsp;읽힐&nbsp;수&nbsp;없거나&nbsp;루트&nbsp;이외의&nbsp;사용자가&nbsp;쓸&nbsp;수&nbsp;없는&nbsp;지&nbsp;확인해야&nbsp;한다. &nbsp; Local&nbsp;Kernel 로컬&nbsp;커널&nbsp;익스플로잇&nbsp;문제는&nbsp;일반적으로&nbsp;시스템에&nbsp;ssh로&nbsp;접속하고&nbsp;사용자&nbsp;정의&nbsp;커널&nbsp;드라이버를&nbsp;활용하는&nbsp;것과&nbsp;관련된다.&nbsp;이러한&nbsp;유형의&nbsp;문제는&nbsp;안정적으로&nbsp;호스팅하기&nbsp;어려울&nbsp;수&nbsp;있고,&nbsp;쉽게&nbsp;확장할&nbsp;수&nbsp;없다.&nbsp;실패한&nbsp;exploit은&nbsp;일반적으로&nbsp;운영체제를&nbsp;다운시키므로,&nbsp;각&nbsp;팀은&nbsp;자신만의&nbsp;고립된&nbsp;vm을&nbsp;가져야&nbsp;한다. &nbsp; 커널&nbsp;문제는&nbsp;팀&nbsp;수가&nbsp;적고&nbsp;충분한&nbsp;시스템&nbsp;자원이&nbsp;할당될&nbsp;수&nbsp;있는&nbsp;CTF&nbsp;&lsquo;결승전&rsquo;에&nbsp;더&nbsp;적합할&nbsp;수&nbsp;있다. &nbsp; 가능한&nbsp;설정은&nbsp;하나&nbsp;또는&nbsp;여러&nbsp;ESXi(Type&nbsp;1&nbsp;hypervisor)&nbsp;호스트를&nbsp;운영하고&nbsp;각&nbsp;팀에게&nbsp;별도의&nbsp;VM을&nbsp;지원하는&nbsp;것이다.&nbsp;그리고&nbsp;각&nbsp;팀에&nbsp;SSH&nbsp;자격&nbsp;증명을&nbsp;제공한다. &nbsp; 몇&nbsp;가지&nbsp;팁과&nbsp;알림: 20개의&nbsp;개별&nbsp;VM을&nbsp;만드는&nbsp;대신&nbsp;하나의&nbsp;기본&nbsp;VM을&nbsp;만들고&nbsp;20개의&nbsp;연결된&nbsp;클론을&nbsp;만든다. 각&nbsp;VM이&nbsp;생성된&nbsp;후&nbsp;로그인하고&nbsp;고유한&nbsp;고정&nbsp;IP&nbsp;주소를&nbsp;구성한다. 모든&nbsp;공개&nbsp;취약점에&nbsp;대해&nbsp;운영체제가&nbsp;완전히&nbsp;업데이트&nbsp;되고&nbsp;패치되었는지&nbsp;확인한다. 사용자를&nbsp;sudo&nbsp;접근에서&nbsp;제거한다. /root에&nbsp;플래그를&nbsp;생성하고:&nbsp;chmod&nbsp;400&nbsp;-R&nbsp;/root;&nbsp;chown&nbsp;root:root&nbsp;-R&nbsp;/root /root/.ssh에&nbsp;member&nbsp;SSH&nbsp;key를&nbsp;삭제하고&nbsp;원격&nbsp;루트&nbsp;SSH&nbsp;로그인을&nbsp;활성화하면&nbsp;잠재적인&nbsp;문제를&nbsp;해결하는&nbsp;데&nbsp;도움이&nbsp;된다. 문제의&nbsp;일부가&nbsp;정보&nbsp;유출이&nbsp;아니라면,&nbsp;모든&nbsp;사용자가&nbsp;/proc/kallsyms를&nbsp;읽을&nbsp;수&nbsp;있도록&nbsp;허용한다:&nbsp;echo&nbsp;&gt;&nbsp;/proc/sys/kernel/kptr_restrict 오류(oopses)에&nbsp;대한&nbsp;커널&nbsp;패닉을&nbsp;비활성화&nbsp;한다.:&nbsp;echo&nbsp;0&nbsp;&gt;&nbsp;/proc/sys/kernel/panic_on_oops 원격&nbsp;VM을&nbsp;재부팅하기&nbsp;위해&nbsp;팀에서&nbsp;호출할&nbsp;수&nbsp;있는&nbsp;간단한(인증된)&nbsp;스크립트를&nbsp;개발한다.&nbsp;Exploit&nbsp;시도&nbsp;후,&nbsp;게스트&nbsp;OS가&nbsp;응답하지&nbsp;않을&nbsp;수&nbsp;있으므로&nbsp;이는&nbsp;게스트가&nbsp;아닌&nbsp;하이퍼바이저와&nbsp;상호작용해야&nbsp;한다.&nbsp;그렇지&nbsp;않으면&nbsp;팀에서&nbsp;재부팅을&nbsp;자주&nbsp;요청하게&nbsp;된다. 작동하는&nbsp;솔루션이&nbsp;존재하고&nbsp;예상되는&nbsp;모든&nbsp;완화&nbsp;조치가&nbsp;실제로&nbsp;VM에서&nbsp;작동하는지&nbsp;확인한다.&nbsp;여기에는&nbsp;읽기&nbsp;전용&nbsp;메모리&nbsp;SMEP/SMAP&nbsp;등이&nbsp;포함된다. 커널&nbsp;챌린지는&nbsp;재미있어야&nbsp;한다! &nbsp; 단순히&nbsp;오래된&nbsp;OS를&nbsp;설치하고&nbsp;참가자들에게&nbsp;공개적인&nbsp;악용&nbsp;코드를&nbsp;컴파일하라고&nbsp;하는&nbsp;것이&nbsp;아니라,&nbsp;도전&nbsp;과제를&nbsp;창의적으로&nbsp;만드는&nbsp;여러&nbsp;방법들이&nbsp;있다. 또한&nbsp;연결&nbsp;시&nbsp;qemu를&nbsp;통해&nbsp;실행될&nbsp;수&nbsp;있는&nbsp;매우&nbsp;최소한의&nbsp;VM을&nbsp;buildroot로&nbsp;구축하는&nbsp;것이&nbsp;간편하다. &nbsp; 위의&nbsp;참고&nbsp;사항이&nbsp;적용되지만&nbsp;이러한&nbsp;접근&nbsp;방식에는&nbsp;몇&nbsp;가지&nbsp;주의점이&nbsp;있다. &nbsp; 몇&nbsp;가지&nbsp;팁: &nbsp; VM에&nbsp;네트워킹이&nbsp;되어있는&nbsp;지&nbsp;확인한다.&nbsp;일부&nbsp;초소형&nbsp;VM에&nbsp;16진수/셸코드를&nbsp;붙여넣는&nbsp;것은&nbsp;재미가&nbsp;없다. 실행&nbsp;중인&nbsp;vm의&nbsp;디버깅을&nbsp;비활성화&nbsp;하기&nbsp;위해&nbsp;qemu&nbsp;모니터에&nbsp;접근을&nbsp;비활성화&nbsp;한다.&nbsp;:&nbsp;-monitor&nbsp;/dev/null 가능하면,&nbsp;Ctrl+C를&nbsp;눌러도&nbsp;연결이&nbsp;끊기지&nbsp;않도록&nbsp;curses&nbsp;모드로&nbsp;qemu&nbsp;인스턴스를&nbsp;로그인&nbsp;셸로&nbsp;설정한다. 대규모&nbsp;CTF라면&nbsp;qemu를&nbsp;시작하기&nbsp;전에&nbsp;어떤&nbsp;종류의&nbsp;캡챠&nbsp;또는&nbsp;작업&nbsp;증명을&nbsp;두는&nbsp;것이&nbsp;좋을&nbsp;수&nbsp;있다. 모든&nbsp;연결이&nbsp;&ldquo;새로운&rdquo;&nbsp;VM을&nbsp;받도록&nbsp;한다.&nbsp;연결&nbsp;시&nbsp;디스크&nbsp;이미지를&nbsp;복사본으로&nbsp;교체하는&nbsp;것은&nbsp;쉽고,&nbsp;작은&nbsp;VM의&nbsp;경우에는&nbsp;오버헤드가&nbsp;많지&nbsp;않아야&nbsp;한다. KVM은&nbsp;EC2/Azure같은&nbsp;가상화된&nbsp;환경에서&nbsp;사용할&nbsp;수&nbsp;없다.&nbsp;하드웨어&nbsp;가상화&nbsp;없이도&nbsp;VM의&nbsp;속도가&nbsp;충분히&nbsp;빠른&nbsp;지&nbsp;테스트하여&nbsp;반응성을&nbsp;확인한다. Remote Remote&nbsp;pwnable에는&nbsp;취약한&nbsp;네트워크&nbsp;서비스&nbsp;실행이&nbsp;포함된다.&nbsp;이를&nbsp;해결하는&nbsp;두&nbsp;가지&nbsp;인기있는&nbsp;방법이&nbsp;있다. xinetd를&nbsp;사용하는&nbsp;것과&nbsp;바이너리&nbsp;자체에서&nbsp;fork/accept를&nbsp;하는&nbsp;것이다. &nbsp; 각&nbsp;연결마다&nbsp;스레드를&nbsp;사용하지&nbsp;말아야&nbsp;한다.&nbsp;이는&nbsp;보통&nbsp;사용자들이&nbsp;서로의&nbsp;Exploit을&nbsp;방해하게&nbsp;하며(의도적으로나&nbsp;우연히나),&nbsp;문제를&nbsp;매우&nbsp;짜증나게&nbsp;만들&nbsp;수&nbsp;있다. &nbsp; 문제가&nbsp;libc&nbsp;leak에&nbsp;의존하는&nbsp;경우,&nbsp;문제&nbsp;바이너리와&nbsp;함께&nbsp;libc.so를&nbsp;제공하는&nbsp;것을&nbsp;고려해야&nbsp;한다.&nbsp;libc를&nbsp;찾는&nbsp;것은&nbsp;CTF에서&nbsp;테스트할&nbsp;흥미로운&nbsp;기술이&nbsp;아니다. &nbsp; xinetd&nbsp;대신&nbsp;자체&nbsp;fork/accept&nbsp;서버를&nbsp;사용하는&nbsp;경우,&nbsp;서비스를&nbsp;Exploit&nbsp;하는&nbsp;사람이&nbsp;서비스를&nbsp;종료하거나&nbsp;점령할&nbsp;수&nbsp;없도록&nbsp;특별한&nbsp;주의를&nbsp;기울여야&nbsp;한다. &nbsp; 일반적인&nbsp;방법은&nbsp;서비스를&nbsp;루트로&nbsp;시작하고&nbsp;forking&nbsp;후&nbsp;권한을&nbsp;하락시키는&nbsp;것이다.&nbsp;(그리고&nbsp;소켓&nbsp;fd를&nbsp;유출하지&nbsp;않도록&nbsp;주의한다) &nbsp; 이&nbsp;권장&nbsp;사항을&nbsp;따르는&nbsp;샘플&nbsp;fork/accept&nbsp;서버는&nbsp;fork_accept.c&nbsp;를&nbsp;참조하라. &nbsp; xinetd&nbsp;서비스에&nbsp;대한&nbsp;샘플&nbsp;xinetd구성은&nbsp;example.xinetd를&nbsp;참조하라. &nbsp; chroot&nbsp;또는&nbsp;제한된&nbsp;환경에서&nbsp;챌린지를&nbsp;시작하기로&nbsp;한&nbsp;경우,&nbsp;/bin/sh,&nbsp;/bin/bash,&nbsp;/bin/cat&nbsp;같은&nbsp;기본&nbsp;프로그램이&nbsp;있는지&nbsp;확인한다.&nbsp;이것이&nbsp;불가능하다면&nbsp;문제&nbsp;설명에서&nbsp;그&nbsp;사실을&nbsp;명확히&nbsp;해야한다. &nbsp; 서비스를&nbsp;완전히&nbsp;Exploit하고&nbsp;제한된&nbsp;chroot에서&nbsp;실행되고&nbsp;있다는&nbsp;것을&nbsp;깨닫기까지&nbsp;한&nbsp;시간을&nbsp;낭비하는&nbsp;것은&nbsp;매우&nbsp;짜증나는&nbsp;일이다. &nbsp; remote&nbsp;pwnalbe을&nbsp;설정하기&nbsp;위한&nbsp;지침: 문제를&nbsp;위한&nbsp;사용자를&nbsp;생성하고&nbsp;문제를&nbsp;/home/problemuser/problem에&nbsp;둔다. chown&nbsp;-R&nbsp;root:problemuser&nbsp;/home/problemuser chmod&nbsp;750&nbsp;/home/problemuser touch&nbsp;/home/problemuser/flag chown&nbsp;root:problemuser&nbsp;/home/problemuser/flag chmod&nbsp;440&nbsp;/home/problemuser/flag &nbsp; short&nbsp;read에&nbsp;의존하지&nbsp;않도록&nbsp;한다.&nbsp;원격으로&nbsp;올바르게&nbsp;처리하기&nbsp;어려울&nbsp;수&nbsp;있다.&nbsp;대신,&nbsp;구분자가&nbsp;나타날&nbsp;때까지&nbsp;한&nbsp;바이트씩&nbsp;읽거나&nbsp;길이로&nbsp;제한된&nbsp;문자열&nbsp;읽기를&nbsp;고려한다.&nbsp;(e.g.&nbsp;4바이트&nbsp;리틀&nbsp;엔디언&nbsp;길이를&nbsp;읽은&nbsp;다음&nbsp;데이터&nbsp;길이만큼의&nbsp;바이트를&nbsp;읽음). &nbsp; 마찬가지로&nbsp;read/recv&nbsp;호출&nbsp;시&nbsp;반환&nbsp;값이&nbsp;확인되어&nbsp;사용자&nbsp;입력이&nbsp;누락되지&nbsp;않도록&nbsp;한다. 명확히&nbsp;하기&nbsp;위해,&nbsp;4096&nbsp;바이트를&nbsp;읽는&nbsp;잘못된&nbsp;예시는&nbsp;다음과&nbsp;같다: &nbsp; char buf[4096]; recv(fd, buf, sizeof(buf)); // 이 부분이 잘못됨. recv는 &lt; 4096을 반환할 수 있음 &nbsp; 더&nbsp;나은&nbsp;방법은&nbsp;fork_accept.c&nbsp;의&nbsp;recvlen함수를&nbsp;참조하라. &nbsp; /home/problemuser/flag&nbsp;같이&nbsp;예측&nbsp;가능한&nbsp;위치에&nbsp;flag를&nbsp;배치한다.&nbsp;서비스를&nbsp;성공적으로&nbsp;exploit&nbsp;한&nbsp;후&nbsp;플래그를&nbsp;찾는데&nbsp;시간을&nbsp;낭비하는&nbsp;것은&nbsp;실망스럽다. &nbsp; General&nbsp;notes 제대로&nbsp;작동하는&nbsp;pwnable&nbsp;문제를&nbsp;만드는&nbsp;데&nbsp;가장&nbsp;중요한&nbsp;부분&nbsp;중&nbsp;하나는&nbsp;적절한&nbsp;테스트이다&nbsp;(이상적으로는&nbsp;저자&nbsp;이외의&nbsp;최소&nbsp;한&nbsp;명이&nbsp;테스트해야&nbsp;한다). &nbsp; 누군가&nbsp;pwnable이&nbsp;작동하지&nbsp;않는다고&nbsp;불평할&nbsp;때마다,&nbsp;문제가&nbsp;작동하는지&nbsp;여부를&nbsp;확인할&nbsp;수&nbsp;있는&nbsp;완전한&nbsp;참조&nbsp;솔루션을&nbsp;실시간&nbsp;인스턴스에&nbsp;대해&nbsp;실행할&nbsp;수&nbsp;있어야&nbsp;한다. &nbsp; 다음은&nbsp;pwnable에서&nbsp;일반적으로&nbsp;짜증나는&nbsp;몇&nbsp;가지&nbsp;사항들이다: 귀찮은 출력 파싱 출력은 간단하고 파싱하기 쉽게 유지해야한다.파싱하기 가장 좋은 유형의 출력은 길이로 제한된 문자열이다.귀찮은&nbsp;출력&nbsp;형식의&nbsp;예:&nbsp;ASCII&nbsp;십진수&nbsp;길이로&nbsp;구분된&nbsp;문자열&nbsp;121A1B1C1D1E1F&nbsp;이를&nbsp;어떻게&nbsp;구분&nbsp;분석해야&nbsp;하는가?&nbsp;(12,&nbsp;1A1B1C1D1E1F)?&nbsp;(1,&nbsp;&lsquo;2&rsquo;),&nbsp;(1,&nbsp;&lsquo;A&rsquo;),&nbsp;(1,&nbsp;&lsquo;C&rsquo;),&nbsp;(1,&nbsp;&lsquo;D&rsquo;),&nbsp;(1,&nbsp;&lsquo;E&rsquo;),&nbsp;(1,&nbsp;&lsquo;F&rsquo;)?&nbsp;또&nbsp;다른&nbsp;귀찮은&nbsp;출력&nbsp;형식은&nbsp;ANSI&nbsp;이스케이프&nbsp;코드가&nbsp;포함된&nbsp;것이다.&nbsp;(자제&nbsp;바람) 바이너리&nbsp;NX가&nbsp;활성되어&nbsp;있어도,&nbsp;실행되는&nbsp;기계가&nbsp;이를&nbsp;지원하지&nbsp;않는&nbsp;경우 말이&nbsp;안&nbsp;되는&nbsp;코드와&nbsp;&lsquo;가짜&rsquo;버그,&nbsp;코드의&nbsp;90%가&nbsp;리버싱&nbsp;시간&nbsp;낭비를&nbsp;위해&nbsp;입력을&nbsp;무작위&nbsp;상수와&nbsp;비교하는&nbsp;것.&nbsp;이는 재미있는 문제가 아니다. 버그가 무작위 제약 조건이 충족되었을 때, 프로그램이 아무 이유 없이 해당 버퍼로 점프하는 것이라면, 조금 더 창의적이어야 한다. &nbsp; Compile&nbsp;time&nbsp;proetections pwnable을&nbsp;위해&nbsp;특정&nbsp;보호&nbsp;기능들이&nbsp;활성화되어야&nbsp;하는&nbsp;경우가&nbsp;있다. &nbsp; 여기&nbsp;gcc에서&nbsp;이들을&nbsp;강제로&nbsp;켜거나&nbsp;끄는&nbsp;방법이&nbsp;있다: &nbsp; -fstack-protector / -fno-stack-protector: stack canary -D_FORTIFY_SOURCE=2/&nbsp;-D_FORTIFY_SOURCE=0(재&nbsp;정의&nbsp;경고를&nbsp;무시하기&nbsp;위해&nbsp;U_FORTIFY_SOURCE를&nbsp;앞에&nbsp;추가):&nbsp;memcpy(),&nbsp;sprintf(),&nbsp;read()&nbsp;등의&nbsp;libc&nbsp;함수&nbsp;버전을&nbsp;사용하여&nbsp;버퍼&nbsp;오버플로우를&nbsp;감지할&nbsp;때&nbsp;중단한다.(감지가&nbsp;완벽하지&nbsp;않고&nbsp;많은&nbsp;경우에&nbsp;작동하지&nbsp;않는다는&nbsp;점에&nbsp;주의한다.) -fPIE&nbsp;-pie/&nbsp;-fno-PIE:&nbsp;위치&nbsp;독립적&nbsp;코드(ASLR을&nbsp;확장하여&nbsp;라이브러리&nbsp;뿐만&nbsp;아니라&nbsp;기본&nbsp;바이너리도&nbsp;무작위화&nbsp;함).&nbsp;PIE는&nbsp;일반적으로&nbsp;32비트에서는&nbsp;효과적이지&nbsp;않다.&nbsp;즉,&nbsp;PIE를&nbsp;인식하지&nbsp;못하는&nbsp;악용은&nbsp;수백/수천&nbsp;번에&nbsp;한&nbsp;번씩&nbsp;성공할&nbsp;것이다.&nbsp;-fPIC는&nbsp;메인&nbsp;실행&nbsp;파일의&nbsp;일부가&nbsp;아닌&nbsp;코드에&nbsp;적용될&nbsp;수&nbsp;있도록&nbsp;(특정&nbsp;최적화를&nbsp;피함으로써)&nbsp;-fPIE의&nbsp;버전이며,&nbsp;-fpie와&nbsp;-fpic도&nbsp;있다. Wl,&nbsp;-z,&nbsp;relro&nbsp;-z,&nbsp;now/&nbsp;?:&nbsp;FULL&nbsp;RELRO&nbsp;(GOT와&nbsp;PLT가&nbsp;프로그램&nbsp;로드&nbsp;중에&nbsp;쓰여지고&nbsp;읽기&nbsp;전용으로&nbsp;매핑됨). &nbsp; 보안이&nbsp;더욱&nbsp;주요&nbsp;이슈가&nbsp;되면서,&nbsp;더&nbsp;많은&nbsp;컴파일&nbsp;시간&nbsp;및&nbsp;런타임&nbsp;보호&nbsp;기능들이&nbsp;기본적으로&nbsp;활성화되고&nbsp;있다. 따라서,&nbsp;예상치&nbsp;못한&nbsp;상황을&nbsp;피하기&nbsp;위해&nbsp;문제를&nbsp;최종&nbsp;구성&nbsp;및&nbsp;설정에서&nbsp;실제로&nbsp;테스트하는&nbsp;것이&nbsp;중요하다. &nbsp; Web&nbsp;Challenges 문제에&nbsp;많은&nbsp;수의&nbsp;요청이나,&nbsp;타이밍&nbsp;측정을&nbsp;필요로&nbsp;한다면,&nbsp;원격으로도&nbsp;합리적으로&nbsp;해결할&nbsp;수&nbsp;있도록&nbsp;해야한다. &nbsp; 더&nbsp;나아가,&nbsp;같은&nbsp;네트워크&nbsp;상에&nbsp;일반적인&nbsp;스트립팅&nbsp;언어와&nbsp;라이브러리가&nbsp;설치된&nbsp;셸&nbsp;서버(SSH&nbsp;로그인이&nbsp;가능한&nbsp;pwnable&nbsp;일&nbsp;수&nbsp;있음)을&nbsp;두어&nbsp;플레이얻르이&nbsp;공격을&nbsp;실행할&nbsp;수&nbsp;있게&nbsp;하는&nbsp;것이&nbsp;좋다. &nbsp; 다음은&nbsp;피해야&nbsp;할&nbsp;몇가지&nbsp;사항들이다: 플레이어에게&nbsp;URL&nbsp;매개변수를&nbsp;추측하도록&nbsp;요구(e.g.&nbsp;?debug=1) 플레이어에게&nbsp;파일이나&nbsp;디렉터리&nbsp;이름을&nbsp;추측하도록&nbsp;요구(또는&nbsp;서버에&nbsp;dirbuster&nbsp;사용) 플레이어에게&nbsp;크리덴셜을&nbsp;추측하도록&nbsp;요구 (패턴을 알아채셨나요?) &nbsp; 웹&nbsp;문제에서&nbsp;훌륭한&nbsp;유형&nbsp;중&nbsp;하나는&nbsp;전체&nbsp;소스&nbsp;코드가&nbsp;제공되는&nbsp;것이다&nbsp;(그럼에도&nbsp;여전히&nbsp;도전적인&nbsp;경우). &nbsp; Reversing 입력이&nbsp;유효한지&nbsp;확인하는&nbsp;문제는&nbsp;항상&nbsp;정확히&nbsp;하나의&nbsp;정답을&nbsp;받아들여야&nbsp;하는&nbsp;것이&nbsp;매우&nbsp;중요하다. &nbsp; 이는&nbsp;리버싱&nbsp;문제에서&nbsp;가장&nbsp;흔한&nbsp;문제를&nbsp;일으키는&nbsp;실수이다.&nbsp;이것이&nbsp;불가능한&nbsp;경우,&nbsp;문제&nbsp;설명에서&nbsp;이를&nbsp;명확히&nbsp;하고,&nbsp;어떤&nbsp;입력&nbsp;플래그도&nbsp;받아들이고&nbsp;점수를&nbsp;받을&nbsp;수&nbsp;있는&nbsp;플래그&nbsp;출력&nbsp;양식을&nbsp;마련한다. &nbsp; 리버싱의&nbsp;일반적인&nbsp;리얼&nbsp;월드&nbsp;사례&nbsp;중&nbsp;하나는&nbsp;악성&nbsp;코드(malware)이지만,&nbsp;악의적인&nbsp;리버싱&nbsp;문제를&nbsp;배포하는&nbsp;것은&nbsp;나쁜&nbsp;취향으로&nbsp;간주된다. &nbsp; 이렇게&nbsp;하려는&nbsp;경우,&nbsp;해당&nbsp;프로그램이&nbsp;악성이라는&nbsp;점을&nbsp;명확히&nbsp;명시해야&nbsp;한다. &nbsp; Crypto 일반적으로,&nbsp;참가자들에게&nbsp;가능한&nbsp;많은&nbsp;정보를&nbsp;제공하려고&nbsp;노력해야&nbsp;한다. &nbsp; 비밀&nbsp;키가&nbsp;명확하게&nbsp;X로&nbsp;표시된&nbsp;소스코드와&nbsp;함께&nbsp;제공하는&nbsp;것이&nbsp;이상적이다. &nbsp; 문제가&nbsp;암호문만&nbsp;있는&nbsp;경우,&nbsp;다음을&nbsp;수행해보자: 의미&nbsp;있는&nbsp;통계를&nbsp;위해&nbsp;충분한&nbsp;암호문을&nbsp;제공한다&nbsp;(스무&nbsp;개의&nbsp;ASCII&nbsp;문자는&nbsp;거의&nbsp;무엇이든&nbsp;될&nbsp;수&nbsp;있다.) 추측 가능한 알고리즘을 사용한다. 고전 암호와 짧은 암호문을 사용할 때, 그것을 좁혀내기는 매우 어려울 수 있다. 도전은 암호 시스템을 깨는 것이지, 암호 시스템이 무엇인지 알아내는 것이 아니다. 19세기&nbsp;이후에&nbsp;만들어진&nbsp;암호&nbsp;시스템을&nbsp;사용하는&nbsp;경우,&nbsp;참가자들에게&nbsp;알고리즘이&nbsp;무엇인지&nbsp;반드시&nbsp;알려주어야&nbsp;한다.&nbsp;아무도&nbsp;암호문이&nbsp;에니그마나&nbsp;퍼플&nbsp;머신에서&nbsp;나온&nbsp;것인지,&nbsp;아니면&nbsp;3DES나&nbsp;GOST에서&nbsp;나온&nbsp;것인지&nbsp;추측하고&nbsp;싶어하지&nbsp;않는다. 문제가&nbsp;많은&nbsp;로컬&nbsp;계산을&nbsp;요구하는&nbsp;경우,&nbsp;합리적인&nbsp;소비자&nbsp;하드웨어에서&nbsp;테스트하여야&nbsp;한다.&nbsp;문제를&nbsp;해결하는&nbsp;올바른&nbsp;방법이&nbsp;있지만&nbsp;종료되기&nbsp;전에&nbsp;계산을&nbsp;완료할&nbsp;수&nbsp;없다는&nbsp;것을&nbsp;대회&nbsp;후반에&nbsp;깨닫는&nbsp;것은,&nbsp;기분이&nbsp;좋지&nbsp;않다.&nbsp;일반적으로&nbsp;현대적인&nbsp;소비자&nbsp;하드웨어에서&nbsp;1시간&nbsp;미만이면&nbsp;괜찮다.&nbsp;그&nbsp;이상이라면&nbsp;정당한&nbsp;근거가&nbsp;있어야&nbsp;한다. &nbsp; Forensics 포렌식은&nbsp;다음과&nbsp;같은&nbsp;여러&nbsp;요소가&nbsp;혼합되어&nbsp;포함될&nbsp;수&nbsp;있다. 네트워크(pcap&nbsp;파일) Recon(CVE,&nbsp;사람,&nbsp;위치&nbsp;식별) 안티 포렌식 기술 대부분&nbsp;포렌식&nbsp;도전과제는&nbsp;사건&nbsp;대응과&nbsp;연계될&nbsp;수&nbsp;있으며,&nbsp;학습자에게&nbsp;주의를&nbsp;기울여&nbsp;처리하는&nbsp;방법을&nbsp;가르친다. &nbsp; 이는&nbsp;파일을&nbsp;실행하거나&nbsp;부주의하게&nbsp;다루면(도전&nbsp;과제의)&nbsp;데이터&nbsp;손실이나&nbsp;문제를&nbsp;해결하는데&nbsp;필요한&nbsp;중요한&nbsp;정보의&nbsp;손실로&nbsp;이어질&nbsp;수&nbsp;있다는&nbsp;것을&nbsp;의미한다. &nbsp; 예를&nbsp;들어,&nbsp;포렌식&nbsp;전문가들은&nbsp;데이터의&nbsp;무결성이&nbsp;법정에서&nbsp;사용될&nbsp;경우,&nbsp;진실되고&nbsp;유효하게&nbsp;유지되도록&nbsp;하는&nbsp;방법으로&nbsp;쓰기&nbsp;방지&nbsp;도구를&nbsp;사용한다. &nbsp; 도전&nbsp;과제는&nbsp;플레이어들을&nbsp;하나의&nbsp;여정,&nbsp;여러&nbsp;데이터&nbsp;소스를&nbsp;통한&nbsp;조사로&nbsp;이끌어&nbsp;결국&nbsp;하나의&nbsp;해결책으로&nbsp;귀결되도록&nbsp;해야&nbsp;한다. &nbsp; 네트워크&nbsp;도전&nbsp;과제(.pcap&nbsp;등)를&nbsp;만들&nbsp;때,&nbsp;&ldquo;TCP&nbsp;스트림&nbsp;따라가기&rdquo;&nbsp;과정보다는&nbsp;플레이어가&nbsp;데이터의&nbsp;다양한&nbsp;출처와&nbsp;목적지,&nbsp;그들&nbsp;사이의&nbsp;타이밍을&nbsp;이해하고&nbsp;이를&nbsp;스토리로&nbsp;매핑하도록&nbsp;하기를&nbsp;바란다. 기본적인&nbsp;인코딩,&nbsp;암호화&nbsp;또는&nbsp;사용자&nbsp;정의&nbsp;프로토콜을&nbsp;추가하는&nbsp;것은&nbsp;더&nbsp;고급&nbsp;도전과제에&nbsp;훌륭할&nbsp;수&nbsp;있지만,&nbsp;네트워크&nbsp;포렌식&nbsp;도전&nbsp;과제를&nbsp;암호학&nbsp;문제&nbsp;정의로&nbsp;바꾸지&nbsp;않도록&nbsp;주의해야&nbsp;한다.;&nbsp;여기서&nbsp;강조하고&nbsp;싶은&nbsp;기술은&nbsp;네트워크&nbsp;개념과&nbsp;기술을&nbsp;이해하고&nbsp;wireshark/tshark/scapy를&nbsp;자신있게&nbsp;활용할&nbsp;수&nbsp;있는&nbsp;플레이어의&nbsp;능력을&nbsp;강화하는&nbsp;것이다. 계획된&nbsp;잡은/간섭이&nbsp;있는&nbsp;샌드박스에서&nbsp;도전&nbsp;과제를&nbsp;만들자.&nbsp;드롭박스&nbsp;패킷이&nbsp;날아다니는&nbsp;로컬&nbsp;기계에서&nbsp;실행하지&nbsp;않도록&nbsp;한다. 분명&nbsp;사물인터넷(IoT)&nbsp;기기,&nbsp;QR&nbsp;코드&nbsp;조회,&nbsp;프록시/VPN을&nbsp;통한&nbsp;공격자&nbsp;원본&nbsp;IP&nbsp;출처&nbsp;찾기&nbsp;등을&nbsp;실험해보자.&nbsp;이런&nbsp;것들은&nbsp;모두&nbsp;유효한&nbsp;실제&nbsp;사례이며,&nbsp;플레이어가&nbsp;관찰하고&nbsp;식별하며&nbsp;분석할&nbsp;것을&nbsp;요구한다. &nbsp; Miscellaneous 가능한&nbsp;다음은&nbsp;피하도록&nbsp;한다: 랜덤&nbsp;게싱&nbsp;문제 zip파일이나&nbsp;stego&nbsp;프로그램의&nbsp;비밀번호&nbsp;크래킹 스테가노&nbsp;그래피&nbsp;문제 Metasploit, nessus, dirbuster 등을 실행하여 해결되는 모든 것, 좋은 CTF 문제에는 기술이 필요하다. 시간이&nbsp;많이&nbsp;걸리는&nbsp;Recon&nbsp;문제 &nbsp; 마치며 이상으로&nbsp;문서의&nbsp;번역을&nbsp;마치며, &nbsp; 해당&nbsp;글은&nbsp;CTF를&nbsp;운영하는&nbsp;사람이나,&nbsp;CTF&nbsp;참가자&nbsp;모두에게&nbsp;도움이&nbsp;될&nbsp;것으로&nbsp;기대한다. CTF&nbsp;참가자는&nbsp;CTF의&nbsp;운영을&nbsp;이해하고&nbsp;어떤&nbsp;문제들이&nbsp;어떻게&nbsp;출제되는&nbsp;지&nbsp;큰&nbsp;그림을&nbsp;그릴&nbsp;수&nbsp;있으며,&nbsp;CTF&nbsp;운영자는&nbsp;직접적으로&nbsp;CTF에&nbsp;어떤&nbsp;문제를&nbsp;출제하고&nbsp;어떻게&nbsp;운영해야하는&nbsp;지&nbsp;알&nbsp;수&nbsp;있기&nbsp;때문이다. &nbsp; (실제로&nbsp;위&nbsp;내용의&nbsp;부적절한&nbsp;사항에&nbsp;해당하는&nbsp;CTF들을&nbsp;참가해본&nbsp;경험이&nbsp;자주&nbsp;있었다.)]]></summary></entry></feed>
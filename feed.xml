<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://neutrinox4b1.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://neutrinox4b1.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-26T06:50:40+00:00</updated><id>https://neutrinox4b1.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">HTTP(S), SMTP, POP3, IMAP 기본</title><link href="https://neutrinox4b1.github.io/blog/2025/https-smtp-pop3-imap/" rel="alternate" type="text/html" title="HTTP(S), SMTP, POP3, IMAP 기본"/><published>2025-01-23T05:44:28+00:00</published><updated>2025-01-23T05:44:28+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/https-smtp-pop3-imap-</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/https-smtp-pop3-imap/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[HTTP(S) 메소드 GET HTML 파일이나 이미지 등의 데이터를 서버에서 검색 POST 양식을 제출하거나 파일을 업로드하는 등 서버에 새로운 데이터를 제출 PUT 서버에 새로운 리소스를 생성하고 기존 정보를 업데이트, 덮어쓰는데 사용 DELETE 서버에서 지정된 파일이나 리소스를 삭제하는데 사용 HTTP는 80/tcp 사용, HTTPS는 443/tcp 사용 $ telnet &lt;ip addr&gt; 80 GET / HTTP/1.1 Host: &lt;ip&gt; &nbsp; 이런 식으로 사용 가능하며, 마지막에 개행이 두 번 들어가야 보내짐 &nbsp; FTP (File Transfer Protocol) 파일 전송에 최적화된 프로토콜임 USER 사용자 이름 입력 PASS 패스워드 입력 RETR FTP 서버에서 클라이언트로 파일 다운로드 시 사용 STOR 클라이언트에서 서버로 파일 업로드 시 사용 FTP 서버는 기본적으로 21번 포트를 사용하여 수신함 데이터 전송은 다른 연결을 맺어 수행됨 &nbsp; $ ftp &lt;IP addr&gt; USER &lt;username&gt; PASS &lt;password&gt; LIST ls type ascii get &lt;filename&gt; quit &nbsp; type을 통해 binary인지, ascii인지를 명시하여야 함. binary 타입으로 텍스트파일을 가져올 시 텍스트가 꺠질 수 있음 &nbsp; SMTP (Simple Mail Transfer Protocol) SMTP는 이메일을 보내는데에 사용됨 HELO 또는 EHLO SMTP 세션을 시작함 MAIL FROM 발신자 이메일 주소를 지정함 RCPT TO 수신자 이메일 주소를 지정함 DATA 클라이언트가 이메일 내용을 보내기 시작함을 의미함 . 한 줄에 전송함으로써 끝을 나타냄 SMTP는 25/tcp 포트를 사용함 $ telnet &lt;IP addr&gt; 25 HELO client.thm MAIL FROM: &lt;user@client.thm&gt; RCPT TO: &lt;strategos@server.thm&gt; DATA From: user@client.thm To: strategos@server.thm Subject: Telnet email Hello. I am using telnet to send you an email! . QUIT &nbsp; &nbsp; &nbsp; POP3 (Post Office Protocol v3) 이메일을 수신하고 로컬 메일 클라이언트에 다운로드 하는데 사용됨. POP3는 클라이언트가 메일서버와 통신하고 메시지를 검색할 수 있도록 설계됨 &nbsp; USER &lt;username&gt; 사용자 식별 PASS &lt;password&gt; 사용자 비밀번호 제공 STAT 메시지 수와 총 크기를 요청함 LIST 모든 메시지와 해당 크기를 나열함 RETR &lt;message_number&gt; 메시지를 검색함 DELE &lt;message_number&gt; 메시지를 삭제함 QUIT 변경사항을 적용하여 POP3 세션을 종료함 POP3는 기본적으로 110/tcp 를 사용함 $ telnet &lt;IP addr&gt; 110 AUTH USER linda PASS Pa$$123 STAT LIST RETR 3 QUIT &nbsp; &nbsp; &nbsp; IMAP (Internet Message Access Protocol) 한 기기에서 작업할 때는 POP3로 충분하지만, 여러 클라이언트에서 이메일을 확인하고 동기화를 수행할 필요가 있을 때는 IMAP을 사용하는 것이 적절함 IMAP는 POP3와 달리 이메일을 서버에 보관하고 이메일 클라이언트간에 동기화를 수행하여 더 많은 저장소를 사용함 LOGIN &lt;username&gt; &lt;password&gt; 사용자를 인증함 SELECT &lt;mailbox&gt; 작업할 사서함 폴더를 선택함 FETCH &lt;mail_number&gt;&nbsp; &lt;data_item_name&gt; FETCH 3 body[] 메시지 번호 3, 헤더 본문을 가져옴 MOVE &lt;sequence_set&gt; &lt;mailbox&gt; 지정된 메시지를 다른 사서함으로 이동함 COPY &lt;sequence_set&gt; &lt;mailbox&gt; 지정된 메시지를 다른 사서함으로 복사함 LOGOUT 로그아웃 143/tcp 를 사용함 $ telnet &lt;IP addr&gt; 143 LOGIN strategos Pa$$123 SELECT inbox FETCH 3 body[] LOGOUT &nbsp; &nbsp; Ref. [1] TryHackMe, "Networking Core Protocols," [Online]. Available: https://tryhackme.com/r/room/networkingcoreprotocols. [Accessed: Jan. 23, 2025].]]></summary></entry><entry><title type="html">DHCP의 DORA</title><link href="https://neutrinox4b1.github.io/blog/2025/dhcp-dora/" rel="alternate" type="text/html" title="DHCP의 DORA"/><published>2025-01-23T05:42:23+00:00</published><updated>2025-01-23T05:42:23+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/dhcp-dora</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/dhcp-dora/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[DHCP는 DORA 절차를 가진다. Discover Discover는 로컬 서버를 찾기 위해 브로드캐스트를 보낸다. Offer Request Acknowledge &nbsp; &nbsp; user@TryHackMe$ tshark -r DHCP-G5000.pcap -n 1 0.000000 0.0.0.0 &rarr; 255.255.255.255 DHCP 342 DHCP Discover - Transaction ID 0xfb92d53f 2 0.013904 192.168.66.1 &rarr; 192.168.66.133 DHCP 376 DHCP Offer - Transaction ID 0xfb92d53f 3 4.115318 0.0.0.0 &rarr; 255.255.255.255 DHCP 342 DHCP Request - Transaction ID 0xfb92d53f 4 4.228117 192.168.66.1 &rarr; 192.168.66.133 DHCP 376 DHCP ACK - Transaction ID 0xfb92d53f &nbsp; 첫 번째 Discover과 세번째 Request에서 아직 DHCP 연결이 이루어지지 않았으므로 클라이언트는 MAC 주소만을 가지고 있고 IP주소는 0.0.0.0으로 브로드캐스트 주소 255.255.255.255에 패킷을 보낸다. 이는 링크 게층에서 브로드캐스트 MAC 주소 ff:ff:ff:ff:ff:ff 으로 사용된다. &nbsp; DHCP 프로세스가 끝나면, DHCP로부터 클라이언트는 다음을 받는다. 네트워크 리소스에 접근하기 위한 임대 IP 주소 로컬 네트워크 외부로 패킷을 라우팅하는 게이트웨이 도메인 이름을 확인하기 위한 DNS 서버 DHCP는 포트번호 67/UDP를 통해 수신하고 68/UDP로 송신한다. &nbsp; Ref. [1] TryHackMe, "Networking Essentials," [Online]. Available: https://tryhackme.com/r/room/networkingessentials. [Accessed: Jan. 23, 2025]. &nbsp;]]></summary></entry><entry><title type="html">Windows PowerShell 기본</title><link href="https://neutrinox4b1.github.io/blog/2025/windows-powershell/" rel="alternate" type="text/html" title="Windows PowerShell 기본"/><published>2025-01-23T05:36:58+00:00</published><updated>2025-01-23T05:36:58+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/windows-powershell-</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/windows-powershell/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[소개 https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.4 PowerShell은 명령줄 쉘, 스크립팅 언어 및 구성 관리 프레임워크로 구성된 크로스 플랫폼 자동화 솔루션이다. PowerShell은 command line 인터페이스와 .NET 프레임워크에 기반한 스크립팅 언어를 결합하였다. 텍스트 기반 Command Line 도구와 달리 객체지향적이므로 복잡한 데이터 유형을 처리하고 시스템 구성 요소와 보다 효과적으로 상호작용 할 수 있다. &nbsp; 역사 2000년대 초, cmd.exe 배치 파일과 같은 기존 도구는 복잡한 엔터프라이즈 환경 시스템을 자동화하고 관리하는데에 한계가 있었다. MS에서는 Windows 최신 API와 상호작용 할 수 있는 도구가 필요했다. MS 엔지니어인 Jeffry Snover는 Windows가 Unix와 달리, 구조화된 데이터와 API를 사용한다는 것을 깨달았다. Unix는 모든 것을 텍스트파일로 처리했다. 이러한 차이로, Unix 도구를 Windows로 이식하는 것이 비실용적이었다. Snover는 이에 스크립팅의 단순성과 .NET 프레임워크의 힘을 결합한 객체지향 방식을 개발하고자 했다. 2006년데 PowerShell이 출시되며 관리자는 객체를 조작하여 작업을 보다 효과적으로 자동화할 수 있고 Windows 시스템과 더욱 밀접하게 통합되었다. 2016년 MS에서는 Windows, macOS, Linux에서 실행되는 오픈 소스 및 크로스 플랫폼 버전인 PowerShell Core을 출시하기도 하였다. &nbsp; The Power of PowerShell 객체는 속성과 메서드가 있는 항목을 의미한다. 예를 들어, 객체 car는 속성 Color, Model, FuelLevel 을 가질 수 있고 메서드로는 Drive(), HonkHorn(), Refuel() 을 가질 수 있다. PowerShell에서 객체도 마찬가지로 데이터와 기능을 캡슐화하는 기본 단위로 정보를 관리하고 조작하기 쉽게 해준다. 객체는 파일명, 유저명, 크기 등을 속성을 포함할 수 있고 파일 복사나 프로세스 중지 같은 메서드를 수행할 수 있다. 기존 Command Shell에서 기본 명령은 텍스트 기반으로, 데이터를 일반 텍스트로 처리하고 출력하지만 PowerShell에서 cmdlet을 실행하면 속성과 메서드를 유지하는 객체를 반환한다. &nbsp; PowerShell 사용 powershell 해당 명령어를 사용하면 현재 작업디렉토리에 PS 가 표시된다. &nbsp; cmdlets cmdlets는 동사-명사 명명 규칙을 따른다. 이 구조는 cmdlet이 무엇을 하는지 이해하기 쉽도록 한다. 동사는 작업을 설명하고 명사는 작업이 수행되는 개체를 지정한다. 예를 들어 Get-Content는 파일의 내용을 검색하여 콘솔에 표시, Set-Location은 현재 작업 디렉토리를 변경(설정)한다. &nbsp; &nbsp; 기본 cmdlet Get-Command Get-Command는 현재 PowerShell 세션에서 사용할 수 있는 모든 cmdlet, 함수, alias 및 스크립트를 나열한다. -CommandType "Function" 이나 -Name "Remove*" 처럼 옵션을 추가할 수 있다. &nbsp; Get-Help Get-Help는 명령어 사용법을 배우는데 필요한 cmdlet이다. Get-Help &lt;cmdlet&gt; 와 같이 사용한다. linux의 man과 비슷하다. -examples 옵션은 몇가지 예시를 보여준다. &nbsp; Get-Alias Get-Alias는 별칭을 나열한다. &nbsp; &nbsp; 이래서 리눅스 명령어와 powershell이 유사한 명령어를 가지던 것이었구나 싶다. 주요 리눅스 명령어들이 cmdlet alias로 지정되어있다. &nbsp; &nbsp; Find-Module Find-Module은 온라인 저장소에서 cmdlet을 검색하는데에 사용할 수 있는 명령어이다. Find-Module -Name "PowerShell*&rdquo; 이렇게 사용할 수 있다. 설치는 Install-Module 명령어를 통해 설치할 수 있다. Install-Module -Name "PowerShellGet" &nbsp; 파일 시스템 탐색 및 파일 작업 Get-ChildItem Get-Childitem은 dir, ls와 유사하게 지정된 위치에 있는 파일과 디렉토리를 나열한다. &nbsp; Set-Location -Path 옵션을 통해 특정 디렉토리로 이동할 수 있다. cd와 유사함 &nbsp; &nbsp; New-Item New-Item은 item을 생성하는데에 사용할 수 있다. 아이템의 경로와 유형(파일 or 디렉토리)를 지정해주어야 한다. New-Item -Path ".\captain-wardrobe" -ItemType "Directory" &nbsp; &nbsp; Remove-Item 이는 cmd의 rmdir이나 del과 유사하며, -Path를 지정해주어야 한다. &nbsp; Copy-Item 이는 copy와 동일하며 -Path 와 -Destination 을 지정해야 한다. &nbsp; Get-Content 이는 cmd의 type 또는 리눅스의 cat과 유사하게 동작한다 지정한 -Path의 내용을 화면에 표시한다. &nbsp; &nbsp; 데이터 파이핑, 필터링 및 정렬 pipe 명령어는 PowerShell에서도 사용 가능하다. PowerShell에서는 텍스트만이 아니라 객체를 전달하기 때문에 더욱 강력한 기능을 가진다. 예를 들어, 디렉토리에 있는 파일 목록을 가져온 다음 크기별로 정렬하려면 Get-ChildItem | Sort-Object Length 을 사용할 수 있다. &nbsp; &nbsp; Where-Object Where-Object는 지정된 조건에 따라 객체를 필터링 하기 위해 사용할 수 있다. Get-ChildItem | Where-Object -Property "Extension" -eq ".txt" &nbsp; &nbsp; -eq 는 같다는 의미, -ne는 같지 않음, -gt는 ~보다 큼 -ge 는 크거나 같음, -lt는 작음 -le는 작거나 같음 Get-ChildItem | Where-Object -Property "Name" -like "ship*" -like 를 이용하여 지정된 패턴과 일치하는 속성으로 객체를 필터링할 수 있다. &nbsp; &nbsp; Select-Object &nbsp; &nbsp; Get-ChildItem | Select-Object Name, Length &nbsp; Name과 Length만 표시하도록 출력을 필터링한다. 그리고 Get-ChildItem | Sort-Object Length -Descending | Select-Object -First 1 &nbsp; 현재 폴더에서 가장 크기가 큰 파일을 선택하는 파이프라이닝 &nbsp; &nbsp; Select-String 이는 리눅스의 grep, 윈도우의 findstr과 유사하게 문서 내 특정 콘텐츠를 찾는데 사용된다. Select-String -Path ".\captain-hat.txt" -Pattern "hat" &nbsp; &nbsp; 이렇게 하면 captain-hat.txt에서 hat이라는 문자열이 있는 행을 찾을 수 있다. 해당 명령어는 regex를 지원한다. &nbsp; &nbsp; 시스템 및 네트워크 정보 Get-ComputerInfo Get-ComputerInfo 명령어는systeminfo와 유사하게 운영체제 정보, 하드웨어 사양, BIOS 세부 정보 등을 제공한다. systeminfo 보다 많은 정보를 제공한다고 한다. &nbsp; Get-LocalUser 이는 사용자 계정을 관리하고 머신의 보안 구성을 이해하는데 필수적이다. Get-LocalUser는 시스템의 모든 로컬 사용자 계정을 나열한다. 사용자 이름, 계정 상태, 설명을 표시한다. &nbsp; &nbsp; Get-NetIPConfiguration IP주소, DNS서버, 게이트웨이 구성을 포함하여 시스템의 네트워크 인터페이스에 대한 자세한 정보를 제공한다. &nbsp; &nbsp; Get-NetIPAddress 네트워크 인터페이스에 할당된 IP주소의 세부정보가 필요할때는 Get-NetIPAddress 명령어를 사용한다. 이는 현재 활성화되지 않은 IP 주소를 포함하여, 시스템의 모든 IP주소에 대한 세부 정보를 표시한다. &nbsp; &nbsp; 실시간 시스템 분석 Get-Process Get-Process는 CPU와 메모리 사용량을 포함하여 현재 실행중은 모든 프로세스에 대한 자세한 정보를 제공한다. &nbsp; &nbsp; Get-Service 실행중인 서비스, 중지되거나 일시중지된 서비스 정보를 나타낸다. &nbsp; &nbsp; Get-NetTCPConnection 현재 TCP 연결을 표시한다. 침해대응 및 멀웨어 분석 작업 중에 유용하다. 공격자가 제어하는 서버에 대한 백도어, 연결을 발견할 수 있기 때문임 &nbsp; Get-FileHash 파일 해시를 생성한다. -Path를 통해 파일을 지정한다. &nbsp; 스크립팅 Invoke-Command Invoke-Command는 원격 시스템에서 명령을 실행하는데 필수적이다. Invoke-Command -FilePath c:\scripts\test.ps1 -ComputerName Server01 와 같이 스크립트와 결합하여 원격 컴퓨터의 작업을 자동화 할 수 있고, Invoke-Command -ComputerName Server01 -Credential Domain01\User01 -ScriptBlock { Get-Culture } 처럼 원격 컴퓨터로 -ScriptBlock을 이용하여 명령어를 입력할 수 있다. &nbsp; &nbsp; Ref. [1] TryHackMe, "Windows PowerShell," [Online]. Available: https://tryhackme.com/r/room/windowspowershell. [Accessed: Jan. 23, 2025]. &nbsp;]]></summary></entry><entry><title type="html">Windows 도메인 네트워크 인증 프로토콜</title><link href="https://neutrinox4b1.github.io/blog/2025/windows/" rel="alternate" type="text/html" title="Windows 도메인 네트워크 인증 프로토콜"/><published>2025-01-18T16:47:05+00:00</published><updated>2025-01-18T16:47:05+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/windows----</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/windows/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Windows 도메인을 사용할 때 모든 자격증명은 Domain Controller(DC)에 저장된다. 사용자가 도메인 자격증명을 사용하여 서비스에 인증하려고 할 때마다, 서비스는 도메인 컨트롤러에 자격증명이 올바른지 확인하도록 요청한다. &nbsp; Windows 도메인에서 네트워크 인증에는 다음 두 가지 프로토콜을 사용할 수 있다. &nbsp; Kerberos &nbsp; &nbsp; Kerberos는 최신 버전 Windows에서 사용되는 인증 프로토콜로, 최신 도메인에서 디폴트로 설정되어 있다. Kerberos의 방식은 Needham-Schroeder (NS) 프로토콜에서 영감을 받았다. Needham-Schroeder protocol Needham-Schroeder 프로토콜은 신뢰된 서버를 사용하는 프로토콜 중 하나로 잘 알려져 있다. 1978년에 개발되었으며, 키 교환에서 매우 중요한 프로토콜이다. &nbsp; &nbsp; A는 서버 S에 A의 아이디, B의 아이디, $N_A$ 라는 A의 nonce값을 전송한다. 서버 S는 $K_{AS}$ 로 대칭키 암호화하여, $N_A$, B의 아이디, AB의 세션키 $K_{AB}$, 그리고 $K_{BS}$로 A의 아이디와 $K_{AB}$ 를 암호화 한 값을 전송한다. &nbsp; A는 $K_{AS}$를 통해 세션키 $K_{AB}$를 얻을 수 있고, $SKE_{K_{BS}}(K_{AB}, A)$ 는 그대로 전송한다. B는 $K_{BS}$를 통해 이를 복호화하여 $K_{AB}$와 A의 아이디를 확인할 수 있다. &nbsp; 이후, B는 A에게 세션키 $K_{AB}$를 잘 가지고있음을 확인하고자 $N_B$를 암호화하여 보내고 A는 $K_{AB}$로 $N_B-1$을 전송하여 서로 세션키를 확인할 수 있게 된다. &nbsp; 해당 Needham-Schroeder 프로토콜에서는 B의 입장에서 $K_{AB}$의 freshness가 보장되지 않는다는 문제가 존재한다. &nbsp; &nbsp; Kerberos 동작 과정 이에 Kerberos에서는 timestamp와 lifetime을 사용하여 이를 해결하였다. &nbsp; &nbsp; 사용자는 이름과 타임스탬프를 Key Distribution Center(KDC)로 보낸다. KDC는 Windows 도메인 네트워크에서 Domain Controller에 설치되는 서비스가 된다. &nbsp; &nbsp; KDC는 Ticket Granting Ticket(TGT)를 생성하여 사용자에게 보낸다. 이때 세션 키(TGS 세션키)도 함께 제공한다. TGT는 krbtgt 계정의 비밀번호 해시를 사용하여 암호화된다. TGT에는 유저 아이디, 세션키가 들어있다. &nbsp; &nbsp; 사용자가 네트워크 서비스에 연결하려고 할 때, TGT를 사용하여 KDC에 Ticket Granting Service(TGS)를 요청해야 한다. TGS를 요청하려면 TGT, Service Principal Name (SPN), 세션 키로 암호화된 사용자 이름, 타임 스탬프를 보내야 한다. &nbsp; SPN은 액세스하려는 서비스, 서버 이름을 나타낸다. 위 그림에서는 MSSQL 서비스, SRV 서버에 접근하려고 나타낸다. &nbsp; TGS를 요청하면 KDC는 서비스 세션 키, TGS를 보낸다. 이는 서비스 소유자 해시에서 파생된 키를 사용하여 암호화된다. TGS에는 서비스 세션 키가 들어있다. &nbsp; &nbsp; 이후, TGS를 원하는 서비스로 보내어 인증하고 연결을 설정한다. 서비스는 Owner Hash를 이용하여 TGS를 해독하고 서비스 세션 키를 검증한다. &nbsp; &nbsp; NetNTLM(NT LAN Manager) NetNTLM은 호환성을 위해 유지되는 레거시 인증 프로토콜이다. Challenge-response authentication 메커니즘을 사용하여 작동한다. &nbsp; 클라이언트가 액세스하고자 하는 서버에 인증 요청을 보낸다. 서버에서는 난수를 생성하여 클리어인트에게 Challenge로 전송한다. 클라이언트는 NTLM 비밀번호 해시를 Challenge와 결합하여 서버로 보낸다. 서버는 Domain Controller에 전달한다. DC에서는 전달 받은 Challenge와 알고 있는 NTLM 비밀번호 해시를 가지고 계산해보고, 전달 받은 Response와 비교한다. 인증 결과를 서버에 전송한다 서버는 클라이언트에 인증 결과를 전송한다. 보다 정확히는 다음과 같이 response를 구성한다. SC=8-byte server challenge, random CC=8-byte client challenge, random CC* = (X, time, CC2, domain name) v2-Hash = HMAC-MD5(NT-Hash, user name, domain name) LMv2=HMAC-MD5(v2-Hash, SC, CC) NTv2=HMAC-MD5(v2-Hash, SC, CC*) response=LMv2 | CC | NTv2 | CC* &nbsp; NT 해시는 Security Account Manager(SAM) 또는 Active Directory(AD)에 저장되어있으며, 위에서 언급한 NTLM 비밀번호 해시는 보다 쉬운 이해를 위하여 사용된 용어이다.]]></summary></entry><entry><title type="html">A memory Allocator (Doug Lea의 글) (dlmalloc)</title><link href="https://neutrinox4b1.github.io/blog/2025/a-memory-allocator-doug-lea-dlmalloc/" rel="alternate" type="text/html" title="A memory Allocator (Doug Lea의 글) (dlmalloc)"/><published>2025-01-05T15:48:14+00:00</published><updated>2025-01-05T15:48:14+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/a-memory-allocator-doug-lea--dlmalloc</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/a-memory-allocator-doug-lea-dlmalloc/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[https://gee.cs.oswego.edu/dl/html/malloc.html 오래된 글이지만 유용한 개념같아 번역하여 정리해둔다. 해당 내용은 매우 오래되었으며, malloc의 현재 버전에 대한 세부 정보를 반영하지 않음에 유의 (그래도 ptmalloc의 기본 알고리즘은 dlmalloc과 흡사하게 작동함) Introduction 메모리 할당자는 인프라 소프트웨어 엔지니어링에서 흥미로운 case study를 형성한다. 나(Doug Lea)는 1987년에 하나를 작성하기 시작했고, 이 할당자는 malloc(), free()의 구현, realloc()과 몇가지 보조 유틸리티 루틴을 제공한다. 할당자는 특정 이름을 받은 적은 없지만, 대부분의 사람들은 이를 Doug Lea&rsquo;s Malloc 또는 줄여서 dlmalloc이라고 부른다. 이 할당자에 대한 코드는 퍼블릭 도메인에 공개되었으며, 널리 사용되고 있는 것으로 보인다. 이 코드는 일부 Linux 버전에서 malloc의 기본 네이티브 버전으로 제공되며, 일반적으로 사용 가능한 여러 소프트웨어 패키지(네이티브 malloc을 재정의)에 컴파일되었으며, 내가 모르는 다른 많은 곳에서 사용되었다. &nbsp; 나는 동적 메모리 할당에 거의 전적으로 의존하는 C++ 프로그램을 작성한 후 할당자의 첫번째 버전을 작성하였다. 예상보다 훨씬 느리게 실행되거나 총 메모리 소비량이 훨씬 더 많다는 것을 알게 되었다. 이는 내가 실행중이던 시스템(주로 당시 최신 버전의 SunOs 및 BSD)의 메모리 할당자의 특성 때문이었다. 이를 해결하기 위해 처음에는 C++에서 다양한 클래스에 대해 operator new를 오버로딩하여 여러 특수 목적 할당자를 작성했다. 이 중 일부는 1989년 C++ 보고서에 실린 &ldquo;Some storage allocation techniques for container classes&ldquo;이라는 기사로 각색된 논문에서 설명되었다. &nbsp; 하지만, 나는 동적으로 할당되고 자주 사용되는 클래스마다 특수 할당기를 구축하는 것은 내가 당시 작성중이던 범용 프로그래밍 지원 클래스를 구축할 때 좋은 전략이 아님을 곧 깨달았다.(1986년 부터 1991년까지 나는 GNU C++ 라이브러리(libg++)의 주요 작성자였다.) 보다 넓은 해결책이 필요했는데, 이는 C++ 및 C의 일반적인 로드에서 충분히 성능이 좋은 할당기를 작성하는 것이었다. 이렇게 하면 프로그래머들이 매우 특별한 조건을 제외하고는 특수 목적의 할당기를 작성하려는 유혹을 느끼지 않을 것이다. &nbsp; 이 글에서는 이 할당기의 주요 설계 목표, 알고리즘, 구현 고려사항에 대한 설명을 제시한다. 보다 자세한 문서는 코드 배포본과 함께 제공된다. &nbsp; Goals 좋은 메모리 할당기는 다음과 같은 목표를 균형 있게 고려해야 한다. 호환성 극대화(Maximizing compatibility) 할당기는 다른 할당기와 플러그-호환성(plug-compatible)을 가져야하며, 특히 ANSI/POSIX 규격을 준수해야 한다. 이식성 극대화(Maximizing Portability) 시스템 종속적인 기능(e.g., system call)에 대한 의존성을 최소화하면서, 특정 시스템에만 제공되는 유용한 기능은 선택적으로 지원해야 한다. 정렬 및 주소지정 규칙과 같은 모든 알려진 시스템 제약 조건을 준수해야 한다 공간 최소화(Minimizing Space) 할당기는 공간 낭비를 최소화해야한다. 시스템에서 메모리를 가능한 적게 가져와야 하며, 메모리를 유지 관리할 때 프로그램이 사용하지 않는 청크의 단편화(fragmentation)을 최소화해야 한다. 시간 최소화(Minimizing Time) malloc(), free(), realloc() 루틴은 평균적인 경우 가능한 빨라야 한다 . 튜닝 가능성 극대화(Maximizing Tunability) 선택적 기능과 동작은 사용자가 정적(e.g., #define 등) 또는 동적(e.g., mallopt 와 같은 제어명령)으로 제어할 수 있어야 한다. 지역성 극대화(Maximizing Locallity) 일반적으로 함께 사용되는 메모리 청크를 서로 가까운 위치에 할당해야 한다. 이는 프로그램 실행 중 페이지 및 캐시 미스를 최소화하는데 도움이 된다. 오류 감지 극대화(Maximizing Error Detection) 일반적인 할당자가 Purify와 같은 일반적인 메모리 오류 테스트 도구로도 사용되기는 어렵지만, 할당자는 메모리 덮어쓰기, 다중 해제 등으로 발생하는 손상을 감지하는 수단을 제공해야 한다. 이상 현상 최소화(Minimizing Anomalies) 기본 설정으로 구성된 할당자는 동적 할당에 크게 의존하는 실제 워크로드(e.g., 윈도잉 툴킷, GUI 어플리케이션, 컴파일러, 인터프리터, 개발 도구, 네트워크 패킷 집중 프로그램, 그래픽 집중 패키지, 웹 브라우저, 문자열 처리 애플리케이션)에서 잘 동작해야 한다. &nbsp; 참고 Paul Wilson과 그의 동료들은 이러한 목표 중 일부를 더 자세히 논의하는 훌륭한 할당 기술 서베이 논문을 작성했다. 이 논문은 Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles, ``Dynamic Storage Allocation: A Survey and Critical Review'' in International Workshop on Memory Management, September 1995 이다. Winson et al. 이 논의한 바와 같이 어떠한 할당자에서도 공간 낭비(주로 단편화에 의한)를 최소화하는 것이 가장 중요한 목표여야 한다. 극단적인 예 가장 빠른 버전의 malloc() 중 하나는 시스템에서 사용할 수 있는 다음 연속 메모리 위치를 항상 할당하는 방식으로 구현된다. 이 경우, 가장 빠른 free()는 아무 작업도 하지 않는다. 하지만 이러한 구현은 거의 받아들여질 수 없다. 이는 사용하지 않는 공간을 절대 회수하지 않으므로, 프로그램이 메모리를 빠르게 소진하게 된다. 실제 사용되는 일부 할당자에서 특정 워크로드는 이와 비슷한 극단적인 낭비가 발생할 수 있다. Wilson이 지적한 바와 같이, 낭비는 금전적으로 측정할 수도 있다. 전 세계적으로 보면, 잘못된 할당 방식은 메모리 칩에서 수십억 달러의 손실을 초래할 수 있다. &nbsp; Trade-off 예시 시간과 공간 문제는 지배적인 요소이지만, Trade-off와 절충안의 조합은 거의 무한하다. 다음은 많은 사례 중 몇가지 예시이다: 최악의 정렬 요구 사항을 수용하는 것은 청크를 정렬하기 위해 할당자가 바이트를 건너뛰도록 강제하여 낭비를 증가시킨다. 동적 튜닝(e.g., 디버그 모드 설정)에 대한 대부분의 규정은 indirection 레벨을 추가하고 분기 수를 증가시켜 시간 효율성을 심각하게 저하시킬 수 있다. 오류를 잡기 위해 설계된 일부 규정은 적용 범위를 제한한다. 예를 들어 2.6.6 버전 이전에는 플랫폼에 관계없이 malloc이 내부적으로 할당 크기 인수를 부호있는 32비트 정수로 처리했으며, 0 이하의 인수를 요청크기 0으로 간주했다. (그러나 2.6.6 부터는 음수 인수가 POSIX 표준을 준수하기 위해 null 값을 반환한다) 다른 할당기의 특이점을 수용하여 플러그-호환성을 유지하려면 유연성과 성능이 감소할 수 있다. 가장 특이한 예로, 초기 Unix 할당기의 일부 버전은 이미 해제된 메모리를 realloc하는 것을 허용했다. 1993년까지는 호환성을 위해 이를 허용했지만, 이 기능이 제거되었을 때 아무도 불평하지 않았다. 소규모 프로그램의 시간/공간을 개선하는 일부 휴리스틱은 요즘 대부분의 시스템 로드를 지배하는 대규모 프로그램에서 시간/공간 특성을 용납할 수 없을 정도로 악화시킬 수 있다. 이와 같은 절충안 중 어떤 것도 완벽할 수 없다. 그러나 수년에 걸쳐 할당자는 대다수 사용자가 수용할 수 있는 Trade-off를 제공하도록 진화해왔다. &nbsp; 이 malloc의 진화를 계속해서 이끄는 주요 요인들은 다음과 같다: malloc 성능에 대한 다른 사람들의 실증적 연구 (위에서 언급한 Wilson 등의 논문과 그 논문이 인용한 다른 논문 포함). 이 논문들은 이 malloc 버전이 시간 및 공간 효율성 측면에서 가장 효율적인 메모리 할당기 중 하나로 순위가 매겨진다고 밝히고 있다. 그러나 각 논문은 약점이나 추가 개선 가능성을 드러낸다. 대상 워크로드의 변화 malloc 구현에 민감한 프로그램 종류의 특성은 지속적으로 변화한다. 대표적인 예로, X 및 기타 윈도잉 시스템의 메모리 특성이 점점 더 지배적이 되고 있다. 시스템 및 프로세서의 변화 전형적인 프로세서에서 코드를 최적화하려는 구현 세부사항 및 미세 조정이 시간이 지남에 따라 변화한다. 추가적으로, Linux와 Solaris와 같은 운영 체제는 자체적으로 진화하여 메모리 매핑을 시스템 수준 할당에 있어서 현명한 선택으로 만드는 경우가 있다. 사용자 및 기여자로부터의 제안, 경험 보고서, 코드 이 코드는 여러 정기적인 자원봉사 기여자들의 도움으로 발전해왔다. 최근의 변경 사항 대부분은 Linux에서 제공된 버전을 사용하는 사람들로부터 시작되었으며, 많은 부분이 Linux 버전을 위해 Wolfram Gloger(ptmalloc 제작자)에 의해 구현되었고, 이후 내가 통합하였다. Algorithms malloc 알고리즘의 두 가지 핵심 요소는 초기 버전 이후로 변하지 않았다: Boundary Tags (경계 태그) 메모리 청크에는 청크의 앞과 뒤에 크기를 정보를 포함한 필드가 있다. 이를 통해 두 가지 중요한 기능을 제공한다: 서로 인접한 사용되지 않은 청크를 하나의 더 큰 청크로 병합(coalescing) 할 수 있다.이는 사용 불가능한 작은 청크의 수를 최소화한다. 모든 청크는 알려진 청크를 기준으로 앞쪽(forwrad) 또는 뒤쪽(backward) 방향으로 순회할 수 있다. &nbsp; &nbsp; 초기 버전에는 경계 태그가 정확히 이 방식으로 구현되었다. 하지만 최신 버전에서는 프로그램에서 사용중인 청크에 대한 후방 필드(trailer fields)를 생략한다. 이는 소소한 트레이드 오프로, 활성 상태인 청크에서는 해당 필드를 절대 사용하지 않으므로 필요하지 않다. 이를 제거하면 오버헤드와 낭비를 줄일 수 있다. 하지만, 이러한 필드가 없으면 사용자가 필드를 덮어쓰는 실수를 감지하기 어려워져 오류 감지 기능이 약화된다. Binning (분류) 사용 가능한 청크는 크기별로 그룹화되어 빈(bin)에 저장된다. bin은 놀랍게도 많은 수(128개)의 고정 폭을 가지며, 대략 로그함수적 간격으로 크기가 배치된다. &nbsp; 512 바이트 이하 크기를 위한 빈은 각 크기마다 정확히 하나씩만 유지한다.(청크 크기는 8바이트 간격으로 나뉘어 있어, 8바이트 정렬을 간단히 보장한다.) 사용 가능한 청크를 검색할 때는 가장 작은 크기부터 시작하여, 가장 적합한 (best-fit) 순서로 처리된다. Wilson 등의 연구에 따르면, 다른 일반적인 접근 방식보다 실제 워크로드에서 단편화를 덜 유발한다. &nbsp; &nbsp; &nbsp; &nbsp; 1995년 이전 버전까지는 빈 내에서 청크가 정렬되지 않았기 때문에, best-fit 전략이 근사적으로만 적용되었다. 최신 버전에서는 대신 빈 내에서 청크를 크기 순서로 정렬하며, 크기가 동일한 경우 가장 오래된 것부터(first-in) 사용하는 규칙으로 정렬한다. (이는 약간의 시간이 추가로 소요되더라도 관찰된 문제를 피할 가치가 있다고 판단되어 변경되었다.) 따라서, 이 알고리즘의 일반적인 분류는 coalescing(병합) 가능한 best-fit 전략이다. 해제된 청크는 이웃한 청크와 병합되고, 크기 순서대로 검색되는 빈에서 관리된다. &nbsp; 이 접근 방식은 청크당 고정된 부가 작업 오버헤드를 초래한다. 크기 정보와 이진 링크를 각각의 사용 가능한 청크에 보유해야 하므로, 32비트 포인터를 사용하는 시스템에서는 최소 할당 가능 청크 크기가 16바이트이고, 64비트 포인터를 사용하는 시스템에서는 24바이트이다. 이러한 최소 크기는 대부분의 사람들이 선호하는 것보다 크며, 예를 들어 작은 연결 리스트 노드를 많이 할당하는 애플리케이션에서는 상당한 낭비를 초래할 수 있다. 그러나 16바이트 크기는 8바이트 정렬을 요구하고 malloc 부가 작업 오버헤드가 있는 시스템의 특징이다. &nbsp; 이 기본 알고리즘은 매우 빠르게 동작하도록 설계될 수 있다. 최적 크기를 찾기 위해 검색 메커니즘에 의존하더라도, 색인 기법(indexing techniques), 특수 사례 활용(exploitation of special cases), 세심한 코딩(careful coding)을 통해 평균적으로 몇십 개의 명령어만 필요하다(물론 이는 기계 및 할당 패턴에 따라 달라질 수 있다.). &nbsp; 경계 태그를 통한 병합(coalescing)과 이진화를 통한 최적 적합(best-fit)은 이 알고리즘의 주요 아이디어를 나타낸다. 하지만 추가적인 고려 사항들이 여러 휴리스틱 개선으로 이어지며 이는 다음을 포함한다: 지역성 유지(locality preservation) 미사용 영역 보존(wilderness preservation) 메모리 매핑(memory mapping) 캐싱(caching) &nbsp; 지역성 유지(Locality preservation) 프로그램에 의해 비슷한 시점에 할당된 청크는 유사한 참조 패턴과 공존 패턴을 가지는 경향이 있다. 지역성(locality)을 유지하면 페이지 폴트(page fault)와 캐시 미스(cache miss)를 최소화할 수 있으며, 이는 현대 프로세서에서 성능에 큰 영향을 미칠 수 있다. 만약 지역성만이 목표라면, 할당자는 연속적인 청크를 가능한 이전 청크에 가깝게 할당할 수 있다. 그러나 이 근접 적합(nearest-fit) 방식(주로 다음 적합(next-fit)으로 근사됨)은 매우 심각한 단편화를 초래할 수 있다. 현재 malloc 버전에서는 제한된 맥락에서만 다음 적합(next-fit)이 사용되며, 이는 지역성이 다른 목표와 가장 적게 충돌하는 경우에 유지하도록 설계되었다. 예를 들어, 정확히 원하는 크기의 청크가 없는 경우, 가장 최근에 분할된 공간을 사용(재분할)할 수 있을 만큼 크다면 이를 사용하고, 그렇지 않으면 최적 적합(best-fit)을 사용한다. 이러한 제한된 사용은 완벽히 사용 가능한 기존 청크가 할당되지 않는 경우를 방지하여 단편화를 제거한다. 또한, 이 형태의 다음 적합은 최적 적합 이진 검색보다 더 빠르므로 평균 malloc 속도를 높인다. &nbsp; 미사용 영역 보존(Wilderness preservation) 미사용 영역(wilderness) 청크는 시스템에서 할당된 최상위 주소를 경계로 하는 공간을 나타내며, Kiem-Phong Vo에 의해 명명되었다. 이 경계에 있으므로, 이는 sbrk(Unix에서 사용)를 통해 임의로 확장할 수 있는 유일한 청크이다. (단, 모든 메모리가 소진되어 sbrk가 실패하지 않는 한 가능하다.) 미사용 영역 청크를 처리하는 한 가지 방법은 다른 청크와 동일하게 다루는 것이다. (이 방법은 1994년까지 대부분의 malloc 버전에서 사용되었다.) 이는 구현을 단순화하고 속도를 높이지만, 신중하지 않으면 매우 나쁜 최악의 공간 특성을 초래할 수 있다. 예를 들어, 다른 사용 가능한 청크가 존재하는데도 미사용 영역 청크를 사용할 경우, 나중에 요청 시 방지할 수 있었던 sbrk를 초래할 가능성이 높아진다. 현재 사용되는 더 나은 전략은 미사용 영역 청크를 다른 청크보다 더 큰 것으로 취급하는 것이다. 이는 시스템 한계까지 확장 가능하므로 최적 우선(best-first) 검색에서 이를 가장 큰 것으로 간주한다. 결과적으로, 미사용 영역 청크는 다른 청크가 없을 때만 사용되며, 방지 가능한 단편화를 최소화한다. &nbsp; 메모리 매핑(Memory mapping) sbrk를 통해 일반적인 할당 영역을 관리하는 것 외에도, 대부분의 Unix 버전은 mmap과 같은 시스템 콜을 지원하여 프로그램에서 사용하기 위한 비연속 메모리 영역을 별도로 할당한다. 이는 malloc이 메모리 요청을 충족하기 위한 두 번째 옵션을 제공한다. mmap된 청크를 요청하고 반환하면 다운스트림 단편화를 줄일 수 있다. 이는 해제된 메모리 맵이 관리해야 할 구멍(hole)을 생성하지 않기 때문이다. 하지만 mmap과 관련된 제한 및 오버헤드로 인해 이는 매우 제한적인 상황에서만 유용하다. 예를 들어: 모든 현재 시스템에서 매핑된 영역은 페이지 정렬(page-aligned)이 필요하다. mmap과 mfree를 호출하는 것은 기존 메모리 청크를 분할하는 것보다 훨씬 느리다. &nbsp; 이러한 이유로 현재 malloc 버전은 다음 두 조건을 충족할 때만 mmap을 사용한다: 요청이 동적으로 조정 가능한 임계값 크기(현재 기본값 1MB)를 초과하는 경우 요청된 공간이 기존 영역에 없어서 sbrk를 통해 확보해야 하는 경우 &nbsp; 또한, 현재 malloc 버전은 메인 영역의 트리밍을 지원한다. 이는 사용되지 않는 공간을 시스템에 반환하여 메모리 매핑 효과 중 하나를 달성한다. 예를 들어, sbrk는 음수 인수를 사용하여 이 효과를 달성할 수 있다. 이러한 공간 반환은 운영 체제의 스왑 공간 요구 사항을 줄이고 메모리 매핑 테이블을 재사용할 수 있게 한다. 하지만 mmap과 마찬가지로 호출 자체가 비용이 많이 들기 때문에, 이는 후행 미사용 메모리가 조정 가능한 임계값을 초과할 경우에만 시도된다. &nbsp; 캐싱(Caching) 가장 기본적인 알고리즘에서, 해제된 청크는 즉시 이웃 청크들과 병합하여 가능한 가장 큰 미사용 청크를 형성한다. 마찬가지로, 청크는 명시적으로 요청될 때만(더 큰 청크를 나눔으로써) 생성된다. 청크를 분할하거나 병합하는 작업은 시간이 소요된다. 이 시간 오버헤드는 두 가지 캐싱 전략 중 하나 또는 둘 모두를 사용함으로써 줄일 수 있다. 지연 병합(Deferred Coalescing) 해제된 청크를 병합하지 않고 현재 크기로 그대로 두어 동일한 크기에 대한 다른 요청이 곧 들어올 가능성에 대비한다. 이를 통해 병합과 나중의 분할, 그리고 정확히 일치하지 않는 청크를 찾는데 드는 시간을 절약할 수 있다. 사전 할당(Preallocation) 새 청크를 하나씩 나누는 대신 여러개를 한 꺼번에 나눈다. 이는 일반적으로 한 번에 하나 씩 나누는 것보다 더 빠르다. malloc, free, realloc 등의 기본 데이터 구조는 언제든지 병합을 허용하므로, 관련된 캐싱 휴리스틱을 쉽게 적용할 수 있다. 캐싱의 효과는 분할, 병합, 검색 비용에 따라 달라진다. 또한, 캐싱과 병합 시점에 대한 정책에 따라 효과가 달라질 수 있다. 캐싱은 소수의 크기만 할당하고 해제하는 프로그램에서 좋은 선택이 될 수 있다. 예를 들어, 많은 트리 노드를 할당하고 해제하는 프로그램에서는 일부 노드를 캐싱하는 것이 효율적일 수 있다. 하지만 프로그램에 대한 사전 지식이 없는 경우, malloc은 작은 캐시된 청크를 병합하여 더 큰 요청을 충족시키는 것이 좋은지 아니면 다른 곳에서 가져와야 하는지를 판단하기 어렵다. 이전의 malloc 버전은 캐싱에 대해 적절한 추정을 하기 위해 몇 가지 검색 순서 휴리스틱(search-ordering huristics)을 사용했지만, 때로는 나쁜 최악의 사례 결과를 초래했다. 시간이 지남에 따라 이러한 휴리스틱은 실제 작업 부하에서 점점 덜 효과적인 것으로 나타났다. 이는 malloc에 크게 의존하는 실제 프로그램들이 점점 더 다양한 크기의 청크를 사용하는 경향이 있기 때문이다 . 예를 들어, C++ 프로그램에서는 클래스 수가 증가하는 경향과 관련이 있을 가능성이 있다. 서로 다른 클래스는 서로 다른 크기를 가지는 경향이 있다. 참고: 최신 malloc은 작은 청크(small chunks)만 캐싱한다. &nbsp; Lookasides Lookasides는 일부 애플리케이션에서 매우 바람직하지만, 이 할당자에서는 구현되지 않는 캐싱 유형으로, 매우 작은 청크를 위한 것이다. 위에서 언급했듯이, 기본 알고리즘은 최소 청크 크기를 강제하면, 이는 매우 작은 요청에 대해 매우 낭비적을 수 있다. 예를 들어 4바이트 포인터를 사용하는 시스템에서 연결 리스트는 두 개의 포인터만 포함하는 노드를 할당할 수 있으며, 이는 8바이트만 필요하다. 그러나 최소 청크 크기가 16바이트이기 때문에, 리스트 노드에만 할당하는 사용자 프로그램은 100%의 오버헤드를 겪게 된다. 이 문제를 해결하면서도 이식 가능한 정렬을 유지하려면 할당자가 어떤 오버헤드도 부과하지 않아야 한다. 이를 수행하기 위한 기술은 존재한다. 예를 들어, 청크가 더 큰 집합된 공간에 속하는지 여부를 주소 비교를 통해 확인할 수 있다. 그러나 이렇게 하는 것은 상당한 비용을 초래할 수 있으며, 실제로 이 할당자에서는 그 비용이 허용될 수 없는 수준이다. 청크가 주소로는 따로 추적되지 않으므로, 임의로 제한하지 않는다면 이러한 확인 과정은 메모리를 무작위로 검색하는 결과를 초래할 수 있다. 또한, 작은 청크를 병합할지 여부와 방법을 제어하는 하나 이상의 정책을 채택해야 한다. 이러한 문제와 제한은 프로그래머가 특수 목적의 메모리 관리 루틴(e.g., C++에서 operator new()를 오버로딩)을 작성해야 하는 매우 적은 종류의 상황 중 하나로 이어진다. 대규모이지만 대략적으로 알려진 숫자의 매우 작은 청크를 사용하는 프로그램은 매우 간단한 할당자를 구축하는 것이 유리할 수 있다. 예를 들어, 고정된 배열에서 청크를 할당하고 임베디드 free 리스트를 사용하며, 배열이 소진된 경우 malloc을 백업으로 사용하는 방식을 들 수 있다. 약간 더 유연하게는, 이는 GNU gcc와 libg++에서 제공되는 C 또는 C++ 버전의 obstack을 기반으로 할 수도 있다.]]></summary></entry><entry><title type="html">LD_PRELOAD란?</title><link href="https://neutrinox4b1.github.io/blog/2025/ld_preload/" rel="alternate" type="text/html" title="LD_PRELOAD란?"/><published>2025-01-04T11:57:42+00:00</published><updated>2025-01-04T11:57:42+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/ld_preload</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/ld_preload/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[LD_PRELOAD 유닉스 계열 운영체제에서 제공하는 환경 변수로, 동적 링커(dynamic linker)에 특정 라이브러리를 강제로 로드하도록 지시하는데에 사용된다. 이를 통해, 프로그램 기본 라이브러리 함수 동작을 재정의하여 후킹 등에 사용할 수 있다. &nbsp; &nbsp; &nbsp; How to use? 프로그램 실행 시 LD_PRELOAD=./your_lib.so ./target_program 환경 변수 등록 export LD_PRELOAD=./your_lib.so 비활성화하려면, unset LD_PRELOAD 명령어를 입력한다. gdb에서 사용 pwndbg&gt; set env LD_PRELOAD ./your_lib.so pwntools에서 사용 p=process('./target_program', env={'LD_PRELOAD':'./your_lib.so'}) &nbsp;]]></summary></entry><entry><title type="html">운영체제별 glibc 버전 확인 방법</title><link href="https://neutrinox4b1.github.io/blog/2025/glibc/" rel="alternate" type="text/html" title="운영체제별 glibc 버전 확인 방법"/><published>2025-01-02T16:58:03+00:00</published><updated>2025-01-02T16:58:03+00:00</updated><id>https://neutrinox4b1.github.io/blog/2025/-glibc---</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2025/glibc/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[pwnable 공부를 하다보면, 어떤 기법은 glibc ~~ 이상부터 통하지 않는다거나, 어느 기능이 사라졌다거나 하는 내용을 한번쯤은 마주쳤을 텐데 "그래서 그게 우분투 몇 버전이야?" 싶었던 적이 있을 것이다. &nbsp; glibc 버전 뿐만이 아니라 다양한 정보들을 알아보기 쉽게 정리해둔 사이트가 있다. &nbsp; DistroWatch Distrowatch는 리눅스 배포판과 관련된 정보를 제공하는 웹사이트로, 리눅스 및 기타 오픈소스 운영체제(OS)에 관심이 있는 사용자들에게 배포판의 최신 뉴스, 업데이트, 리뷰, 다운로드 링크 등을 제공한다. &nbsp; 다음 링크는 우분투에 관한 정보이다. https://distrowatch.com/table.php?distribution=ubuntu &nbsp; DistroWatch.com: Ubuntu Reader supplied reviews for Ubuntu Average rating7.6from 299 review(s) Version: 24.10Rating: 1Date: 2024-12-27Votes: 0 I think .. it's very bloated, hidden reporting packages, data collectors and senders using your bandwidth. pushing upgrade to pro-version distrowatch.com &nbsp; 해당 링크에서는 다음과 같이 테이블 형태로 glibc 버전을 확인할 수 있다. &nbsp; &nbsp; Ubuntu 24.04 LTS noble에서는 glibc 2.39 버전, 22.04 LTS jammy에서는 2.35 버전을 사용한다. Ubuntu LTS 버전들을 표시해보자면, 24.04 LTS noble: glibc 2.39 22.04 LTS jammy: glibc 2.35 20.04 LTS focal: glibc 2.31 18.04 LTS bionic: glibc 2.27 16.04 LTS xenial: glibc 2.23 glibc 버전 별 주요 변경점은 추후 작성할 예정이다.]]></summary></entry><entry><title type="html">GCC memory protection options (Updating)</title><link href="https://neutrinox4b1.github.io/blog/2024/gcc-memory-protection-options-updating/" rel="alternate" type="text/html" title="GCC memory protection options (Updating)"/><published>2024-10-13T13:18:20+00:00</published><updated>2024-10-13T13:18:20+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/gcc-memory-protection-options-updating</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/gcc-memory-protection-options-updating/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[이번 글에서는 GCC(GNU C Compiler)에서 메모리 보호기법을 enable, disable하는 옵션들에 대해서 정리한다. &nbsp; NX bit NX bit는 데이터 영역(e.g., stack)에서 실행 권한을 제거하는 보호기법이다. gcc -z execstack &nbsp; `-z execstack` 옵션을 통해 NX bit를 disable 할 수 있다. &nbsp; Stack Smashing Protector (Stack Canary) SSP는 SFP(Saved Frame Pointer) 전에 Canary라고 하는 랜덤 값을 삽입해두어 오버플로우를 탐지하는 보호기법이다. &nbsp; gcc -fno-stack-protector `-fno-stack-protector` 옵션을 통해 SSP를 disable 할 수 있다. &nbsp; 해당 보호기법을 명시적으로 적용하기 위해서는 gcc -fstack-protector `-fstack-protector` 옵션을 사용한다. &nbsp; &nbsp; ASLR(Address&nbsp;Space&nbsp;Layout&nbsp;Randomization) ASLR은 주소공간을 랜덤화하는 보호기법이다. sudo cat /proc/sys/kernel/randomize_va_space 명령어를 통해 `/proc/sys/kernel/randomize_va_space` 파일을 읽어들여 ASLR 적용 여부를 확인할 수 있다. &nbsp; `/proc/sys/kernel/randomize_va_space`가 0이면 ASLR 해제 1이면 stack과 library가 랜덤 2이면 stack, heap, library가 랜덤이다. &nbsp; sudo bash -c "echo 0 &gt; /proc/sys/kernel/randomize_va_space" 명령어를 통해 ASLR을 disable 할 수 있다. &nbsp; RELRO(RELocation Read Only) RELRO는 GOT overwrite 처럼 메모리가 변경되는 것을 방어한다. NO RELRO gcc -z norelro NO RELRO는 본 헤더, 코드 영역등을 제외한 거의 모든 부분에 read, write 권한을 준다. &nbsp; PARTIAL RELRO gcc -z relro PARTIAL RELRO는 .ctors, .dtors, .jcr, .dynamic 섹션이 ready-only 즉, 쓰기 권한이 없어진다. &nbsp; FULL RELRO gcc -z relro -z now FULL RELRO는 BSS영역을 제외한 모든 부분에서 write권한이 없다. &nbsp; PIE(Position Independent Executable) PIE는 모든 심볼 주소를 상대적으로 작성하고 base address를 랜덤화해서 함수들의 주소를 실행할 때마다 랜덤화하는 보호기법이다. &nbsp; gcc -no-pie `-no-pie` 옵션은 PIE를 disable 하는 옵션이다. &nbsp; gcc -fpie `-fpie`는 .text 영역을 랜덤화한다. &nbsp; gcc -fpie -pie `-fpie -pie`옵션은 PIE를 명식적으로 적용한다. &nbsp; &nbsp; &nbsp; &nbsp;]]></summary></entry><entry><title type="html">Windows에서 GCC를 사용한 C 언어 실행</title><link href="https://neutrinox4b1.github.io/blog/2024/windows-gcc-c/" rel="alternate" type="text/html" title="Windows에서 GCC를 사용한 C 언어 실행"/><published>2024-09-20T03:56:54+00:00</published><updated>2024-09-20T03:56:54+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/windows-gcc--c--</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/windows-gcc-c/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[나는 VS Code와 Git Bash조합으로 많이 사용하고 있는데, 추후 빠른 환경설정을 위해서 환경 설정을 한 번 정리하고 넘어가고자 한다.&nbsp;우선, Git Bash와 VSCode가 설치되었다는 가정 하에서&nbsp;&nbsp; VSCode 터미널 설정 Panel 위치 &nbsp;우선 터미널은 우측으로 두는 것이 작업하기 편리하므로 panel의 default location을 right로 둔다.&nbsp; Default terminal &nbsp;터미널 설정은 우측의 V 표시를 누르고 Select Default Profile -&gt;Git Bash를 지정한다. &nbsp; &nbsp;이제 GCC 설정이 남았다.&nbsp;&nbsp; MinGW를 활용한 GCC 설정 일반적으로 사용하는 MinGW가 아니라 MinGW-w64를 사용하고자 하며, gdb 사용 또한 보장되어야 할 것이다.&nbsp;MinGW와 MinGW-w64의 차이점 및 배경&nbsp;&nbsp;https://code.visualstudio.com/docs/cpp/config-mingw &nbsp; Get Started with C++ and MinGW-w64 in Visual Studio Code Configuring the C++ extension in Visual Studio Code to target g++ and gdb on a MinGW-w64 installation code.visualstudio.com 위 VSCode에서 작성한 문서를 따라 환경설정을 수행한다.&nbsp; MSYS2 및 MinGW-w64 설치 &nbsp;앞선 링크에서 설치 프로그램에 대한 링크를 통해 MSYS2를 설치한다.&nbsp;MSYS2가 설치되면 pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain &nbsp;을 입력한다. 여기에서 Enter를 눌러서 디폴트로 전체 설치를 수행한다.&nbsp; Y 입력&nbsp; 환경 변수 설정 설치가 완료되면 환경변수를 설정한다.&nbsp;&nbsp; &nbsp;Path에 새로운 환경 변수를 추가한다. &nbsp;디폴트로 설치했다면 다음 `C:\msys64\ucrt64\bin` 경로로 설정할 것이다.&nbsp; 설정 완료 및 테스트 &nbsp;이렇게 되면 Windows VSCode에서 자유롭게 gdb, gcc, g++ 사용이 가능하다.&nbsp;&nbsp;추가적으로, 맥이나 리눅스를 사용하다보면 쉘에서 open 이라는 명령어를 편하게 사용한다.윈도우 환경에서는 `explorer.exe` 로 사용하고, 이는 간단히`~/.bash_profile`에서 alias open=explorer.exe &nbsp;를 추가해주면 된다.]]></summary></entry><entry><title type="html">하이퍼바이저(Hypervisor)란 무엇인가? with 가상화 (Virutalization)</title><link href="https://neutrinox4b1.github.io/blog/2024/hypervisor-with-virutalization/" rel="alternate" type="text/html" title="하이퍼바이저(Hypervisor)란 무엇인가? with 가상화 (Virutalization)"/><published>2024-05-22T05:10:30+00:00</published><updated>2024-05-22T05:10:30+00:00</updated><id>https://neutrinox4b1.github.io/blog/2024/hypervisor--with--virutalization</id><content type="html" xml:base="https://neutrinox4b1.github.io/blog/2024/hypervisor-with-virutalization/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[하이퍼바이저란 무엇인가? 커널까지는 뭐하는 앤지 대충 알겠는데, 최신 OS에 대해 논하다보면 항상 Hypervisior라는 단어가 빠지지 않는다. 하이퍼바이저란 무엇일까? 1. Hypervisor 하이퍼바이저는 가상화를 구현하기 위해 기반이 되는 기술이고 가상화 계층을 구현해주는 소프트웨어를 말한다. &nbsp; 하드웨어 위에서 가상 머신을 생성하고 자원을 할당하고, 요청을 처리해주는 매니저의 역할을 수행한다. &nbsp; 그래서 가상 머신 매니저(Virtual Machine Manager)&nbsp; 또는 가상 머신 모니터(Virutual Machine Monitor, VMM) 라고 불리기도 한다. &nbsp; 그럼 이 하이퍼바이저가 우리가 사용하는 윈도우 아래에서 왜 작동하는가? 윈도우는 OS가 하나인데 하이퍼바이저를 두면 뭐가 좋아서? 싶다. &nbsp; 우선 하이퍼바이저의 종류부터 알아보자. &nbsp; &nbsp; 2. Hypervisor Type 하이퍼바이저는 Type 1과 Type 2로 나뉜다. &nbsp; 2.1. Type 1 (navtive, bare-metal) 타입 1 하이퍼바이저는 native 또는 Bare-metal 하이퍼바이저라고도 불린다. 이름 그대로의 의미로 하드웨어에서 직접 구동되어 게스트 OS를 관리한다. &nbsp; 바로 하드웨어 위에서 동작하므로 호스트 OS가 존재하지 않고, 게스트 OS는 하드웨어 위에 2번째 수준으로&nbsp; 실행되기 때문에 오버헤드가 적다는 장점을 가진다.&nbsp; &nbsp; 그러나 VM들에 대한 자체 관리 기능이 없어, VM&nbsp; 관리를 위한 컴퓨터나 콘솔이 별개로 필요하다. &nbsp; Type 1 하이퍼바이저는 IBM의 CP/CMS에서 시작(최초의 하이퍼바이저는 CP-40)되어 IBM의 z/VM으로 이어졌다. 최근에는 Xen, Ctrix의 XenServer Vmware의 ESX Server, L4 마이크로 커널, TANGO IBM의 POWER 하이퍼바이저 (PR/SM)&nbsp; 마이크로소프트 Hyper-V, Parallel Server 썬의 로지컬 도메인 하이퍼바이저 등이 있다. 또는 히타치의 Virtage 하이퍼바이저같이 플랫폼 펌웨어에 하이퍼바이저를 넣기도 하며, KVM은 하이퍼바이저에 완전한 리눅스 커널을 넣었는데 이것도 Type 1이다. &nbsp; Type 1 하이퍼바이저는 구현 방식에 따라 전가상화 (Full-Virtualization) =&gt; VMware ESX Server, MS Hyper-V 반가상화 (Half-Virtualization) =&gt; Citrix XenServer HAV (Hardware Asssisted Virtualization) 으로 나뉜다. &nbsp; 2.2. Type 2 (Hosted Hypervisor) Type 2 하이퍼바이저는 Hosted 하이퍼바이저라고도 불리며, Host OS를 갖는 하이퍼바이저를 말한다. &nbsp; 하드웨어에 이미 Host OS가 설치되어 있고, 하이퍼바이저는 OS 위에서 소프트웨어로서 동작한다. =&gt; 하드웨어로부터 3번째 수준으로 실행된다&nbsp; &nbsp; 기존 시스템 위에서 쉽게 사용 가능하다는 장점을 가진다.&nbsp; 그러나 오버헤드가 커지고 Host OS 문제가 전체 게스트 OS에 영향을 미칠 수 있다는 단점이 존재한다. &nbsp; 대표적인 종류로는 VMware Server VMware Workstation, Fusion QEMU 마이크로소프트 버추얼 PC와 버추얼 서버 Oracle의 Virutal Box SWsoft의 Paralles Workstation과 Parallels Desktop 등이 있다. 그냥 VM 소프트웨어들 같아보인다. &nbsp; 보통 개인 컴퓨터에서 VM을 사용하고자 할 때 일반적으로 사용하는 유형이다. &nbsp; Q1. Type 1 하이퍼바이저와 Type 2 하이퍼바이저를 동시에 사용 가능한가?Q2. BoB에서 VT-x 를 설정해야했는데 그거랑 무슨 관련이 있는가? 왜 그렇게 했어야만 하는가?Q3. Hyper-V는 Default 설정이 Enable인가? &nbsp; A1. GPT: 가능은 하지만 호환성 문제나 성능저하를 야기할 수 있다. &nbsp; &nbsp; A2. BoB에서 VT-x를 설정해야 하는건 Hyper-V를 꺼야 적용되는 옵션이었다. 우선, 에러명은 VMware Workstation does not support nested virtualization on this host. Module 'HV' power on failed. Failed to start the virtual machine 이고, 이 에러가 발생하기 이전에 "virtualized intel vt-x/ept is not supported on this platform" 이 언급된다. &nbsp; VT-x/EPT란 무엇인가? 이에 대해선 다음 글에 설명해봐야겠다. 우선 알고 넘어갈 것은 CPU에 내장된 하드웨어 가상화 기능이라는 것이다. 이 에러는 nested virtualization (중첩 가상화)와 관련이 있는데 이 에러가 뜨는 vm은 이 화면에서 Virtualize Intel VT-x/EPT or AMD-V/RVI 기능이 켜져있었다. https://www.clien.net/service/board/kin/5244830 &nbsp; Vmware 프로그램에서 옵션에 프로세스 부분에 "virtualize intel vt-x/ept or amd-v/rvi" 옵션은 무슨옵션인가 알려주실 고수분 계신가요 -.-a;; 갑자기 궁굼해서 ㅠㅠ www.clien.net &nbsp; 이 옵션을 켜는 이유는 nested VM을 지원하기 위함이며, 해당 VM이 이 옵션을 사용하던 이유는 KVM에서 커널 취약점을 분석하기 위해서 사용하던 VM이기 때문이다. &nbsp; 덧붙여서 &nbsp; Virtualize Intel VT-x/EPT or AMD-V/RVI: CPU가 가상화 기술을 지원할 때, 실행 모드를 Intel VT-x나 AMD-V/RVI로 실행하도록 VMware에 지시하는 옵션임 Virtualize CPU performance counters: 고급 디버깅이나 성능 모니터링을 수행하는 경우 이 옵션을 활성화하나, 일반적으로는 권장되지 않는다. Virtualize IOMMU (IO memory management unit): 메모리 및 DMA 리매핑 기술로 AMD와 Intel의 이더넷 가상화 기술이다. 가상 이더넷 장치를 추가할 때 하드웨어 가속을 해준다. 메인보드 지원 필요. A3. Hyper-V는 기본적으로 Disable 상태로 되어있다. &nbsp; &nbsp; 3. 가상화(Virtualization) 하이퍼바이저가 있고 VM이 있고 위에서 뭐 게스트 OS가 돌아가고 하는 것은 대충 알겠는데, &nbsp; 가상화는 왜 사용하는가? &nbsp; 하드웨어 성능이 빠르게 증가하던 1960, 70년대에 소프트웨어 발전 속도는 하드웨어 발전 속도를 따라가지 못하였고 소프트웨어 요구 성능보다 서버 성능이 좋다보니 자원이 남아 돌았다. &nbsp; 자원이 남아도는 비효율로 문제를 해결하기 위해서 가상화 개념이 도입되었다. &nbsp; 기존에는 하나의 OS, 1개의 태스크를 실행하기 위해서 각각의 물리적 서버가 필요했으나, &nbsp; 서버를 가상화한다면 더 효율적으로 쓸 수 있는 것임. &nbsp; 이렇게 하면 비용 절감: 마이그레이션이 쉬워 빈 서버를 재사용하거나 중지시켜서 유지관리를 수월하게 할 수도 있음 유연성: 동일 하드웨어에서 여러 운영체제 동시 실행 가능 민첩성: 한 물리서버에서 다른 물리 서버로 OS 이동 가능 내결함성: 물리적 서버에 장애가 있으면 관리 소프트웨어가 마이그레이션하여 신속한 조치 가능&nbsp; 이러한 장점을 가진다. &nbsp; 3.1. 가상화 작동 방식 및 종류 하이퍼바이저 소프트웨어를 설치하면 하나의 물리 시스템을 가상 머신으로 분할하여 구현할 수 있다. 하이퍼바이저 소프트웨어의 주 역할은 CPU, 메모리, 기타 물리적 리소스를 가상 인스턴스와 분리하는 가상화 계층을 생성(재차 언급임) &nbsp; &nbsp; https://www.redhat.com/ko/topics/virtualization/what-is-virtualization &nbsp; 3.1.1. 데이터 가상화 데이터 가상화는 여러 곳에 분산된 데이터를 단일 소스로 통합한다. 이를 통해 사용자 요구에 따라 데이터를 변환할 수 있는 처리 역량을 확보할 수 있고 적시에 애플리케이션 또는 사용자에게 필요한 데이터를 제공한다. &nbsp; &nbsp; 3.1.2. 데스크탑 가상화 운영체제 가상화와 혼동하기 쉽다. 중앙 관리자나 자동화 툴을 이용해서 시뮬레이션된 데스크탑 환경을 수백개의 물리 머신에 동시에 배포할 수 있도록 지원한다. &nbsp; 각 머신에서 물리적으로 설치, 구성, 업데이트 되는 전통적인 데스크탑 가상화와 달리, 관리자가 모든 데스크탑에서 설치, 구성, 업데이트를 수행 가능하다. &nbsp; &nbsp; 3.1.3. 서버 가상화 서버를 가상화해서 서버의 기능을 많이 수행할 수 있고, 서버 파티셔닝을 통해 구성요소로 여러 기능을 지원할 수 있다. &nbsp; 3.1.4. 운영체제 가상화 운영체제 가상화는 커널에서 이루어진다. 이렇게 하면 linux 환경과 windows 환경을 함께 실행할 수 있다. 기업에서는 운영체제를 push해서 다음과 같은 이점을 얻을 수 있다. 하드웨어 비용 감소: 컴퓨터에 고도의 OOTB(Out Of The Box) 기능이 필요하지 않음 보안 강화: 모든 가상 인스턴스를 모니터링하고 격리할 수 있음 시간 절약: 소프트웨어 업데이트같은 IT서비스의 소요시간이 감소됨 3.1.5. 네트워크 기능 가상화 (Network Fuctions Virtualization, NFV) 디렉터리 서비스, 파일 공유, IP 설정같은 네트워크 주요 기능을 분리하여 이러한 기능을 환경에 배포시킴 소프트웨어 기능이 속한 물리머신으로부터 분리하면 특정 기능을 새 네트워크에 패키징하고 이를 환경에 할당할 수 있음. =&gt;뭔말이래; &nbsp; 네트워크를 가상화하면 물리 구성 요소의 수가 감소한다. (스위치, 라우터, 서버, 케이블, 허브 등 여러 독립적인 네트워크를 생성하는데 필요하며, 특히 산업에서 일반적으로 사용되는 물리 구성 요소..) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]]></summary></entry></feed>
<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>archive | Jeongmin Lee</title> <meta name="author" content="Jeongmin Lee"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?01fe3e355b99c60a9492350784da1322"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://neutrinox4b1.github.io/archive/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Jeongmin </span>Lee</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item active"> <a class="nav-link" href="/archive/">archive<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <ul class="post-list"> <li> <h3> <a class="post-title" href="https://neutrinox4b1.tistory.com/52" target="_blank" rel="external nofollow noopener">A memory Allocator (Doug Lea의 글) (dlmalloc)</a> <svg width="2rem" height="2rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p></p> <p data-ke-size="size16"><a href="https://gee.cs.oswego.edu/dl/html/malloc.html" rel="external nofollow noopener" target="_blank">https://gee.cs.oswego.edu/dl/html/malloc.html</a></p> <p data-ke-size="size16">오래된 글이지만 유용한 개념같아 번역하여 정리해둔다.</p> <p data-ke-size="size16">해당 내용은 매우 오래되었으며, malloc의 현재 버전에 대한 세부 정보를 반영하지 않음에 유의 (그래도 ptmalloc의 기본 알고리즘은 dlmalloc과 흡사하게 작동함)</p> <h2 data-ke-size="size26">Introduction</h2> <hr data-ke-style="style1"> <p data-ke-size="size16">메모리 할당자는 인프라 소프트웨어 엔지니어링에서 흥미로운 case study를 형성한다. 나(Doug Lea)는 1987년에 하나를 작성하기 시작했고, 이 할당자는 malloc(), free()의 구현, realloc()과 몇가지 보조 유틸리티 루틴을 제공한다.</p> <p data-ke-size="size16">할당자는 특정 이름을 받은 적은 없지만, 대부분의 사람들은 이를 Doug Lea’s Malloc 또는 줄여서 <b><i>dlmalloc</i></b>이라고 부른다.</p> <p data-ke-size="size16">이 할당자에 대한 코드는 퍼블릭 도메인에 공개되었으며, 널리 사용되고 있는 것으로 보인다. 이 코드는 일부 Linux 버전에서 malloc의 기본 네이티브 버전으로 제공되며, 일반적으로 사용 가능한 여러 소프트웨어 패키지(네이티브 malloc을 재정의)에 컴파일되었으며, 내가 모르는 다른 많은 곳에서 사용되었다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">나는 동적 메모리 할당에 거의 전적으로 의존하는 C++ 프로그램을 작성한 후 할당자의 첫번째 버전을 작성하였다. 예상보다 훨씬 느리게 실행되거나 총 메모리 소비량이 훨씬 더 많다는 것을 알게 되었다. 이는 내가 실행중이던 시스템(주로 당시 최신 버전의 SunOs 및 BSD)의 메모리 할당자의 특성 때문이었다. 이를 해결하기 위해 처음에는 C++에서 다양한 클래스에 대해 <code>operator new</code>를 오버로딩하여 여러 특수 목적 할당자를 작성했다. 이 중 일부는 1989년 C++ 보고서에 실린 “Some storage allocation techniques for container classes“이라는 기사로 각색된 논문에서 설명되었다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">하지만, 나는 동적으로 할당되고 자주 사용되는 클래스마다 특수 할당기를 구축하는 것은 내가 당시 작성중이던 범용 프로그래밍 지원 클래스를 구축할 때 좋은 전략이 아님을 곧 깨달았다.(1986년 부터 1991년까지 나는 GNU C++ 라이브러리(libg++)의 주요 작성자였다.) 보다 넓은 해결책이 필요했는데, 이는 C++ 및 C의 일반적인 로드에서 충분히 성능이 좋은 할당기를 작성하는 것이었다. 이렇게 하면 프로그래머들이 매우 특별한 조건을 제외하고는 특수 목적의 할당기를 작성하려는 유혹을 느끼지 않을 것이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이 글에서는 이 할당기의 주요 설계 목표, 알고리즘, 구현 고려사항에 대한 설명을 제시한다. 보다 자세한 문서는 코드 배포본과 함께 제공된다.</p> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">Goals</h2> <hr data-ke-style="style1"> <p data-ke-size="size16">좋은 메모리 할당기는 다음과 같은 목표를 균형 있게 고려해야 한다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>호환성 극대화(Maximizing compatibility) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>할당기는 다른 할당기와 플러그-호환성(plug-compatible)을 가져야하며, 특히 ANSI/POSIX 규격을 준수해야 한다.</li> </ul> </li> <li>이식성 극대화(Maximizing Portability) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>시스템 종속적인 기능(e.g., system call)에 대한 의존성을 최소화하면서, 특정 시스템에만 제공되는 유용한 기능은 선택적으로 지원해야 한다.</li> <li>정렬 및 주소지정 규칙과 같은 모든 알려진 시스템 제약 조건을 준수해야 한다</li> </ul> </li> <li>공간 최소화(Minimizing Space) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>할당기는 공간 낭비를 최소화해야한다.</li> <li>시스템에서 메모리를 가능한 적게 가져와야 하며, 메모리를 유지 관리할 때 프로그램이 사용하지 않는 청크의 단편화(fragmentation)을 최소화해야 한다.</li> </ul> </li> <li>시간 최소화(Minimizing Time) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li> <code>malloc()</code>, <code>free()</code>, <code>realloc()</code> 루틴은 평균적인 경우 가능한 빨라야 한다 .</li> </ul> </li> <li>튜닝 가능성 극대화(Maximizing Tunability) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>선택적 기능과 동작은 사용자가 정적(e.g., <code>#define</code> 등) 또는 동적(e.g., <code>mallopt</code> 와 같은 제어명령)으로 제어할 수 있어야 한다.</li> </ul> </li> <li>지역성 극대화(Maximizing Locallity) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>일반적으로 함께 사용되는 메모리 청크를 서로 가까운 위치에 할당해야 한다. 이는 프로그램 실행 중 페이지 및 캐시 미스를 최소화하는데 도움이 된다.</li> </ul> </li> <li>오류 감지 극대화(Maximizing Error Detection) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>일반적인 할당자가 Purify와 같은 일반적인 메모리 오류 테스트 도구로도 사용되기는 어렵지만, 할당자는 메모리 덮어쓰기, 다중 해제 등으로 발생하는 손상을 감지하는 수단을 제공해야 한다.</li> </ul> </li> <li>이상 현상 최소화(Minimizing Anomalies) <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>기본 설정으로 구성된 할당자는 동적 할당에 크게 의존하는 실제 워크로드(e.g., 윈도잉 툴킷, GUI 어플리케이션, 컴파일러, 인터프리터, 개발 도구, 네트워크 패킷 집중 프로그램, 그래픽 집중 패키지, 웹 브라우저, 문자열 처리 애플리케이션)에서 잘 동작해야 한다.</li> </ul> </li> </ul> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">참고</h3> <p data-ke-size="size16">Paul Wilson과 그의 동료들은 이러한 목표 중 일부를 더 자세히 논의하는 훌륭한 할당 기술 서베이 논문을 작성했다. 이 논문은</p> <blockquote data-ke-style="style1"> <p data-ke-size="size16">Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles, ``Dynamic Storage Allocation: A Survey and Critical Review'' in <i>International Workshop on Memory Management</i>, September 1995</p> </blockquote> <p data-ke-size="size16">이다.</p> <p data-ke-size="size16">Winson et al. 이 논의한 바와 같이 어떠한 할당자에서도 공간 낭비(주로 단편화에 의한)를 최소화하는 것이 가장 중요한 목표여야 한다.</p> <h3 data-ke-size="size23">극단적인 예</h3> <p data-ke-size="size16">가장 빠른 버전의 <code>malloc()</code> 중 하나는 시스템에서 사용할 수 있는 다음 연속 메모리 위치를 항상 할당하는 방식으로 구현된다. 이 경우, 가장 빠른 <code>free()</code>는 아무 작업도 하지 않는다.</p> <p data-ke-size="size16">하지만 이러한 구현은 거의 받아들여질 수 없다. 이는 사용하지 않는 공간을 절대 회수하지 않으므로, 프로그램이 메모리를 빠르게 소진하게 된다. 실제 사용되는 일부 할당자에서 특정 워크로드는 이와 비슷한 극단적인 낭비가 발생할 수 있다. Wilson이 지적한 바와 같이, 낭비는 금전적으로 측정할 수도 있다.</p> <p data-ke-size="size16">전 세계적으로 보면, 잘못된 할당 방식은 메모리 칩에서 수십억 달러의 손실을 초래할 수 있다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Trade-off 예시</h3> <p data-ke-size="size16">시간과 공간 문제는 지배적인 요소이지만, Trade-off와 절충안의 조합은 거의 무한하다. 다음은 많은 사례 중 몇가지 예시이다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li> <b>최악의 정렬 요구 사항을 수용</b>하는 것은 청크를 정렬하기 위해 할당자가 바이트를 건너뛰도록 강제하여 낭비를 증가시킨다.</li> <li> <b>동적 튜닝(e.g., 디버그 모드 설정)에 대한 대부분의 규정</b>은 indirection 레벨을 추가하고 분기 수를 증가시켜 시간 효율성을 심각하게 저하시킬 수 있다.</li> <li> <b>오류를 잡기 위해 설계된 일부 규정</b>은 적용 범위를 제한한다. 예를 들어 2.6.6 버전 이전에는 플랫폼에 관계없이 malloc이 내부적으로 할당 크기 인수를 부호있는 32비트 정수로 처리했으며, 0 이하의 인수를 요청크기 0으로 간주했다. (그러나 2.6.6 부터는 음수 인수가 POSIX 표준을 준수하기 위해 null 값을 반환한다)</li> <li> <b>다른 할당기의 특이점을 수용</b>하여 플러그-호환성을 유지하려면 유연성과 성능이 감소할 수 있다. 가장 특이한 예로, 초기 Unix 할당기의 일부 버전은 이미 해제된 메모리를 realloc하는 것을 허용했다. 1993년까지는 호환성을 위해 이를 허용했지만, 이 기능이 제거되었을 때 아무도 불평하지 않았다.</li> <li> <b>소규모 프로그램의 시간/공간을 개선하는 일부 휴리스틱</b>은 요즘 대부분의 시스템 로드를 지배하는 대규모 프로그램에서 시간/공간 특성을 용납할 수 없을 정도로 악화시킬 수 있다.</li> </ul> <p data-ke-size="size16">이와 같은 절충안 중 어떤 것도 완벽할 수 없다. 그러나 수년에 걸쳐 할당자는 대다수 사용자가 수용할 수 있는 Trade-off를 제공하도록 진화해왔다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이 malloc의 진화를 계속해서 이끄는 주요 요인들은 다음과 같다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li> <b>malloc 성능에 대한 다른 사람들의 실증적 연구</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>(위에서 언급한 Wilson 등의 논문과 그 논문이 인용한 다른 논문 포함).</li> <li>이 논문들은 이 malloc 버전이 시간 및 공간 효율성 측면에서 가장 효율적인 메모리 할당기 중 하나로 순위가 매겨진다고 밝히고 있다. 그러나 각 논문은 약점이나 추가 개선 가능성을 드러낸다.</li> </ul> </li> <li> <b>대상 워크로드의 변화</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>malloc 구현에 민감한 프로그램 종류의 특성은 지속적으로 변화한다.</li> <li>대표적인 예로, X 및 기타 윈도잉 시스템의 메모리 특성이 점점 더 지배적이 되고 있다.</li> </ul> </li> <li> <b>시스템 및 프로세서의 변화</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>전형적인 프로세서에서 코드를 최적화하려는 구현 세부사항 및 미세 조정이 시간이 지남에 따라 변화한다.</li> <li>추가적으로, Linux와 Solaris와 같은 운영 체제는 자체적으로 진화하여 메모리 매핑을 시스템 수준 할당에 있어서 현명한 선택으로 만드는 경우가 있다.</li> </ul> </li> <li> <b>사용자 및 기여자로부터의 제안, 경험 보고서, 코드</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>이 코드는 여러 정기적인 자원봉사 기여자들의 도움으로 발전해왔다. 최근의 변경 사항 대부분은 Linux에서 제공된 버전을 사용하는 사람들로부터 시작되었으며, 많은 부분이 Linux 버전을 위해 Wolfram Gloger(ptmalloc 제작자)에 의해 구현되었고, 이후 내가 통합하였다.</li> </ul> </li> </ul> <h2 data-ke-size="size26">Algorithms</h2> <hr data-ke-style="style1"> <p data-ke-size="size16"><code>malloc</code> 알고리즘의 두 가지 핵심 요소는 초기 버전 이후로 변하지 않았다:</p> <h3 data-ke-size="size23">Boundary Tags (경계 태그)</h3> <p data-ke-size="size16">메모리 청크에는 청크의 앞과 뒤에 크기를 정보를 포함한 필드가 있다. 이를 통해 두 가지 중요한 기능을 제공한다:</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>서로 인접한 <b>사용되지 않은 청크를 하나의 더 큰 청크로 병합(coalescing)</b> 할 수 있다.<br>이는 사용 불가능한 작은 청크의 수를 최소화한다.</li> <li>모든 청크는 알려진 청크를 기준으로 앞쪽(forwrad) 또는 뒤쪽(backward) 방향으로 순회할 수 있다.</li> </ol> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="522" data-origin-height="388"><span data-url="https://blog.kakaocdn.net/dn/XbKIM/btsLEJdEvLO/UDje4NNKnkhDuKH24UnjIk/img.png" data-phocus="https://blog.kakaocdn.net/dn/XbKIM/btsLEJdEvLO/UDje4NNKnkhDuKH24UnjIk/img.png"><img src="https://blog.kakaocdn.net/dn/XbKIM/btsLEJdEvLO/UDje4NNKnkhDuKH24UnjIk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXbKIM%2FbtsLEJdEvLO%2FUDje4NNKnkhDuKH24UnjIk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="522" height="388" data-origin-width="522" data-origin-height="388"></span></figure> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">초기 버전에는 경계 태그가 정확히 이 방식으로 구현되었다. 하지만 최신 버전에서는 <b>프로그램에서 사용중인 청크에 대한 후방 필드(trailer fields)</b>를 생략한다.</p> <p data-ke-size="size16">이는 소소한 트레이드 오프로, 활성 상태인 청크에서는 해당 필드를 절대 사용하지 않으므로 필요하지 않다. 이를 제거하면 오버헤드와 낭비를 줄일 수 있다.</p> <p data-ke-size="size16">하지만, 이러한 필드가 없으면 사용자가 필드를 덮어쓰는 실수를 감지하기 어려워져 오류 감지 기능이 약화된다.</p> <h3 data-ke-size="size23">Binning (분류)</h3> <p data-ke-size="size16">사용 가능한 청크는 크기별로 그룹화되어 빈(bin)에 저장된다.</p> <p data-ke-size="size16">bin은 놀랍게도 많은 수(128개)의 고정 폭을 가지며, <b>대략 로그함수적 간격으로</b> 크기가 배치된다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">512 바이트 이하 크기를 위한 빈은 각 크기마다 정확히 하나씩만 유지한다.(청크 크기는 8바이트 간격으로 나뉘어 있어, 8바이트 정렬을 간단히 보장한다.)</p> <p data-ke-size="size16">사용 가능한 청크를 검색할 때는 <b>가장 작은 크기부터 시작하여, 가장 적합한 (best-fit) 순서로 처리</b>된다. Wilson 등의 연구에 따르면, 다른 일반적인 접근 방식보다 실제 워크로드에서 단편화를 덜 유발한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="493" data-origin-height="318"><span data-url="https://blog.kakaocdn.net/dn/PCAcK/btsLCs5szwy/49jSwIDM9XRQPuToa7tzdK/img.png" data-phocus="https://blog.kakaocdn.net/dn/PCAcK/btsLCs5szwy/49jSwIDM9XRQPuToa7tzdK/img.png"><img src="https://blog.kakaocdn.net/dn/PCAcK/btsLCs5szwy/49jSwIDM9XRQPuToa7tzdK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPCAcK%2FbtsLCs5szwy%2F49jSwIDM9XRQPuToa7tzdK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="493" height="318" data-origin-width="493" data-origin-height="318"></span></figure> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">1995년 이전 버전까지는 빈 내에서 청크가 정렬되지 않았기 때문에, best-fit 전략이 근사적으로만 적용되었다.</p> <p data-ke-size="size16">최신 버전에서는 대신 빈 내에서 청크를 크기 순서로 정렬하며, 크기가 동일한 경우 가장 오래된 것부터(first-in) 사용하는 규칙으로 정렬한다. (이는 약간의 시간이 추가로 소요되더라도 관찰된 문제를 피할 가치가 있다고 판단되어 변경되었다.)</p> <p data-ke-size="size16">따라서, 이 알고리즘의 일반적인 분류는 <b>coalescing(병합) 가능한 best-fit 전략</b>이다. 해제된 청크는 이웃한 청크와 병합되고, 크기 순서대로 검색되는 빈에서 관리된다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이 접근 방식은 청크당 고정된 부가 작업 오버헤드를 초래한다. 크기 정보와 이진 링크를 각각의 사용 가능한 청크에 보유해야 하므로, 32비트 포인터를 사용하는 시스템에서는 최소 할당 가능 청크 크기가 16바이트이고, 64비트 포인터를 사용하는 시스템에서는 24바이트이다. 이러한 최소 크기는 대부분의 사람들이 선호하는 것보다 크며, 예를 들어 작은 연결 리스트 노드를 많이 할당하는 애플리케이션에서는 상당한 낭비를 초래할 수 있다. 그러나 16바이트 크기는 8바이트 정렬을 요구하고 malloc 부가 작업 오버헤드가 있는 시스템의 특징이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이 기본 알고리즘은 매우 빠르게 동작하도록 설계될 수 있다. 최적 크기를 찾기 위해 검색 메커니즘에 의존하더라도, 색인 기법(indexing techniques), 특수 사례 활용(exploitation of special cases), 세심한 코딩(careful coding)을 통해 평균적으로 몇십 개의 명령어만 필요하다(물론 이는 기계 및 할당 패턴에 따라 달라질 수 있다.).</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">경계 태그를 통한 병합(coalescing)과 이진화를 통한 최적 적합(best-fit)은 이 알고리즘의 주요 아이디어를 나타낸다. 하지만 추가적인 고려 사항들이 여러 휴리스틱 개선으로 이어지며 이는 다음을 포함한다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>지역성 유지(locality preservation)</li> <li>미사용 영역 보존(wilderness preservation)</li> <li>메모리 매핑(memory mapping)</li> <li>캐싱(caching)</li> </ul> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">지역성 유지(Locality preservation)</h3> <p data-ke-size="size16">프로그램에 의해 비슷한 시점에 할당된 청크는 유사한 참조 패턴과 공존 패턴을 가지는 경향이 있다. 지역성(locality)을 유지하면 페이지 폴트(page fault)와 캐시 미스(cache miss)를 최소화할 수 있으며, 이는 현대 프로세서에서 성능에 큰 영향을 미칠 수 있다. 만약 지역성만이 목표라면, 할당자는 연속적인 청크를 가능한 이전 청크에 가깝게 할당할 수 있다. 그러나 이 <b>근접 적합(nearest-fit)</b> 방식(주로 다음 적합(next-fit)으로 근사됨)은 매우 심각한 단편화를 초래할 수 있다.</p> <p data-ke-size="size16">현재 malloc 버전에서는 제한된 맥락에서만 <b>다음 적합(next-fit)</b>이 사용되며, 이는 지역성이 다른 목표와 가장 적게 충돌하는 경우에 유지하도록 설계되었다. 예를 들어, 정확히 원하는 크기의 청크가 없는 경우, 가장 최근에 분할된 공간을 사용(재분할)할 수 있을 만큼 크다면 이를 사용하고, 그렇지 않으면 <b>최적 적합(best-fit)</b>을 사용한다. 이러한 제한된 사용은 완벽히 사용 가능한 기존 청크가 할당되지 않는 경우를 방지하여 단편화를 제거한다. 또한, 이 형태의 다음 적합은 최적 적합 이진 검색보다 더 빠르므로 평균 malloc 속도를 높인다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">미사용 영역 보존(Wilderness preservation)</h3> <p data-ke-size="size16">미사용 영역(wilderness) 청크는 시스템에서 할당된 최상위 주소를 경계로 하는 공간을 나타내며, Kiem-Phong Vo에 의해 명명되었다. 이 경계에 있으므로, 이는 <b>sbrk(Unix에서 사용)</b>를 통해 임의로 확장할 수 있는 유일한 청크이다. (단, 모든 메모리가 소진되어 sbrk가 실패하지 않는 한 가능하다.)</p> <p data-ke-size="size16">미사용 영역 청크를 처리하는 한 가지 방법은 다른 청크와 동일하게 다루는 것이다. (이 방법은 1994년까지 대부분의 malloc 버전에서 사용되었다.) 이는 구현을 단순화하고 속도를 높이지만, 신중하지 않으면 매우 나쁜 최악의 공간 특성을 초래할 수 있다. 예를 들어, 다른 사용 가능한 청크가 존재하는데도 미사용 영역 청크를 사용할 경우, 나중에 요청 시 방지할 수 있었던 sbrk를 초래할 가능성이 높아진다.</p> <p data-ke-size="size16">현재 사용되는 더 나은 전략은 미사용 영역 청크를 다른 청크보다 <b>더 큰 것으로 취급</b>하는 것이다. 이는 시스템 한계까지 확장 가능하므로 최적 우선(best-first) 검색에서 이를 가장 큰 것으로 간주한다. 결과적으로, 미사용 영역 청크는 다른 청크가 없을 때만 사용되며, 방지 가능한 단편화를 최소화한다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">메모리 매핑(Memory mapping)</h3> <p data-ke-size="size16">sbrk를 통해 일반적인 할당 영역을 관리하는 것 외에도, 대부분의 Unix 버전은 <b>mmap</b>과 같은 시스템 콜을 지원하여 프로그램에서 사용하기 위한 비연속 메모리 영역을 별도로 할당한다. 이는 malloc이 메모리 요청을 충족하기 위한 두 번째 옵션을 제공한다.</p> <p data-ke-size="size16">mmap된 청크를 요청하고 반환하면 다운스트림 단편화를 줄일 수 있다. 이는 해제된 메모리 맵이 관리해야 할 구멍(hole)을 생성하지 않기 때문이다. 하지만 mmap과 관련된 제한 및 오버헤드로 인해 이는 매우 제한적인 상황에서만 유용하다. 예를 들어:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>모든 현재 시스템에서 매핑된 영역은 페이지 정렬(page-aligned)이 필요하다.</li> <li>mmap과 mfree를 호출하는 것은 기존 메모리 청크를 분할하는 것보다 훨씬 느리다.</li> </ul> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이러한 이유로 현재 malloc 버전은 다음 두 조건을 충족할 때만 mmap을 사용한다:</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>요청이 <b>동적으로 조정 가능한 임계값 크기(현재 기본값 1MB)를 초과</b>하는 경우</li> <li>요청된 공간이 기존 영역에 없어서 sbrk를 통해 확보해야 하는 경우</li> </ol> <p data-ke-size="size16"> </p> <p data-ke-size="size16">또한, 현재 malloc 버전은 메인 영역의 트리밍을 지원한다. 이는 사용되지 않는 공간을 시스템에 반환하여 메모리 매핑 효과 중 하나를 달성한다. 예를 들어, sbrk는 음수 인수를 사용하여 이 효과를 달성할 수 있다. 이러한 공간 반환은 운영 체제의 스왑 공간 요구 사항을 줄이고 메모리 매핑 테이블을 재사용할 수 있게 한다. 하지만 mmap과 마찬가지로 호출 자체가 비용이 많이 들기 때문에, 이는 <b>후행 미사용 메모리가 조정 가능한 임계값을 초과</b>할 경우에만 시도된다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">캐싱(Caching)</h3> <p data-ke-size="size16">가장 기본적인 알고리즘에서, 해제된 청크는 즉시 이웃 청크들과 병합하여 가능한 가장 큰 미사용 청크를 형성한다. 마찬가지로, 청크는 명시적으로 요청될 때만(더 큰 청크를 나눔으로써) 생성된다.</p> <p data-ke-size="size16">청크를 분할하거나 병합하는 작업은 시간이 소요된다. 이 시간 오버헤드는 두 가지 캐싱 전략 중 하나 또는 둘 모두를 사용함으로써 줄일 수 있다.</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li> <b>지연 병합(Deferred Coalescing)</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>해제된 청크를 병합하지 않고 현재 크기로 그대로 두어 동일한 크기에 대한 다른 요청이 곧 들어올 가능성에 대비한다. 이를 통해 병합과 나중의 분할, 그리고 정확히 일치하지 않는 청크를 찾는데 드는 시간을 절약할 수 있다.</li> </ul> </li> <li> <b>사전 할당(Preallocation)</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>새 청크를 하나씩 나누는 대신 여러개를 한 꺼번에 나눈다. 이는 일반적으로 한 번에 하나 씩 나누는 것보다 더 빠르다.</li> </ul> </li> </ol> <p data-ke-size="size16">malloc, free, realloc 등의 기본 데이터 구조는 언제든지 병합을 허용하므로, 관련된 캐싱 휴리스틱을 쉽게 적용할 수 있다.</p> <p data-ke-size="size16">캐싱의 효과는 <b>분할, 병합, 검색 비용</b>에 따라 달라진다. 또한, 캐싱과 병합 시점에 대한 정책에 따라 효과가 달라질 수 있다.</p> <p data-ke-size="size16">캐싱은 <b>소수의 크기만 할당하고 해제하는 프로그램</b>에서 좋은 선택이 될 수 있다. 예를 들어, 많은 트리 노드를 할당하고 해제하는 프로그램에서는 일부 노드를 캐싱하는 것이 효율적일 수 있다. 하지만 프로그램에 대한 사전 지식이 없는 경우, malloc은 작은 캐시된 청크를 병합하여 더 큰 요청을 충족시키는 것이 좋은지 아니면 다른 곳에서 가져와야 하는지를 판단하기 어렵다.</p> <p data-ke-size="size16">이전의 malloc 버전은 캐싱에 대해 적절한 추정을 하기 위해 몇 가지 <b>검색 순서 휴리스틱(search-ordering huristics)</b>을 사용했지만, 때로는 나쁜 최악의 사례 결과를 초래했다. 시간이 지남에 따라 이러한 휴리스틱은 실제 작업 부하에서 점점 덜 효과적인 것으로 나타났다. 이는 malloc에 크게 의존하는 실제 프로그램들이 점점 더 다양한 크기의 청크를 사용하는 경향이 있기 때문이다 .</p> <p data-ke-size="size16">예를 들어, C++ 프로그램에서는 클래스 수가 증가하는 경향과 관련이 있을 가능성이 있다. 서로 다른 클래스는 서로 다른 크기를 가지는 경향이 있다.</p> <p data-ke-size="size16"><b>참고: 최신 malloc은 작은 청크(small chunks)만 캐싱한다.</b></p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">Lookasides</h4> <p data-ke-size="size16">Lookasides는 일부 애플리케이션에서 매우 바람직하지만, 이 할당자에서는 구현되지 않는 캐싱 유형으로, 매우 작은 청크를 위한 것이다. 위에서 언급했듯이, 기본 알고리즘은 최소 청크 크기를 강제하면, 이는 매우 작은 요청에 대해 매우 낭비적을 수 있다. 예를 들어 4바이트 포인터를 사용하는 시스템에서 연결 리스트는 두 개의 포인터만 포함하는 노드를 할당할 수 있으며, 이는 8바이트만 필요하다. 그러나 최소 청크 크기가 16바이트이기 때문에, 리스트 노드에만 할당하는 사용자 프로그램은 100%의 오버헤드를 겪게 된다.</p> <p data-ke-size="size16">이 문제를 해결하면서도 이식 가능한 정렬을 유지하려면 할당자가 어떤 오버헤드도 부과하지 않아야 한다. 이를 수행하기 위한 기술은 존재한다. 예를 들어, 청크가 더 큰 집합된 공간에 속하는지 여부를 주소 비교를 통해 확인할 수 있다. 그러나 이렇게 하는 것은 상당한 비용을 초래할 수 있으며, 실제로 이 할당자에서는 그 비용이 허용될 수 없는 수준이다. 청크가 주소로는 따로 추적되지 않으므로, 임의로 제한하지 않는다면 이러한 확인 과정은 메모리를 무작위로 검색하는 결과를 초래할 수 있다. 또한, 작은 청크를 병합할지 여부와 방법을 제어하는 하나 이상의 정책을 채택해야 한다.</p> <p data-ke-size="size16">이러한 문제와 제한은 프로그래머가 특수 목적의 메모리 관리 루틴(e.g., C++에서 operator new()를 오버로딩)을 작성해야 하는 매우 적은 종류의 상황 중 하나로 이어진다. 대규모이지만 대략적으로 알려진 숫자의 매우 작은 청크를 사용하는 프로그램은 매우 간단한 할당자를 구축하는 것이 유리할 수 있다. 예를 들어, 고정된 배열에서 청크를 할당하고 임베디드 free 리스트를 사용하며, 배열이 소진된 경우 malloc을 백업으로 사용하는 방식을 들 수 있다. 약간 더 유연하게는, 이는 GNU gcc와 libg++에서 제공되는 C 또는 C++ 버전의 obstack을 기반으로 할 수도 있다.</p> <p class="post-meta"> 1 min read   ·   January 5, 2025   ·   tistory.com </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a> </p> </li> <li> <h3> <a class="post-title" href="https://neutrinox4b1.tistory.com/51" target="_blank" rel="external nofollow noopener">LD_PRELOAD란?</a> <svg width="2rem" height="2rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p></p> <h2 data-ke-size="size26">LD_PRELOAD</h2> <hr data-ke-style="style1"> <p data-ke-size="size16">유닉스 계열 운영체제에서 제공하는 환경 변수로, 동적 링커(dynamic linker)에 특정 라이브러리를 강제로 로드하도록 지시하는데에 사용된다.</p> <p data-ke-size="size16">이를 통해, 프로그램 기본 라이브러리 함수 동작을 재정의하여 후킹 등에 사용할 수 있다.</p> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="2294" data-origin-height="1652"><span data-url="https://blog.kakaocdn.net/dn/ndyOS/btsLDunYrQU/g0NlzzKqJMQdzcdWEfqf31/img.png" data-phocus="https://blog.kakaocdn.net/dn/ndyOS/btsLDunYrQU/g0NlzzKqJMQdzcdWEfqf31/img.png"><img src="https://blog.kakaocdn.net/dn/ndyOS/btsLDunYrQU/g0NlzzKqJMQdzcdWEfqf31/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FndyOS%2FbtsLDunYrQU%2Fg0NlzzKqJMQdzcdWEfqf31%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="660" height="475" data-origin-width="2294" data-origin-height="1652"></span></figure> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">How to use?</h2> <hr data-ke-style="style1"> <h3 data-ke-size="size23">프로그램 실행 시</h3> <pre class="bash" data-ke-language="bash"><code>LD_PRELOAD=./your_lib.so ./target_program</code></pre> <h3 data-ke-size="size23">환경 변수 등록</h3> <pre class="bash" data-ke-language="bash"><code>export LD_PRELOAD=./your_lib.so</code></pre> <p data-ke-size="size16">비활성화하려면, <code>unset LD_PRELOAD</code> 명령어를 입력한다.</p> <h3 data-ke-size="size23">gdb에서 사용</h3> <pre class="bash" data-ke-language="bash"><code>pwndbg&gt; set env LD_PRELOAD ./your_lib.so</code></pre> <h3 data-ke-size="size23">pwntools에서 사용</h3> <pre class="bash" data-ke-language="bash"><code>p = process('./target_program', env={'LD_PRELOAD':'./your_lib.so'})</code></pre> <p data-ke-size="size16"> </p> <p class="post-meta"> 1 min read   ·   January 4, 2025   ·   tistory.com </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a> </p> </li> <li> <h3> <a class="post-title" href="https://neutrinox4b1.tistory.com/46" target="_blank" rel="external nofollow noopener">운영체제별 glibc 버전 확인 방법</a> <svg width="2rem" height="2rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p></p> <p data-ke-size="size16">pwnable 공부를 하다보면, 어떤 기법은 glibc ~~ 이상부터 통하지 않는다거나, 어느 기능이 사라졌다거나 하는 내용을 한번쯤은 마주쳤을 텐데 "그래서 그게 우분투 몇 버전이야?" 싶었던 적이 있을 것이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">glibc 버전 뿐만이 아니라 다양한 정보들을 알아보기 쉽게 정리해둔 사이트가 있다.</p> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">DistroWatch</h2> <hr data-ke-style="style1"> <p data-ke-size="size16"><a href="https://distrowatch.com/" target="_blank" rel="noopener"><b>Distrowatch</b></a>는 리눅스 배포판과 관련된 정보를 제공하는 웹사이트로, 리눅스 및 기타 오픈소스 운영체제(OS)에 관심이 있는 사용자들에게 배포판의 최신 뉴스, 업데이트, 리뷰, 다운로드 링크 등을 제공한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">다음 링크는 우분투에 관한 정보이다.</p> <p data-ke-size="size16"><a href="https://distrowatch.com/table.php?distribution=ubuntu" rel="external nofollow noopener" target="_blank">https://distrowatch.com/table.php?distribution=ubuntu</a></p> <figure id="og_1735837013597" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="DistroWatch.com: Ubuntu" data-og-description="Reader supplied reviews for Ubuntu Average rating7.6from 299 review(s) Version: 24.10Rating: 1Date: 2024-12-27Votes: 0 I think .. it's very bloated, hidden reporting packages, data collectors and senders using your bandwidth. pushing upgrade to pro-version" data-og-host="distrowatch.com" data-og-source-url="https://distrowatch.com/table.php?distribution=ubuntu" data-og-url="https://distrowatch.com/table.php?distribution=ubuntu" data-og-image=""><a href="https://distrowatch.com/table.php?distribution=ubuntu" target="_blank" rel="noopener" data-source-url="https://distrowatch.com/table.php?distribution=ubuntu"> <div class="og-image" style="background-image: url();"> </div> <div class="og-text"> <p class="og-title" data-ke-size="size16">DistroWatch.com: Ubuntu</p> <p class="og-desc" data-ke-size="size16">Reader supplied reviews for Ubuntu Average rating7.6from 299 review(s) Version: 24.10Rating: 1Date: 2024-12-27Votes: 0 I think .. it's very bloated, hidden reporting packages, data collectors and senders using your bandwidth. pushing upgrade to pro-version</p> <p class="og-host" data-ke-size="size16">distrowatch.com</p> </div> </a></figure> <p data-ke-size="size16"> </p> <p data-ke-size="size16">해당 링크에서는 다음과 같이 테이블 형태로 glibc 버전을 확인할 수 있다.</p> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1712" data-origin-height="840"><span data-url="https://blog.kakaocdn.net/dn/b4OQ8i/btsLDeSwlBT/HS4G8tXUUKl2lqoGKpH0O1/img.png" data-phocus="https://blog.kakaocdn.net/dn/b4OQ8i/btsLDeSwlBT/HS4G8tXUUKl2lqoGKpH0O1/img.png"><img src="https://blog.kakaocdn.net/dn/b4OQ8i/btsLDeSwlBT/HS4G8tXUUKl2lqoGKpH0O1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4OQ8i%2FbtsLDeSwlBT%2FHS4G8tXUUKl2lqoGKpH0O1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="819" height="402" data-origin-width="1712" data-origin-height="840"></span></figure> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">Ubuntu 24.04 LTS noble에서는 glibc 2.39 버전, 22.04 LTS jammy에서는 2.35 버전을 사용한다.</p> <p data-ke-size="size16">Ubuntu LTS 버전들을 표시해보자면,</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>24.04 LTS noble: glibc 2.39</li> <li>22.04 LTS jammy: glibc 2.35</li> <li>20.04 LTS focal: glibc 2.31</li> <li>18.04 LTS bionic: glibc 2.27</li> <li>16.04 LTS xenial: glibc 2.23</li> </ul> <p data-ke-size="size16">glibc 버전 별 주요 변경점은 추후 작성할 예정이다.</p> <p class="post-meta"> 1 min read   ·   January 2, 2025   ·   tistory.com </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a> </p> </li> <li> <h3> <a class="post-title" href="https://neutrinox4b1.tistory.com/24" target="_blank" rel="external nofollow noopener">Windows에서 GCC를 사용한 C 언어 실행</a> <svg width="2rem" height="2rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p></p> <p data-ke-size="size16">나는 VS Code와 Git Bash조합으로 많이 사용하고 있는데, 추후 빠른 환경설정을 위해서 환경 설정을 한 번 정리하고 넘어가고자 한다.<br> <br>우선, Git Bash와 VSCode가 설치되었다는 가정 하에서<br> <br> </p> <h3 data-ke-size="size23">VSCode 터미널 설정</h3> <hr data-ke-type="horizontalRule" data-ke-style="style5"> <h4 data-ke-size="size20">Panel 위치</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="782" data-origin-height="206"><span data-url="https://blog.kakaocdn.net/dn/bAKLi9/btsJF7gX5PB/77ftrWChXi8C2ZcHwJwiFk/img.png" data-phocus="https://blog.kakaocdn.net/dn/bAKLi9/btsJF7gX5PB/77ftrWChXi8C2ZcHwJwiFk/img.png"><img src="https://blog.kakaocdn.net/dn/bAKLi9/btsJF7gX5PB/77ftrWChXi8C2ZcHwJwiFk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAKLi9%2FbtsJF7gX5PB%2F77ftrWChXi8C2ZcHwJwiFk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="782" height="206" data-origin-width="782" data-origin-height="206"></span></figure> </p> <p data-ke-size="size16"> <br>우선 터미널은 우측으로 두는 것이 작업하기 편리하므로 panel의 default location을 right로 둔다.<br> </p> <h4 data-ke-size="size20">Default terminal</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="730" data-origin-height="162"><span data-url="https://blog.kakaocdn.net/dn/d0Qmaa/btsJEEfLGzy/gEtx72mRllcXKKHvKm2kfK/img.png" data-phocus="https://blog.kakaocdn.net/dn/d0Qmaa/btsJEEfLGzy/gEtx72mRllcXKKHvKm2kfK/img.png"><img src="https://blog.kakaocdn.net/dn/d0Qmaa/btsJEEfLGzy/gEtx72mRllcXKKHvKm2kfK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd0Qmaa%2FbtsJEEfLGzy%2FgEtx72mRllcXKKHvKm2kfK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="730" height="162" data-origin-width="730" data-origin-height="162"></span></figure> </p> <p data-ke-size="size16"> <br>터미널 설정은 우측의 V 표시를 누르고 Select Default Profile -&gt;Git Bash를 지정한다.</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="643" data-origin-height="157"><span data-url="https://blog.kakaocdn.net/dn/OnVS9/btsJGobwRMg/HzYsUnYrhYrkTn3OLt7Jsk/img.png" data-phocus="https://blog.kakaocdn.net/dn/OnVS9/btsJGobwRMg/HzYsUnYrhYrkTn3OLt7Jsk/img.png"><img src="https://blog.kakaocdn.net/dn/OnVS9/btsJGobwRMg/HzYsUnYrhYrkTn3OLt7Jsk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOnVS9%2FbtsJGobwRMg%2FHzYsUnYrhYrkTn3OLt7Jsk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="643" height="157" data-origin-width="643" data-origin-height="157"></span></figure> </p> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="240" data-origin-height="47"><span data-url="https://blog.kakaocdn.net/dn/NG9nA/btsJGxsIGea/axCsmf6fZKaEbTCLaNaO51/img.png" data-phocus="https://blog.kakaocdn.net/dn/NG9nA/btsJGxsIGea/axCsmf6fZKaEbTCLaNaO51/img.png"><img src="https://blog.kakaocdn.net/dn/NG9nA/btsJGxsIGea/axCsmf6fZKaEbTCLaNaO51/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNG9nA%2FbtsJGxsIGea%2FaxCsmf6fZKaEbTCLaNaO51%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="240" height="47" data-origin-width="240" data-origin-height="47"></span></figure> </p> <p data-ke-size="size16"> <br>이제 GCC 설정이 남았다.<br> <br> </p> <h3 data-ke-size="size23">MinGW를 활용한 GCC 설정</h3> <hr data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">일반적으로 사용하는 MinGW가 아니라 MinGW-w64를 사용하고자 하며, gdb 사용 또한 보장되어야 할 것이다.<br> <br><a href="https://stackoverflow.com/questions/25582110/what-is-the-difference-between-mingw-mingw-w64-and-mingw-builds" target="_blank" rel="noopener"><span>MinGW와 MinGW-w64의 차이점</span></a> 및 <a href="https://klutzy.github.io/blog/2015/03/05/mingw/" target="_blank" rel="noopener"><span>배경</span></a><br> <br> <br><a href="https://code.visualstudio.com/docs/cpp/config-mingw" target="_blank" rel="noopener"><span>https://code.visualstudio.com/docs/cpp/config-mingw</span></a></p> <figure data-ke-type="opengraph" data-og-title="Get Started with C++ and MinGW-w64 in Visual Studio Code" data-ke-align="alignCenter" data-og-description="Configuring the C++ extension in Visual Studio Code to target g++ and gdb on a MinGW-w64 installation" data-og-host="code.visualstudio.com" data-og-source-url="https://code.visualstudio.com/docs/cpp/config-mingw" data-og-image="https://scrap.kakaocdn.net/dn/b5y96a/hyW6yRUdlb/rkANNcDAoaxJXgOxMz9sak/img.png?width=1012&amp;height=506&amp;face=0_0_1012_506,https://scrap.kakaocdn.net/dn/Hv82q/hyW6I1iIdK/lJ1HbmIkX9kj4EQbpnGWCK/img.png?width=2482&amp;height=732&amp;face=0_0_2482_732,https://scrap.kakaocdn.net/dn/yFz8t/hyW6ziY3Nn/kkzF5XNEHvJg1JXHME7Dp0/img.png?width=1266&amp;height=453&amp;face=0_0_1266_453" data-og-url="https://code.visualstudio.com/docs/cpp/config-mingw"><a href="https://code.visualstudio.com/docs/cpp/config-mingw" target="_blank" rel="noopener" data-source-url="https://code.visualstudio.com/docs/cpp/config-mingw"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/b5y96a/hyW6yRUdlb/rkANNcDAoaxJXgOxMz9sak/img.png?width=1012&amp;height=506&amp;face=0_0_1012_506,https://scrap.kakaocdn.net/dn/Hv82q/hyW6I1iIdK/lJ1HbmIkX9kj4EQbpnGWCK/img.png?width=2482&amp;height=732&amp;face=0_0_2482_732,https://scrap.kakaocdn.net/dn/yFz8t/hyW6ziY3Nn/kkzF5XNEHvJg1JXHME7Dp0/img.png?width=1266&amp;height=453&amp;face=0_0_1266_453');"> </div> <div class="og-text"> <p class="og-title" data-ke-size="size16">Get Started with C++ and MinGW-w64 in Visual Studio Code</p> <p class="og-desc" data-ke-size="size16">Configuring the C++ extension in Visual Studio Code to target g++ and gdb on a MinGW-w64 installation</p> <p class="og-host" data-ke-size="size16">code.visualstudio.com</p> </div> </a></figure> <p data-ke-size="size16">위 VSCode에서 작성한 문서를 따라 환경설정을 수행한다.<br> </p> <h4 data-ke-size="size20">MSYS2 및 MinGW-w64 설치</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="806" data-origin-height="536"><span data-url="https://blog.kakaocdn.net/dn/qsDxt/btsJFwnOh9V/Y4zWdZk1ABR0REn8KsDYeK/img.png" data-phocus="https://blog.kakaocdn.net/dn/qsDxt/btsJFwnOh9V/Y4zWdZk1ABR0REn8KsDYeK/img.png"><img src="https://blog.kakaocdn.net/dn/qsDxt/btsJFwnOh9V/Y4zWdZk1ABR0REn8KsDYeK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqsDxt%2FbtsJFwnOh9V%2FY4zWdZk1ABR0REn8KsDYeK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="656" height="436" data-origin-width="806" data-origin-height="536"></span></figure> </p> <p data-ke-size="size16"> <br>앞선 링크에서 설치 프로그램에 대한 링크를 통해 MSYS2를 설치한다.<br> <br>MSYS2가 설치되면</p> <pre class="bash" data-ke-type="codeblock" data-ke-language="bash"><code>pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain</code></pre> <p data-ke-size="size16"> <br>을 입력한다.</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="692" data-origin-height="231"><span data-url="https://blog.kakaocdn.net/dn/FQujr/btsJGLKSQDP/KbwH9k1o5d73dIoGppdCBk/img.png" data-phocus="https://blog.kakaocdn.net/dn/FQujr/btsJGLKSQDP/KbwH9k1o5d73dIoGppdCBk/img.png"><img src="https://blog.kakaocdn.net/dn/FQujr/btsJGLKSQDP/KbwH9k1o5d73dIoGppdCBk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFQujr%2FbtsJGLKSQDP%2FKbwH9k1o5d73dIoGppdCBk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="692" height="231" data-origin-width="692" data-origin-height="231"></span></figure> </p> <p data-ke-size="size16">여기에서 Enter를 눌러서 디폴트로 전체 설치를 수행한다.<br> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="286" data-origin-height="79"><span data-url="https://blog.kakaocdn.net/dn/bu4gGT/btsJGBIv22Q/75ZAOCn6ya6fPDL3ubGm7K/img.png" data-phocus="https://blog.kakaocdn.net/dn/bu4gGT/btsJGBIv22Q/75ZAOCn6ya6fPDL3ubGm7K/img.png"><img src="https://blog.kakaocdn.net/dn/bu4gGT/btsJGBIv22Q/75ZAOCn6ya6fPDL3ubGm7K/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbu4gGT%2FbtsJGBIv22Q%2F75ZAOCn6ya6fPDL3ubGm7K%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="286" height="79" data-origin-width="286" data-origin-height="79"></span></figure> </p> <p data-ke-size="size16">Y 입력<br> </p> <h4 data-ke-size="size20">환경 변수 설정</h4> <p data-ke-size="size16">설치가 완료되면 환경변수를 설정한다. <br> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="435" data-origin-height="271"><span data-url="https://blog.kakaocdn.net/dn/UlwIU/btsJE0bHRAi/eK9l2uUJUD7X7aP6Fx4cfk/img.png" data-phocus="https://blog.kakaocdn.net/dn/UlwIU/btsJE0bHRAi/eK9l2uUJUD7X7aP6Fx4cfk/img.png"><img src="https://blog.kakaocdn.net/dn/UlwIU/btsJE0bHRAi/eK9l2uUJUD7X7aP6Fx4cfk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUlwIU%2FbtsJE0bHRAi%2FeK9l2uUJUD7X7aP6Fx4cfk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="350" height="218" data-origin-width="435" data-origin-height="271"></span></figure> </p> <p data-ke-size="size16"> <br>Path에 새로운 환경 변수를 추가한다.</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="185" data-origin-height="22"><span data-url="https://blog.kakaocdn.net/dn/cyF172/btsJG3xNDuy/Lg6kOVzv9U4kK8ijiWGkck/img.png" data-phocus="https://blog.kakaocdn.net/dn/cyF172/btsJG3xNDuy/Lg6kOVzv9U4kK8ijiWGkck/img.png"><img src="https://blog.kakaocdn.net/dn/cyF172/btsJG3xNDuy/Lg6kOVzv9U4kK8ijiWGkck/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcyF172%2FbtsJG3xNDuy%2FLg6kOVzv9U4kK8ijiWGkck%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="185" height="22" data-origin-width="185" data-origin-height="22"></span></figure> </p> <p data-ke-size="size16"> <br>디폴트로 설치했다면 다음 `C:\msys64\ucrt64\bin` 경로로 설정할 것이다.<br> </p> <h3 data-ke-size="size23">설정 완료 및 테스트</h3> <hr data-ke-type="horizontalRule" data-ke-style="style5"> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="529" data-origin-height="95"><span data-url="https://blog.kakaocdn.net/dn/oZoKn/btsJFGjylCy/j64aCvquY9jTuds4wHlXE1/img.png" data-phocus="https://blog.kakaocdn.net/dn/oZoKn/btsJFGjylCy/j64aCvquY9jTuds4wHlXE1/img.png"><img src="https://blog.kakaocdn.net/dn/oZoKn/btsJFGjylCy/j64aCvquY9jTuds4wHlXE1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoZoKn%2FbtsJFGjylCy%2Fj64aCvquY9jTuds4wHlXE1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="529" height="95" data-origin-width="529" data-origin-height="95"></span></figure> <figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="534" data-origin-height="88"><span data-url="https://blog.kakaocdn.net/dn/JLLBZ/btsJG5oSVHV/33mbyfyXucNzeQMKOSrZEK/img.png" data-phocus="https://blog.kakaocdn.net/dn/JLLBZ/btsJG5oSVHV/33mbyfyXucNzeQMKOSrZEK/img.png"><img src="https://blog.kakaocdn.net/dn/JLLBZ/btsJG5oSVHV/33mbyfyXucNzeQMKOSrZEK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJLLBZ%2FbtsJG5oSVHV%2F33mbyfyXucNzeQMKOSrZEK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="534" height="88" data-origin-width="534" data-origin-height="88"></span></figure> <figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="552" data-origin-height="106"><span data-url="https://blog.kakaocdn.net/dn/cqHqsa/btsJFtkpvLP/jyJKjONQUt7zE0Sup8uinK/img.png" data-phocus="https://blog.kakaocdn.net/dn/cqHqsa/btsJFtkpvLP/jyJKjONQUt7zE0Sup8uinK/img.png"><img src="https://blog.kakaocdn.net/dn/cqHqsa/btsJFtkpvLP/jyJKjONQUt7zE0Sup8uinK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcqHqsa%2FbtsJFtkpvLP%2FjyJKjONQUt7zE0Sup8uinK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="552" height="106" data-origin-width="552" data-origin-height="106"></span></figure> </p> <p data-ke-size="size16"> <br>이렇게 되면 Windows VSCode에서 자유롭게 gdb, gcc, g++ 사용이 가능하다.<br> <br> <br>추가적으로, 맥이나 리눅스를 사용하다보면 쉘에서 open 이라는 명령어를 편하게 사용한다.<br>윈도우 환경에서는 `explorer.exe` 로 사용하고, 이는 간단히<br>`~/.bash_profile`에서</p> <pre class="bash" data-ke-type="codeblock" data-ke-language="bash"><code>alias open=explorer.exe</code></pre> <p data-ke-size="size16"> <br>를 추가해주면 된다.</p> <p class="post-meta"> 1 min read   ·   September 20, 2024   ·   tistory.com </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a> </p> </li> <li> <h3> <a class="post-title" href="https://neutrinox4b1.tistory.com/19" target="_blank" rel="external nofollow noopener">하이퍼바이저(Hypervisor)란 무엇인가? with 가상화 (Virutalization)</a> <svg width="2rem" height="2rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p></p> <p data-ke-size="size16">하이퍼바이저란 무엇인가?</p> <p data-ke-size="size16">커널까지는 뭐하는 앤지 대충 알겠는데, 최신 OS에 대해 논하다보면 항상 Hypervisior라는 단어가 빠지지 않는다.</p> <p data-ke-size="size16">하이퍼바이저란 무엇일까?</p> <h2 data-ke-size="size26">1. Hypervisor</h2> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">하이퍼바이저는 가상화를 구현하기 위해 기반이 되는 기술이고</p> <p data-ke-size="size16">가상화 계층을 구현해주는 소프트웨어를 말한다.</p> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="942" data-origin-height="560"><span data-url="https://blog.kakaocdn.net/dn/drmBYh/btsHxJ3diht/mDYAMSOiP2zqOkzqJet4V1/img.png" data-phocus="https://blog.kakaocdn.net/dn/drmBYh/btsHxJ3diht/mDYAMSOiP2zqOkzqJet4V1/img.png"><img src="https://blog.kakaocdn.net/dn/drmBYh/btsHxJ3diht/mDYAMSOiP2zqOkzqJet4V1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdrmBYh%2FbtsHxJ3diht%2FmDYAMSOiP2zqOkzqJet4V1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="557" height="331" data-origin-width="942" data-origin-height="560"></span></figure> </p> <p data-ke-size="size16">하드웨어 위에서 가상 머신을 생성하고 자원을 할당하고, 요청을 처리해주는 매니저의 역할을 수행한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">그래서 가상 머신 매니저(Virtual Machine Manager)  또는 가상 머신 모니터(Virutual Machine Monitor, VMM) 라고 불리기도 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">그럼 이 하이퍼바이저가 우리가 사용하는 윈도우 아래에서 왜 작동하는가?</p> <p data-ke-size="size16">윈도우는 OS가 하나인데 하이퍼바이저를 두면 뭐가 좋아서? 싶다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">우선 하이퍼바이저의 종류부터 알아보자.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">2. Hypervisor Type</h2> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">하이퍼바이저는 Type 1과 Type 2로 나뉜다.</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="471" data-origin-height="285"><span data-url="https://blog.kakaocdn.net/dn/bZX9cy/btsHx0KlNcK/kvwD8CnpKDLgYAyiMKcUnk/img.png" data-phocus="https://blog.kakaocdn.net/dn/bZX9cy/btsHx0KlNcK/kvwD8CnpKDLgYAyiMKcUnk/img.png"><img src="https://blog.kakaocdn.net/dn/bZX9cy/btsHx0KlNcK/kvwD8CnpKDLgYAyiMKcUnk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbZX9cy%2FbtsHx0KlNcK%2FkvwD8CnpKDLgYAyiMKcUnk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="471" height="285" data-origin-width="471" data-origin-height="285"></span></figure> </p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">2.1. Type 1 (navtive, bare-metal)</h3> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1124" data-origin-height="736"><span data-url="https://blog.kakaocdn.net/dn/bN41sY/btsHwB56SXS/eWgaI7ZPFQ00oemDxUJHv0/img.png" data-phocus="https://blog.kakaocdn.net/dn/bN41sY/btsHwB56SXS/eWgaI7ZPFQ00oemDxUJHv0/img.png"><img src="https://blog.kakaocdn.net/dn/bN41sY/btsHwB56SXS/eWgaI7ZPFQ00oemDxUJHv0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbN41sY%2FbtsHwB56SXS%2FeWgaI7ZPFQ00oemDxUJHv0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="442" height="289" data-origin-width="1124" data-origin-height="736"></span></figure> </p> <p data-ke-size="size16">타입 1 하이퍼바이저는 native 또는 Bare-metal 하이퍼바이저라고도 불린다. 이름 그대로의 의미로 하드웨어에서 직접 구동되어 게스트 OS를 관리한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">바로 하드웨어 위에서 동작하므로 호스트 OS가 존재하지 않고, 게스트 OS는 하드웨어 위에 2번째 수준으로  실행되기 때문에 오버헤드가 적다는 장점을 가진다. </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">그러나 VM들에 대한 자체 관리 기능이 없어, VM  관리를 위한 컴퓨터나 콘솔이 별개로 필요하다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">Type 1 하이퍼바이저는 IBM의 CP/CMS에서 시작(최초의 하이퍼바이저는 CP-40)되어 IBM의 z/VM으로 이어졌다.</p> <p data-ke-size="size16">최근에는</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Xen, Ctrix의 XenServer</li> <li>Vmware의 ESX Server, L4 마이크로 커널, TANGO</li> <li>IBM의 POWER 하이퍼바이저 (PR/SM) </li> <li>마이크로소프트 <b>Hyper-V</b>, Parallel Server</li> <li>썬의 로지컬 도메인 하이퍼바이저</li> </ul> <p data-ke-size="size16">등이 있다. 또는 히타치의 Virtage 하이퍼바이저같이 플랫폼 펌웨어에 하이퍼바이저를 넣기도 하며,</p> <p data-ke-size="size16"><b>KVM</b>은 하이퍼바이저에 완전한 리눅스 커널을 넣었는데 <b>이것도 Type 1이다</b>.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">Type 1 하이퍼바이저는 구현 방식에 따라</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>전가상화 (Full-Virtualization) =&gt; VMware ESX Server, MS Hyper-V</li> <li>반가상화 (Half-Virtualization) =&gt; Citrix XenServer</li> <li>HAV (Hardware Asssisted Virtualization)</li> </ul> <p data-ke-size="size16">으로 나뉜다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">2.2. Type 2 (Hosted Hypervisor)</h3> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1134" data-origin-height="562"><span data-url="https://blog.kakaocdn.net/dn/pCImp/btsHykhyPGG/N1DmKXnVOYWBPm0xnFYWi1/img.png" data-phocus="https://blog.kakaocdn.net/dn/pCImp/btsHykhyPGG/N1DmKXnVOYWBPm0xnFYWi1/img.png"><img src="https://blog.kakaocdn.net/dn/pCImp/btsHykhyPGG/N1DmKXnVOYWBPm0xnFYWi1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpCImp%2FbtsHykhyPGG%2FN1DmKXnVOYWBPm0xnFYWi1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="503" height="249" data-origin-width="1134" data-origin-height="562"></span></figure> </p> <p data-ke-size="size16">Type 2 하이퍼바이저는 Hosted 하이퍼바이저라고도 불리며, Host OS를 갖는 하이퍼바이저를 말한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">하드웨어에 이미 Host OS가 설치되어 있고, 하이퍼바이저는 OS 위에서 소프트웨어로서 동작한다. =&gt; 하드웨어로부터 3번째 수준으로 실행된다 </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">기존 시스템 위에서 쉽게 사용 가능하다는 장점을 가진다. </p> <p data-ke-size="size16">그러나 오버헤드가 커지고 Host OS 문제가 전체 게스트 OS에 영향을 미칠 수 있다는 단점이 존재한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">대표적인 종류로는</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>VMware Server</li> <li>VMware Workstation, Fusion</li> <li>QEMU</li> <li>마이크로소프트 버추얼 PC와 버추얼 서버</li> <li>Oracle의 Virutal Box</li> <li>SWsoft의 Paralles Workstation과 Parallels Desktop</li> </ul> <p data-ke-size="size16">등이 있다. 그냥 VM 소프트웨어들 같아보인다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">보통 개인 컴퓨터에서 VM을 사용하고자 할 때 일반적으로 사용하는 유형이다.</p> <p data-ke-size="size16"> </p> <blockquote data-ke-style="style3">Q1. Type 1 하이퍼바이저와 Type 2 하이퍼바이저를 동시에 사용 가능한가?<br>Q2. BoB에서 VT-x 를 설정해야했는데 그거랑 무슨 관련이 있는가? 왜 그렇게 했어야만 하는가?<br>Q3. Hyper-V는 Default 설정이 Enable인가?</blockquote> <p data-ke-size="size16"> </p> <p data-ke-size="size16">A1. GPT: 가능은 하지만 호환성 문제나 성능저하를 야기할 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">A2. BoB에서 VT-x를 설정해야 하는건 Hyper-V를 꺼야 적용되는 옵션이었다.</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1277" data-origin-height="642"><span data-url="https://blog.kakaocdn.net/dn/byudZd/btsHGXOYzQb/zSIuDB2Ks7n4tFGusokyxk/img.png" data-phocus="https://blog.kakaocdn.net/dn/byudZd/btsHGXOYzQb/zSIuDB2Ks7n4tFGusokyxk/img.png"><img src="https://blog.kakaocdn.net/dn/byudZd/btsHGXOYzQb/zSIuDB2Ks7n4tFGusokyxk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbyudZd%2FbtsHGXOYzQb%2FzSIuDB2Ks7n4tFGusokyxk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="532" height="267" data-origin-width="1277" data-origin-height="642"></span></figure> </p> <p data-ke-size="size16">우선, 에러명은</p> <pre id="code_1717049303574" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>VMware Workstation does not support nested virtualization on this host.
Module 'HV' power on failed. 

Failed to start the virtual machine</code></pre> <p data-ke-size="size16">이고, 이 에러가 발생하기 이전에 "virtualized intel vt-x/ept is not supported on this platform" 이 언급된다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">VT-x/EPT란 무엇인가? 이에 대해선 다음 글에 설명해봐야겠다. 우선 알고 넘어갈 것은 CPU에 내장된 하드웨어 가상화 기능이라는 것이다.</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="640" data-origin-height="603"><span data-url="https://blog.kakaocdn.net/dn/ZUsko/btsHG9uZh9f/uhbobxxycXjfmMxdKqdUak/img.webp" data-phocus="https://blog.kakaocdn.net/dn/ZUsko/btsHG9uZh9f/uhbobxxycXjfmMxdKqdUak/img.webp"><img src="https://blog.kakaocdn.net/dn/ZUsko/btsHG9uZh9f/uhbobxxycXjfmMxdKqdUak/img.webp" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZUsko%2FbtsHG9uZh9f%2FuhbobxxycXjfmMxdKqdUak%2Fimg.webp" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="306" height="288" data-origin-width="640" data-origin-height="603"></span></figure> </p> <p data-ke-size="size16">이 에러는 nested virtualization (중첩 가상화)와 관련이 있는데</p> <p data-ke-size="size16">이 에러가 뜨는 vm은</p> <p><figure class="imagegridblock"> <div class="image-container"> <span data-url="https://blog.kakaocdn.net/dn/M6c0x/btsHGUdFRIP/FDuzSJroyNQEFA0fF7u1yK/img.png" data-phocus="https://blog.kakaocdn.net/dn/M6c0x/btsHGUdFRIP/FDuzSJroyNQEFA0fF7u1yK/img.png" data-origin-width="532" data-origin-height="211" data-is-animation="false" width="416" height="165" style="width: 42.1725%; margin-right: 10px;" data-widthpercent="42.67"><img src="https://blog.kakaocdn.net/dn/M6c0x/btsHGUdFRIP/FDuzSJroyNQEFA0fF7u1yK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FM6c0x%2FbtsHGUdFRIP%2FFDuzSJroyNQEFA0fF7u1yK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="532" height="211"></span><span data-url="https://blog.kakaocdn.net/dn/DjlPx/btsHI1u462Q/viuDKN8cEgmHoIaZwMl0OK/img.png" data-phocus="https://blog.kakaocdn.net/dn/DjlPx/btsHI1u462Q/viuDKN8cEgmHoIaZwMl0OK/img.png" data-origin-width="498" data-origin-height="147" data-is-animation="false" style="width: 56.6647%;" data-widthpercent="57.33"><img src="https://blog.kakaocdn.net/dn/DjlPx/btsHI1u462Q/viuDKN8cEgmHoIaZwMl0OK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDjlPx%2FbtsHI1u462Q%2FviuDKN8cEgmHoIaZwMl0OK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="498" height="147"></span> </div> </figure> </p> <p data-ke-size="size16">이 화면에서 Virtualize Intel VT-x/EPT or AMD-V/RVI 기능이 켜져있었다.</p> <p data-ke-size="size16"><a href="https://www.clien.net/service/board/kin/5244830" target="_blank" rel="noopener noreferrer">https://www.clien.net/service/board/kin/5244830</a></p> <figure id="og_1717049814852" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title='Vmware 프로그램에서 옵션에 프로세스 부분에 "virtualize intel vt-x/ept or amd-v/rvi" 옵션은 무슨옵션인가' data-og-description="알려주실 고수분 계신가요 -.-a;; 갑자기 궁굼해서 ㅠㅠ" data-og-host="www.clien.net" data-og-source-url="https://www.clien.net/service/board/kin/5244830" data-og-url="https://www.clien.net/service/board/kin/5244830" data-og-image=""><a href="https://www.clien.net/service/board/kin/5244830" target="_blank" rel="noopener" data-source-url="https://www.clien.net/service/board/kin/5244830"> <div class="og-image" style="background-image: url();"> </div> <div class="og-text"> <p class="og-title" data-ke-size="size16">Vmware 프로그램에서 옵션에 프로세스 부분에 "virtualize intel vt-x/ept or amd-v/rvi" 옵션은 무슨옵션인가</p> <p class="og-desc" data-ke-size="size16">알려주실 고수분 계신가요 -.-a;; 갑자기 궁굼해서 ㅠㅠ</p> <p class="og-host" data-ke-size="size16">www.clien.net</p> </div> </a></figure> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이 옵션을 켜는 이유는 nested VM을 지원하기 위함이며, 해당 VM이 이 옵션을 사용하던 이유는 KVM에서 커널 취약점을 분석하기 위해서 사용하던 VM이기 때문이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">덧붙여서</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="532" data-origin-height="211"><span data-url="https://blog.kakaocdn.net/dn/M6c0x/btsHGUdFRIP/FDuzSJroyNQEFA0fF7u1yK/img.png" data-phocus="https://blog.kakaocdn.net/dn/M6c0x/btsHGUdFRIP/FDuzSJroyNQEFA0fF7u1yK/img.png"><img src="https://blog.kakaocdn.net/dn/M6c0x/btsHGUdFRIP/FDuzSJroyNQEFA0fF7u1yK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FM6c0x%2FbtsHGUdFRIP%2FFDuzSJroyNQEFA0fF7u1yK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="416" height="165" data-origin-width="532" data-origin-height="211"></span></figure> </p> <p data-ke-size="size16"> </p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Virtualize Intel VT-x/EPT or AMD-V/RVI<br>: CPU가 가상화 기술을 지원할 때, 실행 모드를 Intel VT-x나 AMD-V/RVI로 실행하도록 VMware에 지시하는 옵션임</li> <li>Virtualize CPU performance counters<br>: 고급 디버깅이나 성능 모니터링을 수행하는 경우 이 옵션을 활성화하나, 일반적으로는 권장되지 않는다.</li> <li>Virtualize IOMMU (IO memory management unit)<br>: 메모리 및 DMA 리매핑 기술로 AMD와 Intel의 이더넷 가상화 기술이다. 가상 이더넷 장치를 추가할 때 하드웨어 가속을 해준다. 메인보드 지원 필요.</li> </ul> <p data-ke-size="size16">A3. Hyper-V는 기본적으로 Disable 상태로 되어있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">3. 가상화(Virtualization)</h2> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">하이퍼바이저가 있고 VM이 있고 위에서 뭐 게스트 OS가 돌아가고 하는 것은 대충 알겠는데,</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">가상화는 왜 사용하는가?</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">하드웨어 성능이 빠르게 증가하던 1960, 70년대에 소프트웨어 발전 속도는 하드웨어 발전 속도를 따라가지 못하였고</p> <p data-ke-size="size16">소프트웨어 요구 성능보다 서버 성능이 좋다보니 자원이 남아 돌았다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">자원이 남아도는 비효율로 문제를 해결하기 위해서 가상화 개념이 도입되었다.</p> <p data-ke-size="size16"> </p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="503" data-origin-height="144"><span data-url="https://blog.kakaocdn.net/dn/qygt6/btsHxGS0V39/JNtUJitLoM6UN0sXrm6GmK/img.png" data-phocus="https://blog.kakaocdn.net/dn/qygt6/btsHxGS0V39/JNtUJitLoM6UN0sXrm6GmK/img.png"><img src="https://blog.kakaocdn.net/dn/qygt6/btsHxGS0V39/JNtUJitLoM6UN0sXrm6GmK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fqygt6%2FbtsHxGS0V39%2FJNtUJitLoM6UN0sXrm6GmK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="363" height="104" data-origin-width="503" data-origin-height="144"></span></figure> </p> <p data-ke-size="size16">기존에는 하나의 OS, 1개의 태스크를 실행하기 위해서 각각의 물리적 서버가 필요했으나,</p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="502" data-origin-height="135"><span data-url="https://blog.kakaocdn.net/dn/Q7XTG/btsHwNZQZ2w/1KIjrGrSrxLRtPdZZhycT1/img.png" data-phocus="https://blog.kakaocdn.net/dn/Q7XTG/btsHwNZQZ2w/1KIjrGrSrxLRtPdZZhycT1/img.png"><img src="https://blog.kakaocdn.net/dn/Q7XTG/btsHwNZQZ2w/1KIjrGrSrxLRtPdZZhycT1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQ7XTG%2FbtsHwNZQZ2w%2F1KIjrGrSrxLRtPdZZhycT1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="372" height="100" data-origin-width="502" data-origin-height="135"></span></figure> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">서버를 가상화한다면 더 효율적으로 쓸 수 있는 것임.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이렇게 하면</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>비용 절감: 마이그레이션이 쉬워 빈 서버를 재사용하거나 중지시켜서 유지관리를 수월하게 할 수도 있음</li> <li>유연성: 동일 하드웨어에서 여러 운영체제 동시 실행 가능</li> <li>민첩성: 한 물리서버에서 다른 물리 서버로 OS 이동 가능</li> <li>내결함성: 물리적 서버에 장애가 있으면 관리 소프트웨어가 마이그레이션하여 신속한 조치 가능 </li> </ul> <p data-ke-size="size16">이러한 장점을 가진다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">3.1. 가상화 작동 방식 및 종류</h3> <p data-ke-size="size16">하이퍼바이저 소프트웨어를 설치하면 하나의 물리 시스템을 가상 머신으로 분할하여 구현할 수 있다.</p> <p data-ke-size="size16">하이퍼바이저 소프트웨어의 주 역할은 CPU, 메모리, 기타 물리적 리소스를 가상 인스턴스와 분리하는 가상화 계층을 생성(재차 언급임)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"><a href="https://www.redhat.com/ko/topics/virtualization/what-is-virtualization" target="_blank" rel="noopener noreferrer">https://www.redhat.com/ko/topics/virtualization/what-is-virtualization</a></p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">3.1.1. 데이터 가상화</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="635" data-origin-height="473"><span data-url="https://blog.kakaocdn.net/dn/L0vTj/btsHGkiR9Qp/lxwkpJmvOvK24idhvzMdcK/img.png" data-phocus="https://blog.kakaocdn.net/dn/L0vTj/btsHGkiR9Qp/lxwkpJmvOvK24idhvzMdcK/img.png"><img src="https://blog.kakaocdn.net/dn/L0vTj/btsHGkiR9Qp/lxwkpJmvOvK24idhvzMdcK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FL0vTj%2FbtsHGkiR9Qp%2FlxwkpJmvOvK24idhvzMdcK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="355" height="264" data-origin-width="635" data-origin-height="473"></span></figure> </p> <p data-ke-size="size16">데이터 가상화는 여러 곳에 분산된 데이터를 단일 소스로 통합한다.</p> <p data-ke-size="size16">이를 통해 사용자 요구에 따라 데이터를 변환할 수 있는 처리 역량을 확보할 수 있고 적시에 애플리케이션 또는 사용자에게 필요한 데이터를 제공한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">3.1.2. 데스크탑 가상화</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1087" data-origin-height="709"><span data-url="https://blog.kakaocdn.net/dn/cprbvz/btsHGeQufT1/90dEMEGZZoHDutJzSwnV90/img.png" data-phocus="https://blog.kakaocdn.net/dn/cprbvz/btsHGeQufT1/90dEMEGZZoHDutJzSwnV90/img.png"><img src="https://blog.kakaocdn.net/dn/cprbvz/btsHGeQufT1/90dEMEGZZoHDutJzSwnV90/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcprbvz%2FbtsHGeQufT1%2F90dEMEGZZoHDutJzSwnV90%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="362" height="236" data-origin-width="1087" data-origin-height="709"></span></figure> </p> <p data-ke-size="size16">운영체제 가상화와 혼동하기 쉽다.</p> <p data-ke-size="size16">중앙 관리자나 자동화 툴을 이용해서 시뮬레이션된 데스크탑 환경을 수백개의 물리 머신에 동시에 배포할 수 있도록 지원한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">각 머신에서 물리적으로 설치, 구성, 업데이트 되는 전통적인 데스크탑 가상화와 달리,</p> <p data-ke-size="size16">관리자가 모든 데스크탑에서 설치, 구성, 업데이트를 수행 가능하다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">3.1.3. 서버 가상화</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="530" data-origin-height="287"><span data-url="https://blog.kakaocdn.net/dn/cV0HLB/btsHGVCThPN/lgSf4klYIBFLE11XNk3FK1/img.png" data-phocus="https://blog.kakaocdn.net/dn/cV0HLB/btsHGVCThPN/lgSf4klYIBFLE11XNk3FK1/img.png"><img src="https://blog.kakaocdn.net/dn/cV0HLB/btsHGVCThPN/lgSf4klYIBFLE11XNk3FK1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcV0HLB%2FbtsHGVCThPN%2FlgSf4klYIBFLE11XNk3FK1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="329" height="178" data-origin-width="530" data-origin-height="287"></span></figure> </p> <p data-ke-size="size16">서버를 가상화해서 서버의 기능을 많이 수행할 수 있고, 서버 파티셔닝을 통해 구성요소로 여러 기능을 지원할 수 있다.</p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">3.1.4. 운영체제 가상화</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="400" data-origin-height="321"><span data-url="https://blog.kakaocdn.net/dn/bLr44o/btsHHKAAc2S/SeBzlN1VCNcS0GjAODOBj1/img.png" data-phocus="https://blog.kakaocdn.net/dn/bLr44o/btsHHKAAc2S/SeBzlN1VCNcS0GjAODOBj1/img.png"><img src="https://blog.kakaocdn.net/dn/bLr44o/btsHHKAAc2S/SeBzlN1VCNcS0GjAODOBj1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbLr44o%2FbtsHHKAAc2S%2FSeBzlN1VCNcS0GjAODOBj1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="350" height="281" data-origin-width="400" data-origin-height="321"></span></figure> </p> <p data-ke-size="size16">운영체제 가상화는 커널에서 이루어진다.</p> <p data-ke-size="size16">이렇게 하면 linux 환경과 windows 환경을 함께 실행할 수 있다.</p> <p data-ke-size="size16">기업에서는 운영체제를 push해서 다음과 같은 이점을 얻을 수 있다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>하드웨어 비용 감소: 컴퓨터에 고도의 OOTB(Out Of The Box) 기능이 필요하지 않음</li> <li>보안 강화: 모든 가상 인스턴스를 모니터링하고 격리할 수 있음</li> <li>시간 절약: 소프트웨어 업데이트같은 IT서비스의 소요시간이 감소됨</li> </ul> <h4 data-ke-size="size20">3.1.5. 네트워크 기능 가상화 (Network Fuctions Virtualization, NFV)</h4> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="400" data-origin-height="337"><span data-url="https://blog.kakaocdn.net/dn/CIY8y/btsHHMEY4Rq/oFkXgclJQdnYkwFjAA0KZ1/img.png" data-phocus="https://blog.kakaocdn.net/dn/CIY8y/btsHHMEY4Rq/oFkXgclJQdnYkwFjAA0KZ1/img.png"><img src="https://blog.kakaocdn.net/dn/CIY8y/btsHHMEY4Rq/oFkXgclJQdnYkwFjAA0KZ1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCIY8y%2FbtsHHMEY4Rq%2FoFkXgclJQdnYkwFjAA0KZ1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="305" height="257" data-origin-width="400" data-origin-height="337"></span></figure> </p> <p data-ke-size="size16">디렉터리 서비스, 파일 공유, IP 설정같은 네트워크 주요 기능을 분리하여 이러한 기능을 환경에 배포시킴</p> <p data-ke-size="size16">소프트웨어 기능이 속한 물리머신으로부터 분리하면 특정 기능을 새 네트워크에 패키징하고 이를 환경에 할당할 수 있음. =&gt;뭔말이래;</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">네트워크를 가상화하면 물리 구성 요소의 수가 감소한다. (스위치, 라우터, 서버, 케이블, 허브 등 여러 독립적인 네트워크를 생성하는데 필요하며, 특히 산업에서 일반적으로 사용되는 물리 구성 요소..)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <p class="post-meta"> 1 min read   ·   May 22, 2024   ·   tistory.com </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a> </p> </li> <li> <h3> <a class="post-title" href="https://neutrinox4b1.tistory.com/3" target="_blank" rel="external nofollow noopener">Team. PPP - CTF 운영에 대한 제안</a> <svg width="2rem" height="2rem" viewbox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p></p> <p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="150" data-origin-height="150"><span data-url="https://blog.kakaocdn.net/dn/XD10w/btsG8DVTdmk/cm4WLGk6SLIInu6nSOao8K/img.png" data-phocus="https://blog.kakaocdn.net/dn/XD10w/btsG8DVTdmk/cm4WLGk6SLIInu6nSOao8K/img.png"><img src="https://blog.kakaocdn.net/dn/XD10w/btsG8DVTdmk/cm4WLGk6SLIInu6nSOao8K/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXD10w%2FbtsG8DVTdmk%2Fcm4WLGk6SLIInu6nSOao8K%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" loading="lazy" width="150" height="150" data-origin-width="150" data-origin-height="150"></span></figure> </p> <p data-ke-size="size16">PPP팀의 <a href="https://github.com/pwning/docs/blob/master/suggestions-for-running-a-ctf.markdown" target="_blank" rel="noopener">suggestions-for-running-a-ctf</a> 문서를 읽고 정리한 글</p> <p data-ke-size="size16">CTF에는 어떤 문제들이 출제되고(되어야 하고) 어떻게 운영되는지 담은 글 같아서 정리해둔다.</p> <p data-ke-size="size18"> </p> <h2 data-ke-size="size26">Introduction</h2> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">이 문서는 CTF 대회 운영과 관련된 설계 및 기술적인 세부 사항을 설명한다.</p> <p data-ke-size="size16">CTF 커뮤니티들이 가지고 있는 의견을 요약하고, 문제를 설계할 때 피해야 할 몇 가지 구체적인 위험 사항들을 나열하고자한다.</p> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">General Design</h2> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">CTF를 많이 참가하여 타겟 고객(참가자)를 파악하고 내려야 할 몇 가지 결정들에 익숙해지는 것이 좋다.</p> <p data-ke-size="size16">CTF를 준비하고 실행하는 것은 항상 예상보다 더 많은 시간과 노력이 필요하므로 작업할 시간을 충분히 가지도록 한다. :-)</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Timing</h3> <p data-ke-size="size16">다른 보안 행사와의 일정 충돌을 피하기 위해, <a href="https://ctftime.org/" rel="external nofollow noopener" target="_blank">ctftime.org</a>같은 것을 주로 사용해보자. 미리 계획하고 이벤트를 일찍 발표해서 다른 사람들이 계획할 시간을 갖도록 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">또한, 과거에 열린 큰 규모의 대회 일정을 찾아볼 수 있다. 매년 같은 날짜에 열리는 경향이 있으며(연례 컨퍼런스와 관련됨) 이를 통해 CTF에 많은 인원을 수용하기 위해서 일정을 변경할 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">주중에는 CTF 일정을 잡지 않도록 한다. 이는 학생과 직업을 가진 사람들에게 패널티가 된다.</p> <p data-ke-size="size16">경쟁을 24시간 또는 48시간 열어두어야 한다. 이렇게 하면 전 세계 팀이 동일한 ‘일광’ 시간을 투자할 수 있다.</p> <p data-ke-size="size16">그러나 일반적으로 2일 이상 열어두는 것은 좋지 않다. 좋은 문제로는 그렇게 많은 시간을 채울 수 없거나, 할수 있다 하더라도 참가자들이 금방 지치게 된다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Flag Format</h3> <p data-ke-size="size16">플래그 형식이 사소한 것처럼 보일 수 있으나, 성가신 플래그 형식은 그럭저럭 괜찮은 CTF 경험을 짜증나는 경험으로 바꿀 수 있다.</p> <p data-ke-size="size16">가능한 한, 플래그를 참가자들이 해결하면서 발견하는 간단한 ASCII 문자열로 만들자. 그리고 다음과 같은 복잡한 형식으로는 만들지 않도록 한다.</p> <pre id="code_1714633573327" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>&lt;md5(대상 이름)&gt;&lt;이벤트 날짜&gt;&lt;함수 주소&gt;</code></pre> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이러한 형식은 실수로 충분히 명시되지 않기 쉽다. 이름은 대문자로? 어떻게 표기하는가? 날짜에는 슬래시? 대시? 점으로 구분하는가? 시간도 포함인가? 어떤 시간대인가? 정확도는 얼마나 되고 초, 밀리초, 마이크로초인가? 함수 주소는 16진수인가? 8자리 또는 16자리 0으로 채워진 주소인가? 0x로시작하나 아니면 시작하지 않나?</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">또한, 복합 플래그 형식은 참가자들이 올바른 것을 찾았는 지 알기 어렵게 만든다. 새로운 추축이 있을 때마다, 여러 순열을 시도해야 하며 형식을 가지고 놀면서 가까운 지 궁금해하는 것은 보람이 없다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">(복잡한 형식을 절대적으로 필요하는 좋은 문제가 있을 수 있다. 조심스럽게 진행하고 모호함을 주의하도록 한다.)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">참가자들에게 해시로 만들어 플래그로 보내도록 요청하지 않도록 한다. 해시에 정확히 무엇이 들어가야 하는지 명시하기 어렵고, 대소문자나 new line 문자에서 사소한 오류로 인해 잘못된 결과가 나올 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">해시 자체가 원래 플래그보다 추축하기 어렵지도 않다; 직접 제출하는게 낫다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">주최자 입장에서 힌트 필요 여부나 참가자들이 예상치 못한 장애물에 부딪혔는지 알기 위해 플래그 제출 로그를 보는 것도 중요하다. MD5 해시만 본다면 무슨 일이 일어나고 있는 지 알 수 없다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">플래그는 항상 제출할 플래그처럼 명확하게 보여야 한다. 플래그가 “축하합니다. 이겼습니다!” 또는 “1234"라면, 일부 참가자들은 문제를 해결했다는걸 깨닫지 못하고 계속 시간을 낭비할 수도 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">주최자들은 `MyCTF{663d63e8c755f1b4}` 또는 `funny_1337speaK_pHras3` 같은 일반적인 형식을 모든 대회의 플래그에 사용하는 것이 좋다.(일부 플래그 앞에 “flag is:” 를 포함하는 것도 도움이 된다.)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">브루트 포스로 풀수 있는 플래그를 피해야 한다. 예를 들어 플래그가 도시 이름이라면, 일부 플레이어는 수천 개의 추측을 제출할 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">모든 키 제출 앞에 CAPCHA를 두지는 말자 이는 불필요하고 플레이어한테 성가신 일이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">플래그 검사는 최대한 허용적이어야 한다. 대소문자를 구분하지 않고 합리적으로 유연해야 한다.</p> <p data-ke-size="size16">좋은 기능 중 하나는, “CTF{663d63e8c755f1b4}”, “663D63E8C755F1B4”, “flag is:663D63E8C755F1B4” 같은 것을 모두 받아들이는 것이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">또 다른 좋은 기능은 웹 폼에 복사하여 붙여넣을 때 쉽게 추가될 수 있는 공백 문자를 플래그 제출에서 자르거나 삭제하는 것이다. -&gt; .strip()</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Mechanics</h3> <p data-ke-size="size16">CTF는 재미를 위한 게임이지만, 보안 기술 연습이기도 하다. 도전 과제를 둘러싼 게임플레이 매커니즘은 재미와 흥미를 더할 수 있지만, 항상 보안 기술을 발휘하는 것은 아니다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">최고의 CTF 챌린지는 재미와 주제에 관한 것이다. 팀이 매커니즘에 대해 전략을 세우는 것은 나쁘지 않지만, CTF의 핵심은 항상 보안 문제이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">따라서, 아무리 복잡하더라도 CTF 채점 시스템은 최고의 보안 기술을 보여주는 팀에 큰 보상을 제공해야 한다. 게임 매커니즘에 열심히 생각하고 그것이 악용되거나, 핵심 과제에서 너무 많은 방해를 받지 않도록 노력하자. (재미 없다는 뜻은 아니지만, 본 문서에서는 그러한 대회에 적용되는 내용이 거의 없다.)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">Jeopardy 스타일 CTF의 몇 가지 일반적인 매커니즘은 다음과 같다. :</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>어려운 “역작” 문제를 더 높은 점수를 가지도록 하고, 쉽거나 더 하찮고 게싱하는 문제를 낮은 점수를 가지도록 한다. 이는 사람들이 어려운 문제를 살펴보고 하드코어한 보안 기술을 배우도록 장려한다. 포인트 값을 미세 조정하는 것에 대해서는 걱정하지 말자. “완벽함"은 없다. 문제를 테스트 하는 사람은 문제를 낸 사람보다 난이도를 더 잘 알고 있으므로 테스터는 일반적으로 적합한 점수 값을 할당한다.</li> <li>“돌파 점수"를 사용한다.: 각 문제를 처음으로 최초 몇 팀에게만 주어지는 추가 포인트(보통 동점자 처리를 위한 것)을 활용한다. 이는 팀이 자신들의 플래그를 쥐고 있다가 대회 끝에서 모두 제출하는 ‘플래그 키핑’을 방지하는데 도움이 된다 (플래그 키핑은 종종 유리한 경우가 있음).<br><br>자신이 생각한 만큼 잘하지 않는다는 사실을 깨달으면 사기가 떨어지기 때문에, 돌파 점수와 같은 키핑 방지 조치를 취하는 것이 좋다</li> <li>문제의 열림/닫힘 상태는 모두 동일해야 한다. 즉, 한 팀에게 문제가 열려 있다면 모든 팀에게 열려 있어야 한다. 이는 모든 팀에게 모든 문제를 살펴볼 공정한 시간과 기회를 제공하고, 불운한 문제를 열어 손해를 보는 팀이 생기는 상황을 피하는 데 도움이 된다.<br><br> </li> <li>점수판에 있는 모든 팀에는 항상 해결해야 할 문제가 2~3개 이상 있는지 확인해야 한다. 특정 문제에 막히는 것은 어느 팀이게나 쉽게 일어날 수 있다 (자신들의 잘못이 아닐 수도 있음). 그리고 모든 참가자들이 자신들이 다루고 싶어하는 문제를 다루도록 하는게 모두를 만족시키는 최선의 방법이다.<br><br> </li> <li>열려있는 미해결 문제의 수를 제한하도록 한다. 이는 대규모 팀이 큰 이점을 얻는 것을 방지하며, 내년을 위해 열리지 않은 문제를 몇 개 절약할 수 있다.</li> </ol> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Testing</h3> <p data-ke-size="size16">테스팅은 끔찍한 문제와 훌륭한 문제의 차이가 된다. 누군가가 요청할 때마다 서비스가 작동하고 해결 가능한지 확인하기 위해 실행할 수 있는 참조 솔루션을 마련해야 한다.</p> <p data-ke-size="size16">원래 문제 작성자가 아닌 다른 사람에게 풀이를 작성하게 하여, 심령술사가 아니어도 실행 가능한지 확인해야 한다. 모든 것을 테스트할 시간이 없다면, ‘블랙박스’ 기반 문제에 우선 순위를 둔다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Communication</h3> <p data-ke-size="size16">주최자는 CTF 전체 기간 동안 연락이 가능하도록 해야 한다. IRC 채널을 만들고 CTF 전체에서 이를 모니터링 한다. 채널에서 주최자들에게 채널 운영자 역할을 부여하여 플레이어들이 문제에 대해 누구와 논의해야 하는지 알 수 있도록 해야한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이메일 주소를 공개하고 모니터링 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">사이트에 트위터 스트림이나 뉴스 페이지와 같은 최소한 하나의 다른 커뮤니케이션 채널을 가져, 누구도 중요한 게임 업데이트를 놓치지 않도록 해야한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Problem Updates</h3> <p data-ke-size="size16">문제에 변경 사항이 있을 때마다 IRC 뿐만 아니라 영구적이고 눈에 띄는 장소에 이를 발표해야 한다.</p> <p data-ke-size="size16">문제 설명을 업데이트하여 변경 사항을 반영하도록 한다. 변경된 다운로드 파일이 있다면, 파일 이름을 업데이트 하여 변경 사항이 명백하게 드러나도록 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">해당되는 경우, 원래 버전의 문제도 계속 사용 가능하게 하고 운영한다. 예를 들어, 업데이트 하려는 문제에 대해 누군가가 정답에 가까이 다가간 경우가 있을 수 있다.</p> <p data-ke-size="size16">문제에 솔버(solver)가 있는 경우, 문제 변경에 신중해야 한다. (점수 가치, 문제 파일, 설명, 힌트를 포함) 이러한 문제들은 대부분 사례별로 처리해야 하므로 좋은 판단력을 발휘하기 바란다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Problem Distribution</h3> <p data-ke-size="size16">파일을 배포하는 가장 쉬운 방법은 스코어보드 서버에서 HTTP를 이용하는 것이다. Dropbox 및 Google Drive같은 서비스는 대역폭 제한에 도달할 수 있으므로 사용하지 말아야 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">철저한 준비가 되어 있고, 대용량 파일이 있는 경우 배포하는 가장 좋은 방법은 gpg 또는 openssl 같은 무료 도구를 사용하여 대칭 암호화하고 CTF 전에 토렌트를 배포하는 것이다. 그런 다음 CTF의 시작(또는 중간)에 암호화를 해제하여 사람들에게 파일에 대한 액세스 권한을 부여할 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">문제가 열릴 때까지 문제에 대한 파일에 접근할 수 없는 지 확인하라.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이를 수행하는 한 가지 간단한 방법은 파일 이름에 파일 내용의 해시를 추가하여(파일 이름을 추측할 수 없도록) 웹 서버에서 디렉토리 인덱싱을 비활성화 하는 것이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">문제를 다운로드 하기 위해 로그인이 필요하지 않은 경우에도 좋다. 이렇게 하면 플레이어들이 wget이나 curl같은 도구를 명령 줄에서 쉽게 사용할 수 있고, 성가신 쿠키 설정이나 로그인 처리 스크립트를 준비할 필요가 없다. 파일명이 비밀로 유지된다면 이것과 관련된 문제가 없어야 한다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Infrastructure</h3> <p data-ke-size="size16">다른 모든 것과 마찬가지로 인프라의 모든 부분을 주의 깊게 테스트해야 한다.</p> <p data-ke-size="size16">많은 CTF 주최자들이 웹 사이트와 관련한 문제들을 클라우드에 호스팅하는 것이 유용하다고 발견했다. 이 방식은 필요에 따라 더 많은 인스턴스를 빠르고 쉽게 가동할 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">최종 배포 인프라에서 적절한 테스트를 수행해야 한다. 예를 들어, 첫 번째 pCTF에서 pwnable 문제들이 NX를 지원하지 않는 기계에서 실행된다면 이는 인프라가 철저히 테스트되지 않아 CTF 이후까지 내용이 누락되었다. (역주: PPP 팀 이야기로 보임)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">배포 인프라에서 테스트할 항목의 부분적인 체크리스트:</p> <p data-ke-size="size16"> </p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>팀 등록 및 키 제출에 대한 End to End Testing</li> <li>키(flag) 제출에 중복 계산 race condition이 없는 지 확인해야 한다.</li> <li>점수판 및 주요 제출에 대한 부하 테스트를 수행한다.</li> <li>pwnable 머신이 원하는 보호 기능을 제공하는 지 확인한다.</li> <li>모든 문제에 대한 전체 솔루션을 테스트한다. 이는 솔루션 스크립트를 실행할 수 있고 올바른 키가 출력된다는 의미이다. “내 솔루션 스크립트에 eip=0x41414141이 표시된다"는 것으로는 충분하지 않을 수 있다.</li> <li>CTF 중에 문제 업데이트하는 것을 테스트해야 한다. 실수가 발생할 수 있으므로 준비하는 것이 좋다.</li> <li>서비스에서 실행되는 바이너리/코드가 제공하는 파일과 일치하는 지 테스트해야 한다.</li> </ul> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Problems</h3> <p data-ke-size="size16">CTF의 목표는 플레이어가 배우고 즐기는 것임을 기억한다.</p> <p data-ke-size="size16">문제의 핵심은 해결되는 것이므로, 적어도 한 팀 이상이 모든 문제를 해결하는 것이 좋다. 창의력을 발휘하고 풀이자들이 문제에서 멋진 점을 배울 수 있도록 노력해야 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">플레이어가 고객이라는 점을 기억하고, 그들을 행복하게 만들자 :-)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">아래에는 특정 문제 범주에 대한 좀 더 구체적인 권장 사항이 있다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Pwnable</h3> <p data-ke-size="size16">이 pwnable 섹션에서는 Linux 바이너리만 구체적으로 다룬다.</p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">Local</h4> <p data-ke-size="size16">로컬 pwnable에서는 일반적으로 시스템에 대한 ssh 연결과 거기에서 setuid/setgid 바이너리 활용이 포함된다.</p> <p data-ke-size="size16">이를 수행하는 가장 좋은 방법은 팀이 서로 간섭하거나 정보를 유출하지 않고 작업할 수 있도록 컴퓨터에 팀별 계정을 만드는 것이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">다음은 머신에서 구성할 사항에 대한 간단한 체크리스트이다. :</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>컴퓨터가 완전히 패치되고 최신 상태인지 확인한다.</li> <li>limits.conf를 통해 forkbombing 또는 기타 리소스 고갈을 방지한다.</li> <li>`sysctl -w kernel.dmesg_restrict=1` # 그리고 `/etc/sysctl.conf`에 persist 를 설정한다.</li> <li>`mount -o remount,hidepid=2 /proc` # 사용자가 서로의 프로세스를 볼 수 없도록 한다.</li> <li>`chmod 1733 /tmp/var/ /dev/shm` # 작업 내용이 다른 사람에게 유출되는 것을 방지하기 위해 # 사용자별 홈 디렉토리가 있는 경우 `chmod 700` 하면 된다. :-)</li> <li>문제에 대한 사용자를 생성하고 `/home/problemuser/problem`에 문제를 넣는다.</li> <li>`chown -R root:rioot /home/problemuser`</li> <li>`chown root:problemuser /home/problemuser/problem`</li> <li>`chmod 2755 /home/problemuser/problem`</li> <li>`touch /home/problemuser/flag`</li> <li>`chown root:problemuser /home/problemuser/flag`</li> <li>`chmod 440 /home/problemuser/flag`</li> </ul> <p data-ke-size="size16">모든 문제와 마찬가지로 완전히 설정된 후 완전히 테스트한다. 특히, 참조 솔루션이 CTF 사용자 중 하나로 작동하는 지, 플래그가 다른 수단을 통해 읽힐 수 없거나 루트 이외의 사용자가 쓸 수 없는 지 확인해야 한다.</p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">Local Kernel</h4> <p data-ke-size="size16">로컬 커널 익스플로잇 문제는 일반적으로 시스템에 ssh로 접속하고 사용자 정의 커널 드라이버를 활용하는 것과 관련된다. 이러한 유형의 문제는 안정적으로 호스팅하기 어려울 수 있고, 쉽게 확장할 수 없다. 실패한 exploit은 일반적으로 운영체제를 다운시키므로, 각 팀은 자신만의 고립된 vm을 가져야 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">커널 문제는 팀 수가 적고 충분한 시스템 자원이 할당될 수 있는 CTF ‘결승전’에 더 적합할 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">가능한 설정은 하나 또는 여러 ESXi(Type 1 hypervisor) 호스트를 운영하고 각 팀에게 별도의 VM을 지원하는 것이다. 그리고 각 팀에 SSH 자격 증명을 제공한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">몇 가지 팁과 알림:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>20개의 개별 VM을 만드는 대신 하나의 기본 VM을 만들고 20개의 연결된 클론을 만든다.</li> <li>각 VM이 생성된 후 로그인하고 고유한 고정 IP 주소를 구성한다.</li> <li>모든 공개 취약점에 대해 운영체제가 완전히 업데이트 되고 패치되었는지 확인한다.</li> <li>사용자를 sudo 접근에서 제거한다.</li> <li>/root에 플래그를 생성하고: `chmod 400 -R /root; chown root:root -R /root`</li> <li>/root/.ssh에 member SSH key를 삭제하고 원격 루트 SSH 로그인을 활성화하면 잠재적인 문제를 해결하는 데 도움이 된다.</li> <li>문제의 일부가 정보 유출이 아니라면, 모든 사용자가 /proc/kallsyms를 읽을 수 있도록 허용한다: `echo &gt; /proc/sys/kernel/kptr_restrict`</li> <li>오류(oopses)에 대한 커널 패닉을 비활성화 한다.: `echo 0 &gt; /proc/sys/kernel/panic_on_oops`</li> <li>원격 VM을 재부팅하기 위해 팀에서 호출할 수 있는 간단한(인증된) 스크립트를 개발한다. Exploit 시도 후, 게스트 OS가 응답하지 않을 수 있으므로 이는 게스트가 아닌 하이퍼바이저와 상호작용해야 한다. 그렇지 않으면 팀에서 재부팅을 자주 요청하게 된다.</li> <li>작동하는 솔루션이 존재하고 예상되는 모든 완화 조치가 실제로 VM에서 작동하는지 확인한다. 여기에는 읽기 전용 메모리 SMEP/SMAP 등이 포함된다.</li> </ul> <p data-ke-size="size16">커널 챌린지는 재미있어야 한다!</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">단순히 오래된 OS를 설치하고 참가자들에게 공개적인 악용 코드를 컴파일하라고 하는 것이 아니라, 도전 과제를 창의적으로 만드는 여러 방법들이 있다.</p> <p data-ke-size="size16">또한 연결 시 qemu를 통해 실행될 수 있는 매우 최소한의 VM을 buildroot로 구축하는 것이 간편하다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">위의 참고 사항이 적용되지만 이러한 접근 방식에는 몇 가지 주의점이 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">몇 가지 팁:</p> <p data-ke-size="size16"> </p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>VM에 네트워킹이 되어있는 지 확인한다. 일부 초소형 VM에 16진수/셸코드를 붙여넣는 것은 재미가 없다.</li> <li>실행 중인 vm의 디버깅을 비활성화 하기 위해 qemu 모니터에 접근을 비활성화 한다. : `-monitor /dev/null`</li> <li>가능하면, Ctrl+C를 눌러도 연결이 끊기지 않도록 curses 모드로 qemu 인스턴스를 로그인 셸로 설정한다.</li> <li>대규모 CTF라면 qemu를 시작하기 전에 어떤 종류의 캡챠 또는 작업 증명을 두는 것이 좋을 수 있다.</li> <li>모든 연결이 “새로운” VM을 받도록 한다. 연결 시 디스크 이미지를 복사본으로 교체하는 것은 쉽고, 작은 VM의 경우에는 오버헤드가 많지 않아야 한다.</li> <li>KVM은 EC2/Azure같은 가상화된 환경에서 사용할 수 없다. 하드웨어 가상화 없이도 VM의 속도가 충분히 빠른 지 테스트하여 반응성을 확인한다.</li> </ul> <h4 data-ke-size="size20">Remote</h4> <p data-ke-size="size16">Remote pwnable에는 취약한 네트워크 서비스 실행이 포함된다. 이를 해결하는 두 가지 인기있는 방법이 있다.</p> <p data-ke-size="size16">xinetd를 사용하는 것과 바이너리 자체에서 fork/accept를 하는 것이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">각 연결마다 스레드를 사용하지 말아야 한다. 이는 보통 사용자들이 서로의 Exploit을 방해하게 하며(의도적으로나 우연히나), 문제를 매우 짜증나게 만들 수 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">문제가 libc leak에 의존하는 경우, 문제 바이너리와 함께 libc.so를 제공하는 것을 고려해야 한다. libc를 찾는 것은 CTF에서 테스트할 흥미로운 기술이 아니다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">xinetd 대신 자체 fork/accept 서버를 사용하는 경우, 서비스를 Exploit 하는 사람이 서비스를 종료하거나 점령할 수 없도록 특별한 주의를 기울여야 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">일반적인 방법은 서비스를 루트로 시작하고 forking 후 권한을 하락시키는 것이다. (그리고 소켓 fd를 유출하지 않도록 주의한다)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이 권장 사항을 따르는 샘플 fork/accept 서버는 <a href="https://github.com/pwning/docs/blob/master/fork_accept.c" target="_blank" rel="noopener">fork_accept.c</a> 를 참조하라.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">xinetd 서비스에 대한 샘플 xinetd구성은 <a href="https://github.com/pwning/docs/blob/master/example.xinetd" target="_blank" rel="noopener">example.xinetd</a>를 참조하라.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">chroot 또는 제한된 환경에서 챌린지를 시작하기로 한 경우, /bin/sh, /bin/bash, /bin/cat 같은 기본 프로그램이 있는지 확인한다. 이것이 불가능하다면 문제 설명에서 그 사실을 명확히 해야한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">서비스를 완전히 Exploit하고 제한된 chroot에서 실행되고 있다는 것을 깨닫기까지 한 시간을 낭비하는 것은 매우 짜증나는 일이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">remote pwnalbe을 설정하기 위한 지침:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>문제를 위한 사용자를 생성하고 문제를 /home/problemuser/problem에 둔다.</li> <li>`chown -R root:problemuser /home/problemuser`</li> <li>`chmod 750 /home/problemuser`</li> <li>`touch /home/problemuser/flag`</li> <li>`chown root:problemuser /home/problemuser/flag`</li> <li>`chmod 440 /home/problemuser/flag`</li> </ul> <p data-ke-size="size16"> </p> <p data-ke-size="size16">short read에 의존하지 않도록 한다. 원격으로 올바르게 처리하기 어려울 수 있다. 대신, 구분자가 나타날 때까지 한 바이트씩 읽거나 길이로 제한된 문자열 읽기를 고려한다. (e.g. 4바이트 리틀 엔디언 길이를 읽은 다음 데이터 길이만큼의 바이트를 읽음).</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">마찬가지로 read/recv 호출 시 반환 값이 확인되어 사용자 입력이 누락되지 않도록 한다.</p> <p data-ke-size="size16">명확히 하기 위해, 4096 바이트를 읽는 잘못된 예시는 다음과 같다:</p> <p data-ke-size="size16"> </p> <pre id="code_1714717804965" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>char buf[4096];
recv(fd, buf, sizeof(buf)); // 이 부분이 잘못됨. recv는 &lt; 4096을 반환할 수 있음</code></pre> <p data-ke-size="size16"> </p> <p data-ke-size="size16">더 나은 방법은 <a href="https://github.com/pwning/docs/blob/master/fork_accept.c" target="_blank" rel="noopener">fork_accept.c</a> 의 recvlen함수를 참조하라.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">/home/problemuser/flag 같이 예측 가능한 위치에 flag를 배치한다. 서비스를 성공적으로 exploit 한 후 플래그를 찾는데 시간을 낭비하는 것은 실망스럽다.</p> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">General notes</h4> <p data-ke-size="size16">제대로 작동하는 pwnable 문제를 만드는 데 가장 중요한 부분 중 하나는 적절한 테스트이다 (이상적으로는 저자 이외의 최소 한 명이 테스트해야 한다).</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">누군가 pwnable이 작동하지 않는다고 불평할 때마다, 문제가 작동하는지 여부를 확인할 수 있는 완전한 참조 솔루션을 실시간 인스턴스에 대해 실행할 수 있어야 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">다음은 pwnable에서 일반적으로 짜증나는 몇 가지 사항들이다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>귀찮은 출력 파싱 출력은 간단하고 파싱하기 쉽게 유지해야한다.<br><br>파싱하기 가장 좋은 유형의 출력은 길이로 제한된 문자열이다.<br>귀찮은 출력 형식의 예: <br>ASCII 십진수 길이로 구분된 문자열 121A1B1C1D1E1F 이를 어떻게 구분 분석해야 하는가? (12, 1A1B1C1D1E1F)? (1, ‘2’), (1, ‘A’), (1, ‘C’), (1, ‘D’), (1, ‘E’), (1, ‘F’)? 또 다른 귀찮은 출력 형식은 ANSI 이스케이프 코드가 포함된 것이다. (자제 바람)</li> <li>바이너리 NX가 활성되어 있어도, 실행되는 기계가 이를 지원하지 않는 경우</li> <li>말이 안 되는 코드와 ‘가짜’버그, 코드의 90%가 리버싱 시간 낭비를 위해 입력을 무작위 상수와 비교하는 것. <br><br>이는 재미있는 문제가 아니다. 버그가 무작위 제약 조건이 충족되었을 때, 프로그램이 아무 이유 없이 해당 버퍼로 점프하는 것이라면, 조금 더 창의적이어야 한다.</li> </ul> <p data-ke-size="size16"> </p> <h4 data-ke-size="size20">Compile time proetections</h4> <p data-ke-size="size16">pwnable을 위해 특정 보호 기능들이 활성화되어야 하는 경우가 있다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">여기 gcc에서 이들을 강제로 켜거나 끄는 방법이 있다:</p> <p data-ke-size="size16"> </p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>-fstack-protector / -fno-stack-protector: stack canary</li> <li>-D_FORTIFY_SOURCE=2/ -D_FORTIFY_SOURCE=0(재 정의 경고를 무시하기 위해 U_FORTIFY_SOURCE를 앞에 추가): memcpy(), sprintf(), read() 등의 libc 함수 버전을 사용하여 버퍼 오버플로우를 감지할 때 중단한다.(감지가 완벽하지 않고 많은 경우에 작동하지 않는다는 점에 주의한다.)</li> <li>-fPIE -pie/ -fno-PIE: 위치 독립적 코드(ASLR을 확장하여 라이브러리 뿐만 아니라 기본 바이너리도 무작위화 함). PIE는 일반적으로 32비트에서는 효과적이지 않다. 즉, PIE를 인식하지 못하는 악용은 수백/수천 번에 한 번씩 성공할 것이다. -fPIC는 메인 실행 파일의 일부가 아닌 코드에 적용될 수 있도록 (특정 최적화를 피함으로써) -fPIE의 버전이며, -fpie와 -fpic도 있다.</li> <li>Wl, -z, relro -z, now/ ?: FULL RELRO (GOT와 PLT가 프로그램 로드 중에 쓰여지고 읽기 전용으로 매핑됨).</li> </ul> <p data-ke-size="size16"> </p> <p data-ke-size="size16">보안이 더욱 주요 이슈가 되면서, 더 많은 컴파일 시간 및 런타임 보호 기능들이 기본적으로 활성화되고 있다.</p> <p data-ke-size="size16">따라서, 예상치 못한 상황을 피하기 위해 문제를 최종 구성 및 설정에서 실제로 테스트하는 것이 중요하다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Web Challenges</h3> <p data-ke-size="size16">문제에 많은 수의 요청이나, 타이밍 측정을 필요로 한다면, 원격으로도 합리적으로 해결할 수 있도록 해야한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">더 나아가, 같은 네트워크 상에 일반적인 스트립팅 언어와 라이브러리가 설치된 셸 서버(SSH 로그인이 가능한 pwnable 일 수 있음)을 두어 플레이얻르이 공격을 실행할 수 있게 하는 것이 좋다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">다음은 피해야 할 몇가지 사항들이다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>플레이어에게 URL 매개변수를 추측하도록 요구(e.g. ?debug=1)</li> <li>플레이어에게 파일이나 디렉터리 이름을 추측하도록 요구(또는 서버에 dirbuster 사용)</li> <li>플레이어에게 크리덴셜을 추측하도록 요구</li> </ul> <p data-ke-size="size16">(패턴을 알아채셨나요?)</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">웹 문제에서 훌륭한 유형 중 하나는 전체 소스 코드가 제공되는 것이다 (그럼에도 여전히 도전적인 경우).</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Reversing</h3> <p data-ke-size="size16">입력이 유효한지 확인하는 문제는 항상 정확히 하나의 정답을 받아들여야 하는 것이 매우 중요하다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이는 리버싱 문제에서 가장 흔한 문제를 일으키는 실수이다. 이것이 불가능한 경우, 문제 설명에서 이를 명확히 하고, 어떤 입력 플래그도 받아들이고 점수를 받을 수 있는 플래그 출력 양식을 마련한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">리버싱의 일반적인 리얼 월드 사례 중 하나는 악성 코드(malware)이지만, 악의적인 리버싱 문제를 배포하는 것은 나쁜 취향으로 간주된다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이렇게 하려는 경우, 해당 프로그램이 악성이라는 점을 명확히 명시해야 한다.</p> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Crypto</h3> <p data-ke-size="size16">일반적으로, 참가자들에게 가능한 많은 정보를 제공하려고 노력해야 한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">비밀 키가 명확하게 X로 표시된 소스코드와 함께 제공하는 것이 이상적이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">문제가 암호문만 있는 경우, 다음을 수행해보자:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>의미 있는 통계를 위해 충분한 암호문을 제공한다 (스무 개의 ASCII 문자는 거의 무엇이든 될 수 있다.)</li> <li>추측 가능한 알고리즘을 사용한다. 고전 암호와 짧은 암호문을 사용할 때, 그것을 좁혀내기는 매우 어려울 수 있다. 도전은 암호 시스템을 깨는 것이지, 암호 시스템이 무엇인지 알아내는 것이 아니다.</li> <li>19세기 이후에 만들어진 암호 시스템을 사용하는 경우, 참가자들에게 알고리즘이 무엇인지 반드시 알려주어야 한다. 아무도 암호문이 에니그마나 퍼플 머신에서 나온 것인지, 아니면 3DES나 GOST에서 나온 것인지 추측하고 싶어하지 않는다.</li> <li>문제가 많은 로컬 계산을 요구하는 경우, 합리적인 소비자 하드웨어에서 테스트하여야 한다. 문제를 해결하는 올바른 방법이 있지만 종료되기 전에 계산을 완료할 수 없다는 것을 대회 후반에 깨닫는 것은, 기분이 좋지 않다. 일반적으로 현대적인 소비자 하드웨어에서 1시간 미만이면 괜찮다. 그 이상이라면 정당한 근거가 있어야 한다.</li> </ul> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Forensics</h3> <p data-ke-size="size16">포렌식은 다음과 같은 여러 요소가 혼합되어 포함될 수 있다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>네트워크(pcap 파일)</li> <li>Recon(CVE, 사람, 위치 식별)</li> <li>안티 포렌식 기술</li> </ul> <p data-ke-size="size16">대부분 포렌식 도전과제는 사건 대응과 연계될 수 있으며, 학습자에게 주의를 기울여 처리하는 방법을 가르친다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">이는 파일을 실행하거나 부주의하게 다루면(도전 과제의) 데이터 손실이나 문제를 해결하는데 필요한 중요한 정보의 손실로 이어질 수 있다는 것을 의미한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">예를 들어, 포렌식 전문가들은 데이터의 무결성이 법정에서 사용될 경우, 진실되고 유효하게 유지되도록 하는 방법으로 쓰기 방지 도구를 사용한다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">도전 과제는 플레이어들을 하나의 여정, 여러 데이터 소스를 통한 조사로 이끌어 결국 하나의 해결책으로 귀결되도록 해야 한다.</p> <p data-ke-size="size16"> </p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>네트워크 도전 과제(.pcap 등)를 만들 때, “TCP 스트림 따라가기” 과정보다는 플레이어가 데이터의 다양한 출처와 목적지, 그들 사이의 타이밍을 이해하고 이를 스토리로 매핑하도록 하기를 바란다.</li> <li>기본적인 인코딩, 암호화 또는 사용자 정의 프로토콜을 추가하는 것은 더 고급 도전과제에 훌륭할 수 있지만, 네트워크 포렌식 도전 과제를 암호학 문제 정의로 바꾸지 않도록 주의해야 한다.; 여기서 강조하고 싶은 기술은 네트워크 개념과 기술을 이해하고 wireshark/tshark/scapy를 자신있게 활용할 수 있는 플레이어의 능력을 강화하는 것이다.</li> <li>계획된 잡은/간섭이 있는 샌드박스에서 도전 과제를 만들자. 드롭박스 패킷이 날아다니는 로컬 기계에서 실행하지 않도록 한다.</li> <li>분명 사물인터넷(IoT) 기기, QR 코드 조회, 프록시/VPN을 통한 공격자 원본 IP 출처 찾기 등을 실험해보자. 이런 것들은 모두 유효한 실제 사례이며, 플레이어가 관찰하고 식별하며 분석할 것을 요구한다.</li> </ul> <p data-ke-size="size16"> </p> <h3 data-ke-size="size23">Miscellaneous</h3> <p data-ke-size="size16">가능한 다음은 피하도록 한다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>랜덤 게싱 문제</li> <li>zip파일이나 stego 프로그램의 비밀번호 크래킹</li> <li>스테가노 그래피 문제</li> <li>Metasploit, nessus, dirbuster 등을 실행하여 해결되는 모든 것, 좋은 CTF 문제에는 기술이 필요하다.</li> <li>시간이 많이 걸리는 Recon 문제</li> </ul> <p data-ke-size="size16"> </p> <h2 data-ke-size="size26">마치며</h2> <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5"> <p data-ke-size="size16">이상으로 문서의 번역을 마치며,</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">해당 글은 CTF를 운영하는 사람이나, CTF 참가자 모두에게 도움이 될 것으로 기대한다.</p> <p data-ke-size="size16">CTF 참가자는 CTF의 운영을 이해하고 어떤 문제들이 어떻게 출제되는 지 큰 그림을 그릴 수 있으며, CTF 운영자는 직접적으로 CTF에 어떤 문제를 출제하고 어떻게 운영해야하는 지 알 수 있기 때문이다.</p> <p data-ke-size="size16"> </p> <p data-ke-size="size16">(실제로 위 내용의 부적절한 사항에 해당하는 CTF들을 참가해본 경험이 자주 있었다.)</p> <p class="post-meta"> 1 min read   ·   May 3, 2024   ·   tistory.com </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a> </p> </li> </ul> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Jeongmin Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>